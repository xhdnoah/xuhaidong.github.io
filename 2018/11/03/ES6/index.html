<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Noah Xu"><title>《Understanding ECMAScript6》Notes · 电子月亮</title><meta name="description" content="ES6Block BindingsVar Declarations and HoistingVariable declarations using var are treated as if they are at the top of the function regardless of wher"><meta name="keywords" content><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">Electronic Moon</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/resume/resume.html">简历</a></li><li class="soc"><a href="https://github.com/xhdnoah" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="http://xhdnoah.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>《Understanding ECMAScript6》Notes</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2018-11-03</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/ECMAScript-6/" title="ECMAScript 6" class="a-tag">ECMAScript 6</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h1 id="Block-Bindings"><a href="#Block-Bindings" class="headerlink" title="Block Bindings"></a>Block Bindings</h1><h2 id="Var-Declarations-and-Hoisting"><a href="#Var-Declarations-and-Hoisting" class="headerlink" title="Var Declarations and Hoisting"></a>Var Declarations and Hoisting</h2><p>Variable declarations using <code>var</code> are treated as if they are at the top of the function regardless of where the actual declaration occurs; this is called <em>hoisting</em></p>
<h2 id="Block-Level-Declarations"><a href="#Block-Level-Declarations" class="headerlink" title="Block-Level Declarations"></a>Block-Level Declarations</h2><p>Block scopes,also called lexical scopes,are created:</p>
<ol>
<li>Inside of a function</li>
<li>Inside of a block<code>{}</code></li>
</ol>
<h3 id="Let-Declarations"><a href="#Let-Declarations" class="headerlink" title="Let Declarations"></a>Let Declarations</h3><p>The <code>let</code> declaration syntax is the same as the syntax for <code>var</code>,but limit the variable’s scope to only the current code block.Since <code>let</code>declarations are not hoisted to the top of the enclosing block,you may want to always place <code>let</code> declaration first in the block,so that they are available to the entire block.</p>
<h3 id="No-Redeclaration"><a href="#No-Redeclaration" class="headerlink" title="No Redeclaration"></a>No Redeclaration</h3><pre><code>var count = 30;
// Syntax error
let count = 40;
</code></pre><h3 id="Constant-Declarations"><a href="#Constant-Declarations" class="headerlink" title="Constant Declarations"></a>Constant Declarations</h3><p>Variables declared using <code>const</code> are considered <em>~constants~</em>,meaning their values cannot be changed once set. For this reason,every <code>const</code> variable must be initialized on declaration.</p>
<h3 id="Constants-vs-Let-Declarations"><a href="#Constants-vs-Let-Declarations" class="headerlink" title="Constants vs Let Declarations"></a>Constants vs Let Declarations</h3><p>Constants,like <code>let</code> declarations,are block-level declarations.<br>In another similarity to <code>let</code>,a <code>const</code> declaration throws an error when made with an identifier for an already-defined variable in the same scope.<br>Despite those similarities,attempting to assign a <code>const</code> to a previously defined constant will throw an error.</p>
<h3 id="Declaring-Objects-with-Const"><a href="#Declaring-Objects-with-Const" class="headerlink" title="Declaring Objects with Const"></a>Declaring Objects with Const</h3><p>A <code>const</code> declaration prevents modification of the binding and not of the value itself. That means <code>const</code> declarations for objects do not prevent modification of those objects.</p>
<pre><code>const person = {
    name:”Nicholas”
};

//work
person.name = “Greg”;

//throws an error
person = {
    name:”Greg”
};
</code></pre><p>Just remember:<code>const</code> prevents modification of the binding, not modification of the bound value.</p>
<h3 id="The-Temporal-Dead-Zone"><a href="#The-Temporal-Dead-Zone" class="headerlink" title="The Temporal Dead Zone"></a>The Temporal Dead Zone</h3><p>A variable declared with either <code>let</code> or <code>const</code> cannot be accessed until after the declaration.</p>
<pre><code>if(condition){
    console.log(typeof value);//ReferenceError! value exists in what the JavaScript community has dubbed the temporal dead zone(TDZ)
    let value = “blue”;
}
</code></pre><h3 id="Block-Binding-in-Loops"><a href="#Block-Binding-in-Loops" class="headerlink" title="Block Binding in Loops"></a>Block Binding in Loops</h3><pre><code>for (var i=0;i&lt;10;i++){
    process(item[i]);
}

//i is still accessible here
console.log(i); //10
</code></pre><pre><code>for (let i=0;i&lt;10;i++){
    process(item[i]);
}

//i is not accessible here - throws an error
console.log(i);
</code></pre><h3 id="Function-in-Loops"><a href="#Function-in-Loops" class="headerlink" title="Function in Loops"></a>Function in Loops</h3><pre><code>for (var i=0;i&lt;10;i++){
    func.push(function(){console.log(i);});
}
funcs.forEach(function(func){
    func(); //outputs the number “10” ten times
})
</code></pre><p>The variable <code>i</code> is shared across each iteration of the loop,meaning the function created inside the loop all hode a reference to the same variable.The variable <code>i</code> has a value of <code>10</code> once the loop completes,and so when <code>console.log(i)</code> is called,that value prints each time.<br>To fix this problem,developers use immediately-invoked function expressions(IIFEs) inside of loops to force a new copy of the variable they want to iterate over to be created:</p>
<pre><code>var funcs = [];
for (var i=0;i&lt;10;i++){
    funcs.push((function(value){
        return function(){
            console.log(value);
        }
    }(i)));
}
funcs.forEach(function(funcs){
    func(); //outputs 0,then 1,then 2,up to 9
});
</code></pre><h3 id="Let-Declaration-in-Loops"><a href="#Let-Declaration-in-Loops" class="headerlink" title="Let Declaration in Loops"></a>Let Declaration in Loops</h3><pre><code>var func = [];
for (let i=0;i&lt;10;i++){
    func.push(function(){
        console.log(i);
    });
}
funcs.forEach(function(func){
    func(); //outputs 0,then 1,then 2,up to 9
})
</code></pre><p>The <code>let</code> declaration creates a new variable <code>i</code> each time through the loop,Each copy of <code>i</code> has the value it was assigned at the beginning of the loop iteration in which it was  created.</p>
<h3 id="Constant-Declarations-in-Loops"><a href="#Constant-Declarations-in-Loops" class="headerlink" title="Constant Declarations in Loops"></a>Constant Declarations in Loops</h3><p>For a normal <code>for</code> loop,u can use <code>const</code> in the initializer,but the loop will throw a warning if u attempt to change the value.<br>The <code>for-in</code> and <code>for-of</code> loops work with <code>const</code> because the loop initializer creates a new binging on each iteration through the loop rather than attempting to modify the value of an existing binding.</p>
<h3 id="Global-Block-Bindings"><a href="#Global-Block-Bindings" class="headerlink" title="Global Block Bindings"></a>Global Block Bindings</h3><p>Another way in which <code>let</code> and <code>const</code> are different from <code>var</code> is in their global scope behavior.When <code>var</code> is used in the global scope, it creates a new global variable,which is a property on the global object(<code>window</code> in browsers).<br>If you instead use <code>let</code> or <code>const</code> in the global scope,a new binding is created in the global scope but no property is added to the global object.That also means you cannot overwrite a global variable using <code>let</code> or <code>const</code>,you can only shadow it.</p>
<h3 id="Emerging-Best-Practices-for-Block-Bindings"><a href="#Emerging-Best-Practices-for-Block-Bindings" class="headerlink" title="Emerging Best Practices for Block Bindings"></a>Emerging Best Practices for Block Bindings</h3><p>As more developers migrates to ECAMScript 6,an alternate approach gained popularity:use <code>const</code> by default and only use <code>let</code> when you know a variable’s value needs to change. The rationale is that most variable should not change their value after initialization because unexpected value changes are a source of bugs.</p>
<h1 id="Strings-and-Regular-Expressions"><a href="#Strings-and-Regular-Expressions" class="headerlink" title="Strings and Regular Expressions"></a>Strings and Regular Expressions</h1><h2 id="Better-Unicode-Support"><a href="#Better-Unicode-Support" class="headerlink" title="Better Unicode Support"></a>Better Unicode Support</h2><p>Before ECMAScript 6, Javascript strings revolved around 16-bit character encoding(UTF-16). Each 16-bit sequence is a <em>code unit</em> representing a character.</p>
<h3 id="UTF-16-Code-Points"><a href="#UTF-16-Code-Points" class="headerlink" title="UTF-16 Code Points"></a>UTF-16 Code Points</h3><p>Code points are what you may think of as character codes,where a number represents a character. A character encoding must encode code points into code units that are internally consistent.<br>The first 2^16 code points in UTF-16 are represented as single 16-bit code units. This range is called the <em>Basic Multilingual Plane</em>(BMP). Everything beyond that is considered to be in one of the <em>supplementary planes</em>,where the code points can no longer be represented in just 16-bits. UTF-16 solves this problem by introducing <em>surrogate pairs</em> in which a single code point is represented by two 16-bit code units.</p>
<h3 id="The-codePointAt-Method"><a href="#The-codePointAt-Method" class="headerlink" title="The codePointAt() Method"></a>The codePointAt() Method</h3><p>One method ECMAScript 6 added to fully support UTF-16 is the <code>codePointAt()</code> method,which retrieves the Unicode code point that maps to a given position in a string. This method accepts the code unit position and returns an integer value</p>
<pre><code>var text = “𠮷a”;
console.log(text.charCodeAt(0)); //55362
console.log(text.charCodeAt(1));    //57271
console.log(text.charCodeAt(2));    //97

console.log(text.codePointAt(0));   //134071
console.log(text.codePointAt(1));   //57271
console.log(text.codePointAt(2));   //97
</code></pre><p>The<code>codePointAt</code>method returns the same value as the<code>charCodeAt</code>method unless it operates on non-BMP characters. The first character in<code>text</code>is non-BMP and is therefore comprised of two code units,meaning the length property is 3 rather than 2. The <code>charCodeAt()</code> returns only the first code units for position 0,but <code>codePointAt()</code> returns the full code point even though the code point spans multiple code units.<br>Calling the <code>codePointAt</code> method on a character is the easiest way to determine if that character is represented by one or two code points:</p>
<pre><code>function is32Bit(c){
    return c.codePointAt(0) &gt; 0xFFFF;
}
console.log(is32Bit(“𠮷”));  //true
console.log(is32Bit(“a”));  //false
</code></pre><h3 id="The-String-fromCodePoint-Method"><a href="#The-String-fromCodePoint-Method" class="headerlink" title="The String.fromCodePoint() Method"></a>The String.fromCodePoint() Method</h3><p><code>console.log(String.fromCodePoint(134071)); //“𠮷”</code></p>
<h3 id="The-normalize-Method"><a href="#The-normalize-Method" class="headerlink" title="The normalize() Method"></a>The normalize() Method</h3><p>This method optionally accepts a single string parameter indicating one of the following Unicode normalization forms to apply:</p>
<ul>
<li>Normalization Form Canonical Composition(“NFC”),which is the default</li>
<li>Normalization Form Canonical Decomposition(“NFD”)</li>
<li>Normalization Form Compatibility Composition (“NFKC” ) </li>
<li>Normalization Form Compatibility Decomposition (“NFKD” )</li>
</ul>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><h2 id="Functions-with-Default-Parameter-Values"><a href="#Functions-with-Default-Parameter-Values" class="headerlink" title="Functions with Default Parameter Values"></a>Functions with Default Parameter Values</h2><p>Functions in JavaScript are unique in that they allow any number of parameters to be passed,regardless of the number of parameters declared in the function definition. This allows you to define functions that can handle different numbers of parameters,often by just filling in default values when parameters aren’t provided.</p>
<h3 id="Simulating-Default-Parameter-Values-in-ECMAScript-5"><a href="#Simulating-Default-Parameter-Values-in-ECMAScript-5" class="headerlink" title="Simulating Default Parameter Values in ECMAScript 5"></a>Simulating Default Parameter Values in ECMAScript 5</h3><p>In ECMAScript 5,you would like to use the following pattern to create a function with default parameters values:</p>
<pre><code>function makeRequest(url,timeout,callback){
    timeout = timeout||2000;
    callback = callback||function(){};
    //the rest of the function
}
</code></pre><p>Both <code>timeout</code> and <code>callback</code> are actually optional because they are given a default value if a parameter isn’t provided. The logic OR operator(<code>||</code>)always returns the second operand when the first is false. Since named function parameters that are not explicitly provided are set to <code>undefined</code>,the logical OR operator is frequently used to provided default values for missing parameters.</p>
<h3 id="Default-Parameters-Values-in-ECMAScript-6"><a href="#Default-Parameters-Values-in-ECMAScript-6" class="headerlink" title="Default Parameters Values in ECMAScript 6"></a>Default Parameters Values in ECMAScript 6</h3><p>ECMAScript 6 makes it easier to provide default values for parameters by providing initialization that are used when the parameter isn’t formally passed:</p>
<pre><code>function makeRequest(url,timeout = 2000,callback = function(){}){
    //the rest of the function
}
</code></pre><p>When <code>makeRequest()</code>is called with all three parameters,the defaults are not used.</p>
<h3 id="How-Default-Parameter-Values-Affect-the-arguments-Object"><a href="#How-Default-Parameter-Values-Affect-the-arguments-Object" class="headerlink" title="How Default Parameter Values Affect the arguments Object"></a>How Default Parameter Values Affect the arguments Object</h3><p>Just keep in mind that the behavior of the <code>arguments</code> object is different when default parameter values are present. In ECMAScript 5 nonstrict mode,the <code>arguments</code> object reflects changes in the name parameters of a function.<br>In ECMAScript 6 ,regardless of whether the function is explicitly running in strict mode,the presence of default parameter values triggers the <code>arguments</code> object to remain detached from the named parameters:</p>
<pre><code>function mixArgs(first,second = “b”){
    console.log(arguments.length);
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = “c”;
    second = “d”
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}
mixArgs(“a”);

//1
//true
//false
//false
//false
</code></pre><h3 id="Default-Parameter-Expressions"><a href="#Default-Parameter-Expressions" class="headerlink" title="Default Parameter Expressions"></a>Default Parameter Expressions</h3><p>Default parameter value need not be a primitive value（基本类型值）,you can execute a function to retrieve the default parameter value.</p>
<blockquote>
<p>Be careful when using function calls as default parameter values. If you forget the parentheses,you are passing a reference to the function rather than the result of the function call.</p>
</blockquote>
<p>This behavior introduces another interesting capability. You can use a previous parameter as the default for a later parameter:</p>
<pre><code>function add(first,second = first){
    return first + second;
}

console.log(add(1,1));  //2
console.log(add(1));    //2
</code></pre><p>The ability to reference parameters from default parameter assignments works only for previous arguments,so earlier arguments do not have access to later arguments because of the temporal dead zone.</p>
<h2 id="Working-with-Unnamed-Parameters"><a href="#Working-with-Unnamed-Parameters" class="headerlink" title="Working with Unnamed Parameters"></a>Working with Unnamed Parameters</h2><p>Default parameter values make it clear when a function can accept fewer parameters,and ECMAScript 6 sought to make the problem of passing more parameters than defined better as well.</p>
<h3 id="Unnamed-Parameters-in-ECMAScript-5"><a href="#Unnamed-Parameters-in-ECMAScript-5" class="headerlink" title="Unnamed Parameters in ECMAScript 5"></a>Unnamed Parameters in ECMAScript 5</h3><p>Early on,JavaScript provided the <code>arguments</code>object as a way to <strong>inspect</strong> all function parameters that are passed without necessarily defining each parameter individually:</p>
<pre><code>function pick(object){
    let result = Object.create(null);
    //start at the second parameter
    for(let i=1;let=arguments.length;i++){
        result[arguments[i]]=object[arguments[i]];
    }
    return result;
}
let book = {
    title:”Understanding ECMAScript 6”,
    author:”Nicholas C.Zakas”,
    year:2015
};
let bookData = pick(book,”author”,”year”);
    console.log(bookData.author);   //“Nicholas C.Zakas”
console.log(bookData.year); //2015
</code></pre><p><code>pick()</code>method returns a copy of a given object with some specified subset of the original object’s properties.While inspecting <code>arguments</code> works fine in most cases,this object can be a little cumbersome to work with.</p>
<p>ECMAScript 6 introduces rest parameters to help with these issues.</p>
<h3 id="Rest-Parameters"><a href="#Rest-Parameters" class="headerlink" title="Rest Parameters"></a>Rest Parameters</h3><p>A <em>rest parameter</em> is indicated by three dots(<code>...</code>)preceding a named parameter. That named parameter becomes an Array containing the rest of the parameters passed to the function. For example, <code>pick()</code> can be written using rest parameters,like this:</p>
<pre><code>function pick(object,...key){
    let result = Object.create(null);
    for(let i=0,len=keys.length;i&lt;len;i++){
        result[keys[i])=object[keys[i]];
    }
    return result;
}
</code></pre><p><code>keys</code> is a rest parameter that contains all parameters passed after <code>object</code>(unlike <code>arguments</code>,which contains all parameters including the first one).</p>
<blockquote>
<p>Rest parameters do not affect a function’s <code>length</code> property,which indicates the number of named parameters for the function. </p>
</blockquote>
<h3 id="Rest-Parameter-Restrictions"><a href="#Rest-Parameter-Restrictions" class="headerlink" title="Rest Parameter Restrictions"></a>Rest Parameter Restrictions</h3><p>There are two restrictions on rest parameters. The first is that there can be only only one rest parameter, and the rest parameter must be last.<br>The second restriction is that rest parameters cannot be used in an object literal setter:</p>
<pre><code>let object = {
    //Syntax error: Can’t use rest parameter in setter
    set name(...value){
        //do something
    }
};
</code></pre><p>This restriction exists because object literal setters are restricted to a single argument.</p>
<h3 id="How-Rest-Parameters-Affect-the-arguments-Object"><a href="#How-Rest-Parameters-Affect-the-arguments-Object" class="headerlink" title="How Rest Parameters Affect the arguments Object"></a>How Rest Parameters Affect the arguments Object</h3><p>The <code>arguments</code> object works together with rest parameters by reflecting the arguments that were passed to the function when called,as illustrated in this program:</p>
<pre><code>function checkArgs(...args){
    console.log(args.length);
    console.log(arguments.length);
    console.log(args[0],arguments[0]);
    console.log(args[1],arguments[1]);
}
checkArgs(“a”,”b”);
</code></pre><pre><code>//outputs
2
2
a a
b b
</code></pre><p>The <code>arguments</code> object always correctly reflects the parameters  that were passed into a function regardless of rest parameter usage.</p>
<h2 id="Increased-Capabilities-of-the-Function-Constructor"><a href="#Increased-Capabilities-of-the-Function-Constructor" class="headerlink" title="Increased Capabilities of the Function Constructor"></a>Increased Capabilities of the Function Constructor</h2><p>The <code>Function</code> constructor is an infrequently used part of Javascript that allows you to dynamically create a new function. The arguments to the constructor are the parameters for the function and the function body, all as strings:</p>
<pre><code>var add = new Function(“first”,”second”,”return first + second”);
console.log(add(1,1));  //2
</code></pre><p>ECMAScript 6 augments the capabilities of the <code>Function</code> constructor to allow default parameters and rest parameters. You need only add an equals sign and a value to the parameter names, as follows:</p>
<pre><code>var add = new Function(“first”,second = first”,”return first+second”);
console.log(add(1,1));  //2
console.log(add(1));    //2
</code></pre><p>For rest parameters,just add the <code>...</code> before the last parameter:</p>
<pre><code>var pickFirst = new Function(“...args”,”return args[0]”);
console.log(pickFirst(1,2));    //1
</code></pre><h2 id="The-Spread-Operator"><a href="#The-Spread-Operator" class="headerlink" title="The Spread Operator"></a>The Spread Operator</h2><p>While <strong>rest parameters</strong> allow you to specify that multiple independent arguments should be combined into an array, the <strong>spread operator</strong> allows you to specify an array that should be split and have its items passed in as separate arguments to a function:</p>
<pre><code>let value1 = 25, value2 = 50;
console.log(Math.max(value1,value2));   //50
</code></pre><p>The <code>Math.max</code> method doesn’t allow you to pass in an array, so in ECMAScript 5 and earlier,you’d stuck either searching the array yourself using <code>apply(Math,array)</code></p>
<p>The ECMAScript 6 spread operator makes this case very simple. Instead of calling<code>apply()</code>, you can pass the array to <code>Math.max()</code>directly and prefix it with the same <code>...</code> pattern used with rest parameters. The JavaScript engine then splits the array into individual arguments and passes them in:</p>
<pre><code>let values = [25,50,75,100]

//equivalent to 
//console.log(Math.max(25,50,75,100));
console.log(Math.max(...values));   //100
</code></pre><p>You can mix and match the spread operator with other arguments as well:</p>
<pre><code>let values = [-25,-50,-75,-100]
console.log(Math.max(...values,0)); //0
</code></pre><h2 id="ECMAScript-6’s-name-Property"><a href="#ECMAScript-6’s-name-Property" class="headerlink" title="ECMAScript 6’s name Property"></a>ECMAScript 6’s name Property</h2><p>Identifying functions can be challenging in JavaScript given the various ways a function can be defined. Additionally, the prevalence of  anonymous function expressions makes debugging a bit more difficult, often resulting in stack traces that are hard to read and decipher. For these reasons, ECMAScript 6 adds the <code>name</code> property to all functions.</p>
<h3 id="Special-Cases-of-the-name-Property"><a href="#Special-Cases-of-the-name-Property" class="headerlink" title="Special Cases of the name Property"></a>Special Cases of the name Property</h3><pre><code>var doSomething = function doSomethingElse(){
    //...
};
var person = {
    get firstName(){
        return “Nicholas”
    },
    sayName:function(){
        console.log(this.name);
    }
}

console.log(doSomething.name);  //“doSomethingElse”
console.log(person.sayName.name);   //“sayName”

var descriptor = Object.getOwnPropertyDescriptor(person,”firstName”);
console.log(descriptor.get.name);   //“get firstName”
</code></pre><p><code>person.firstName</code> is actually a getter function, so its name is <code>”get firstName”</code> to indicate this difference. Setter function are prefixed with <code>”set”</code> as well.(Both getter and setter functions must be retrieved using <code>Object.getOwnPropertyDescriptor()</code>)<br>There are a couple of other special cases for function names,too. Functions created using <code>bind()</code>will have their names prefixed with <code>”bound”</code> and functions created using the <code>Function</code> constructor have a name of <code>”anonymous”</code></p>
<blockquote>
<p>The <code>name</code> property is meant to be informative, to help with debugging, so there’s no way to use the value of <code>name</code> to get a reference to the function.</p>
</blockquote>
<h2 id="Clarifying-the-Dual-Purpose-of-Functions"><a href="#Clarifying-the-Dual-Purpose-of-Functions" class="headerlink" title="Clarifying the Dual Purpose of Functions"></a>Clarifying the Dual Purpose of Functions</h2><p>In ECMAScript 5 and earlier, functions serve the dual purpose of being callable with or without <code>new</code>. When used with <code>new</code>,the <code>this</code> value inside a function is a new object and that new object is returned:</p>
<pre><code>function Person(name){
    this.name = name;
}

var person = new Person(“Nicholas”);
var notAPerson = Person(“Nicholas”);

console.log(person);    //“[Object object]”
console.log(notAPerson);    //“undefined”
</code></pre><p>The confusion over the dual roles of functions led to some changes in ECMAScript 6.<br>Javascript has two different internal-only methods for functions:<code>[[Call]]</code>and<code>[[Construct]]</code>. When a function is called without <code>new</code>, the <code>[[Call]]</code> method is executed,which executes the body of the function as it appears in the code. When the function is called with <code>new</code>, that’s when the <code>[[Construct]]</code> method is called. The <code>[[Construct]]</code> method is responsible for creating a new object, called the <em>new target</em>, and then executing the function body with <code>this</code> set to the new target. Function that have a <code>[[Construct]]</code> method are called <em>constructors</em>.</p>
<blockquote>
<p>Keep in mind that not all functions have <code>[[Construct]]</code>,and therefore not all functions can be called with <code>new</code>, such as Arrow Functions.</p>
</blockquote>
<h3 id="Determine-How-a-Function-was-Called-in-ECMAScript-5"><a href="#Determine-How-a-Function-was-Called-in-ECMAScript-5" class="headerlink" title="Determine How a Function was Called in ECMAScript 5"></a>Determine How a Function was Called in ECMAScript 5</h3><p>The most popular way to determine if a function was called with <code>new</code>(and hence,with constructor) in ECMAScript 5 is to use <code>instanceof</code>:</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        this.name = name;   //using new
    } else {
        throw new Error(“You must use new with Person.”)
    }
}
</code></pre><p>Unfortunately, this approach is not completely reliable because <code>this</code> can be an instance of <code>Person</code> without using <code>new</code>:<br><code>var person = Person.call(person.”Michael”);    //works!</code><br>The call to <code>Person.call()</code> passes the <code>person</code> variable as the first argument, which means <code>this</code> is set to <code>person</code> inside of the <code>Person</code> function.</p>
<h3 id="The-new-target-MetaProperty"><a href="#The-new-target-MetaProperty" class="headerlink" title="The new.target MetaProperty"></a>The new.target MetaProperty</h3><p>To solve this problem, ECMAScript 6 introduces the <code>new.target</code> <em>metaproperty</em>. A <em>metaproperty</em> is a property of a non-object that provides additional information related to its target(such as <code>new</code>). When a function’s <code>[[Construct]]</code> method is called, <code>new.target</code> is filled with the target of the <code>new</code> operator. That target is typically the constructor of the newly created object instance that will become <code>this</code> inside the function body. If <code>[[Call]]</code> is executed, then <code>new.target</code> is <code>undefined</code>.</p>
<pre><code>function Person(name){
    if(typeof new.target !== “undefined”){
        this.name = name;   //using new
    } else {
        throw new Error(“You must use new with Person.”)
    }
}
</code></pre><p>You can also check that <code>new.target</code> was called with a specific constructor:</p>
<pre><code>function Person(name){
    if(new.target === Person){
        this.name = name;   //using new
    } else {
        throw new Error(“You must use new with Person.”)
    }
}
function AnotherPerson(name){
    Person.call(this,name);
}

var person = new Person(“Nicholas”);
var anotherPerson = new AnotherPerson(“Nicholas”);  //error!
</code></pre><blockquote>
<p>Warning: Using <code>new.target</code> outside of a function is a syntax error.</p>
</blockquote>
<p>By adding <code>new.target</code>, ECMAScript 6 helped to clarify some ambiguity around functions calls. Following on this theme, ECMAScript 6 also addresses another previously ambiguous part of the language: declaring functions inside of blocks.</p>
<h2 id="Block-Level-Functions"><a href="#Block-Level-Functions" class="headerlink" title="Block-Level Functions"></a>Block-Level Functions</h2><pre><code>“use strict”
if(true){
    console.log(typeof doSomething);    //“function”
    function doSomething(){
        //...
    }
    doSomething();
}

console.log(typeof doSomething);    //“undefined”
</code></pre><p>Block level functions are hoisted to the top of the block in which they are defined. Once the <code>if</code> block is finished executing, <code>doSomething</code> no longer exists.</p>
<h3 id="Deciding-When-to-Use-Block-Level-Functions"><a href="#Deciding-When-to-Use-Block-Level-Functions" class="headerlink" title="Deciding When to Use Block-Level Functions"></a>Deciding When to Use Block-Level Functions</h3><p>Block level functions are similar to <code>let</code> function expressions in that the function definition is removed once execution flows out of the block in which it’s defined. The key difference is that block level functions are hoisted to the top of the containing block. Function expressions that use <code>let</code> are not hoisted. Knowing this difference, you can choose whether to use block level functions or <code>let</code> expressions based on whether or not you want the hoisting behavior.</p>
<h3 id="Block-Level-Functions-in-Nonstrict-Mode"><a href="#Block-Level-Functions-in-Nonstrict-Mode" class="headerlink" title="Block-Level Functions in Nonstrict Mode"></a>Block-Level Functions in Nonstrict Mode</h3><p>ECMAScript 6 also allows block-level functions in nonstrict mode, but the behavior is slightly different. Instead of hoisting these declarations to the top of the block, they are hoisted all the way to the containing function or global environment. For example:</p>
<pre><code>//ECMAScript 6 behavior
if(true){
    console.log(typeof doSomething);    //“function”
    function doSomething(){
    //...
    }
    doSomething();
}
console.log(typeof doSomething);    //“function”
</code></pre><h2 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h2><p>Arrow functions are,as the same suggests, functions defined with a new syntax that uses an “arrow”(<code>=&gt;</code>). But arrow functions behave differently than traditional JavaScript functions in a number of important ways:</p>
<pre><code>* No `this`,`super`,`arguments`, and `new.target` bindings - The value of `this`,`super`,`arguments` and`new.target` inside of the function is by the closest containing no arrow function.
* Cannot be called with `new` - Arrow functions do not have a `[[Construct]]` method and therefore cannot be used as constructors.
* **No prototype** - since you can’t use `new` on an arrow function, there’s no need for a prototype.
* Can’t change `this` - The value of `this` inside of the function can’t be changed. It remains the same throughout the entire lifestyle of the function.
* No `arguments` object - Since arrow functions have no `arguments` binding, you must rely on named and rest parameters to access function arguments.
* **No duplicate named parameters** - arrow functions cannot have duplicate named parameters in strict or nonstrict mode, as opposed to nonarrow functions that cannot have duplicate named parameters only in strict mode.
</code></pre><p>First and foremost, <code>this</code> binding is a common source of error in JavaScript. It’s very easy to lose track of the <code>this</code> value inside a function,which can result in unintended program behavior, and arrow functions eliminate this confusion. Second, by limiting arrow functions to simply executing code with a single <code>this</code> value, JavaScript engines can more easily optimize these operations, unlike regular functions, which might be used as a constructor or otherwise modified.</p>
<blockquote>
<p>Note: Arrow functions also have a <code>name</code> property that follows the same rules as other functions.</p>
</blockquote>
<h3 id="Arrow-Function-Syntax"><a href="#Arrow-Function-Syntax" class="headerlink" title="Arrow Function Syntax"></a>Arrow Function Syntax</h3><p>The syntax for arrow functions comes in many flavors depending upon what you’re trying to accomplish. All variations begin with function arguments, followed by the arrow, followed by the body of the function. Both the arguments and the body can take different forms depending on usage.</p>
<pre><code>var reflect = value =&gt; value;
var sum = (num1,num2) =&gt; num1 + num2;
var getName = () =&gt; “Nicholas”;
var sum = (num1,num2) =&gt; {
    return num1 + num2;
};
var doNothing = () =&gt; {};
var getTempItem = id =&gt; ({id:id,name:”Temp”});  
//Wrapping the object literal in parentheses signals that the braces are an object literal instead of the function body.
</code></pre><h3 id="Creating-Immediately-Invoked-Function-Expressions"><a href="#Creating-Immediately-Invoked-Function-Expressions" class="headerlink" title="Creating Immediately-Invoked Function Expressions"></a>Creating Immediately-Invoked Function Expressions</h3><p>One popular use of functions in Javascript is creating immediately-invoked function expressions(IIFEs). IIFEs allow you to define an anonymous function and call it immediately without saving a reference. This pattern comes in handy when you want to create a scope that is shielded from the rest of a program:</p>
<pre><code>let person = function(name){
    return{
        getName:function(){
            return name;
        }
    };
}(“Nicholas”);

console.log(person.getName());  //“Nicholas”
</code></pre><p>You can accomplish the same thing using arrow functions, so long as you wrap the arrow function in parentheses:</p>
<pre><code>let person = ((name) =&gt; {
    return {
        getName:function(){
            return name;
        }
    };
})(“Nicholas”);
console.log(person.getName());  //“Nicholas”
</code></pre><p>Note that the parentheses are only around the arrow function definition, and not around <code>(“Nicholas”)</code>. This is different from a formal function,where the parentheses can be placed outside of the passed-in parameters as well as just around the function definition.</p>
<h3 id="No-this-Binding"><a href="#No-this-Binding" class="headerlink" title="No this Binding"></a>No this Binding</h3><p>Since the value of <code>this</code> can change inside a single function depending on the context in which the function is called, it’s possible to mistakenly affect one object when you meant to affect another:</p>
<pre><code>var PageHandler = {
    id:”123456”,
    init:function(){
        document.addEventListener(“click”,function(event){
            this.doSomething(event.type);   //error
        }, false);
    },
    doSomething:function(type){
        console.log(“Handling” + type + “for” + this.id);
    }
};
</code></pre><p>The call to <code>this.doSomething</code> is broken because <code>this</code> is a reference to the object that was the target of the event(in this case <code>document</code>),instead of being bound to <code>PageHandler</code>. You can fix this by binding the value of <code>this</code> to <code>PageHandler</code> explicitly using the <code>bind()</code> method on the function instead,like:</p>
<pre><code>...
init:function(){
    document.addEventListener(“click”,(function(event){
        this.doSomething(event.type);   // no error
    }).bind(this),false);
},
...
</code></pre><p>By calling <code>bind(this)</code>, you’re actually creating a new function whose <code>this</code> is bound to the current <code>this</code>, which is <code>PageHandler</code>.</p>
<p>Arrow functions have no <code>this</code> binding, which means the value of <code>this</code> inside an arrow function can only be determined by looking up the scope chain. If the arrow function is contained within a nonarrorw function, <code>this</code> will be the same as the containing function; otherwise,<code>this</code> is equivalent to the value of <code>this</code> in the global scope. Here’s one way you could write this code using an arrow function:</p>
<pre><code>...
    init:function(){
        document.addEventListener(“click”,event =&gt; this.doSomething(event.type), false);
    },
...
</code></pre><p>Arrow functions are designed to be “throwaway” functions,and so cannot be used to define new types; this is evident from the missing <code>prototype</code> property.</p>
<h3 id="Arrow-Functions-and-Arrays"><a href="#Arrow-Functions-and-Arrays" class="headerlink" title="Arrow Functions and Arrays"></a>Arrow Functions and Arrays</h3><p>The concise syntax for arrow functions makes them ideal for use with array processing, too. For example:<br><code>var result = values.sort((a,b) =&gt; a-b);</code><br>The array methods that accept callback functions such as <code>sort()</code>,<code>map()</code> and <code>reduce()</code> can all benefit from simpler arrow function syntax.</p>
<h3 id="No-arguments-Binding"><a href="#No-arguments-Binding" class="headerlink" title="No arguments Binding"></a>No arguments Binding</h3><p>Even though arrow functions don’t have their own <code>arguments</code> object, it’s possible for them to access the <code>arguments</code> object from a containing function. That <code>arguments</code> object is then available no matter where the arrow function is executed later on. Even though the arrow function is no longer in the scope of the function that created it, <code>arguments</code> remains accessible due to scope chain resolution of the <code>arguments</code> identifier.</p>
<p>Arrow functions are appropriate to use anywhere you’re currently using an anonymous function expression,such as with callback.</p>
<h3 id="Tail-Call-Optimization"><a href="#Tail-Call-Optimization" class="headerlink" title="Tail Call Optimization"></a>Tail Call Optimization</h3><p>A <em>tail call</em> is when a function is called as the last statement in another function:</p>
<pre><code>function doSomething(){
    return doSomethingElse();   //tail call
} 
</code></pre><p>Tail calls as implemented in ECMAScript 5 engines are handled just like any other function call: a new stack frame is created and pushed onto the call stack to represent the function call. That means every previous stack frame is kept in memory, which is problematic when the call stack gets too large.</p>
<h3 id="What’s-Different"><a href="#What’s-Different" class="headerlink" title="What’s Different?"></a>What’s Different?</h3><p>ECMAScript 6 seeks to reduce the size of the call stack for certain tail calls in strict mode. With this optimization, instead of creating a new stack frame for a tail call, the current stack frame is cleared and reused so long as the following conditions are met:</p>
<ul>
<li>The tail call does not require access to variable in the current stack frame(meaning the function is not a closure)</li>
<li>The function making the tail call has no further work to do after the tail call returns.</li>
<li>The result of the tail call is returned as the function value.</li>
</ul>
<p>As an example,this code can easily be optimized because it fits all three criteria:</p>
<pre><code>“use strict”;
function doSomething(){
    //optimized
    return doSomethingElse();
}
</code></pre><h3 id="How-to-Harness-Tail-Call-Optimization"><a href="#How-to-Harness-Tail-Call-Optimization" class="headerlink" title="How to Harness Tail Call Optimization"></a>How to Harness Tail Call Optimization</h3><p>In practice, tail call optimization happens behind-the-scenes. The primary use cases for tail call optimization is in recursive functions, as that is where the optimization has the greatest effect. Consider this function,which computes factorials:</p>
<pre><code>functions factorial(n){
    if(n &lt;= 1){
        return 1;
    } else {
        // not optimized - must multiply after returning
        return n * factorial(n-1);
    }
}
</code></pre><p>If <code>n</code> is very large number, the call stack size will grow and could potentially cause a stack overflow.<br>In order to optimized the function, you can use a default parameter to move the multiplication operation outside of the <code>return</code> statement:</p>
<pre><code>function factorial(n,p = 1){
    if(n &lt;= 1){
        return 1 * p;
    } else {
        let result = n * p;
        //optimized
        return factorial(n-1,result);
    }
}
</code></pre><p>In this rewritten version of <code>factorial()</code>, a second argument <code>p</code> holds the previous multiplication result so that the next result can be computed without another function call.</p>
<p>Tail call optimization is something you should think about whenever you’re writing a recursive function, as it can provide a significant performance improvement.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Default functions parameters allow you to easily specify what value to use when a particular argument isn’t passed,</p>
<p>Rest parameters allow you to specify an array into which all remaining parameters should be placed. Using a real array and letting you indicate which parameters to include makes rest parameters a much more flexible solution than <code>arguments</code>.</p>
<p>The spread operator is a companion to rest parameters, allowing you to deconstruct an array into separate parameters when calling a function. With the spread operator, you can easily pass an array to any function without worrying about the <code>this</code> binding of the function.</p>
<p>The addition of the <code>name</code> property should help you more easily identify functions for debugging and evaluation purposes. Additionally, ECMAScript 6 formally defines the behavior of block-level functions.</p>
<p>In ECMAScript 6, the behavior of a function is defined by <code>[[Call]]</code>, normal function execution, and <code>[[Construct]]</code>, when a function is called with <code>new</code>. The <code>new.target</code> metaproperty also allows you to determine if a function was called using <code>new</code>or not.</p>
<p>Arrow functions are designed to be used in place of anonymous function expressions.</p>
<p>Tail call optimization allows some function calls to be optimized in order to keep a smaller call stack,use less memory, and prevent stack overflow errors. You may decide to rewrite recursive functions in order to take advantages of this optimization.</p>
<h1 id="Expanded-Object-Functionality"><a href="#Expanded-Object-Functionality" class="headerlink" title="Expanded Object Functionality"></a>Expanded Object Functionality</h1><p>ECMAScript 6 focuses heavily on improving the utility of objects, which makes sense because nearly every value in JavaScript is some type of object.<br>ECMAScript 6 improves objects in a number of ways, from simple syntax extensions to options for manipulating and interacting with them.</p>
<h2 id="Object-Categories"><a href="#Object-Categories" class="headerlink" title="Object Categories"></a>Object Categories</h2><p>Javascript uses a mix of terminology to describe objects found in the standard as opposed to those added by execution environments such as the browser or Node.js, and the ECMAScript 6 specification has clear definition for each category of object.</p>
<ul>
<li><em>Ordinary objects</em> Have all the default internal behavior for objects in JavaScript.</li>
<li><em>Exotic objects</em> Have internal behavior that differs from the default in some way.</li>
<li><em>Standard objects</em> Are those defined by ECMAScript 6,such as <code>Array</code>,<code>Date</code>,and so on. Standard objects may be ordinary or exotic.</li>
<li><em>Built-in object</em> Are present in a JavaScript execution environment when a script begins to execute. All standard objects are built-in objects.</li>
</ul>
<h2 id="Object-Literal-Syntax-Extensions"><a href="#Object-Literal-Syntax-Extensions" class="headerlink" title="Object Literal Syntax Extensions"></a>Object Literal Syntax Extensions</h2><h3 id="Property-Initializer-Shorthand"><a href="#Property-Initializer-Shorthand" class="headerlink" title="Property Initializer Shorthand"></a>Property Initializer Shorthand</h3><p>In ECMAScript 5 and earlier, object literals were simply collections of name-value pairs. That meant there could be some ~duplication~ when property values are initialized:</p>
<pre><code>function createPerson(name,age){
    return {
        name:name,
        age:age
    };
}
</code></pre><p>In ECMAScript 6, you can eliminate the duplication that exists around property names and local variables by using the <em>property initializer</em> shorthand.</p>
<pre><code>function createPerson(name,age){
    return {
        name,
        age
    };
}
</code></pre><p>When a property in an object literal only has a name, the JavaScript engine looks into the surrounding scope for a variable of the same name. If it find one, that variable’s value is assigned to the same name on the object literal. In this example, the object literal property <code>name</code> is assigned the  value of the local variable <code>name</code>.</p>
<h3 id="Concise-Methods"><a href="#Concise-Methods" class="headerlink" title="Concise Methods"></a>Concise Methods</h3><p>ECMAScript 6 also improves the syntax for assigning methods to object literals. In ECMAScript 5 and earlier, you must specify a name and then the full function definition to add a method to an object, as follows:</p>
<pre><code>var person = {
    name:”Nicholas”,
    sayName: function(){
        console.log(this.name);
    }
};
</code></pre><p>In ECMAScript 6, the syntax is made more concise by eliminating the colon and the <code>function</code> keyword:</p>
<pre><code>var person = {
    name:”Nicholas”,
    sayName(){
        console.log(this.name);
    }
};
</code></pre><p>The <code>sayName()</code> property is assigned an anonymous function and has all the same characteristics as the ECMAScript 5 <code>sayName()</code> function. The one difference is that concise methods may use <code>super</code>, while the nonconcise methods may not.</p>
<h3 id="Computed-Property-Names"><a href="#Computed-Property-Names" class="headerlink" title="Computed Property Names"></a>Computed Property Names</h3><p>ECMAScript 5 and earlier could compute property names on object instances when those properties were set with square brackets instead of dot notation. The square brackets allow you to specify property names using variable and string literals.</p>
<pre><code>var person = {},
      lastName = “last name”;
person[“first name”] = “Nicholas”;
person[lastName] = “Zakas”;
</code></pre><p>In ECMAScript 6, computed property names are part of the object literal syntax, and they use the same square bracket notation that has been used to reference computed property names in object instances:</p>
<pre><code>var lastName = “last name”;
var person = {
    “first name”:”Nicholas”,
    [lastName]:”Zakas”
};
console.log(person[“first name”]);
console.log(person[lastName]);
</code></pre><p>The square brackets inside the object literal indicate that the property name is computed, so its contains are evaluated as a string. That means you can also include expressions such as:</p>
<pre><code>var suffix = “ name”;
var person = {
    [“first” + suffix]:”Nicholas”,
    [“last” + suffix]:”Zakas”
};
</code></pre><h2 id="New-Methods"><a href="#New-Methods" class="headerlink" title="New Methods"></a>New Methods</h2><p>One of the design goals of ECMAScript beginning with ECMAScript 5 was to avoid creating new global functions or methods on <code>Object.prototype</code>, and instead try to find objects on which new methods should be available. ECMAScript 6 introduces a couple new methods on the <code>Object</code> global that are designed to make certain tasks easier.</p>
<h3 id="The-Object-is-Method"><a href="#The-Object-is-Method" class="headerlink" title="The Object.is() Method"></a>The Object.is() Method</h3><p>ECMAScript 6 introduces the <code>Object.is()</code> method to make up for the remaining quirks of the identically euqals operator(<code>===</code>).</p>
<pre><code>console.log(+0 === -0); //true
console.log(Object.is(+0,-0));  //false
console.log(NaN === NaN);   //false
console.log(Object.is(NaN,NaN));    //true
</code></pre><h3 id="The-Object-assign-Method"><a href="#The-Object-assign-Method" class="headerlink" title="The Object.assign() Method"></a>The Object.assign() Method</h3><p><em>Mixins</em> are among the most popular patterns for object composition in JavaScript. In a mixin, one object receives properties and methods from another object. Many JavaScript libraries have a mixin method similar to this:</p>
<pre><code>function mixin(receiver,supplier){
    Object.key(supplier).forEach(function(key){
        receiver[key] = supplier[key];
    });
    return receiver;
}
</code></pre><p>The <code>mixin</code> function iterates over the own properties of <code>supplier</code> and copies them onto <code>receiver</code>(a shallow copy, where object reference are shared with property values are objects). This allows the <code>receiver</code> to gain new properties without inheritance,as in this code:</p>
<pre><code>function EventTarget(){/*...*/}
EventTarget.prototype = {
    constructor:EventTarget,
    emit:function(){/*...*/},   //publish events
    on:function(){/*...*/}
};      //subscribe to events

var myObject = {};
mixin(myObject,EventTarget.prototype);

myObject.emit(“somethingChanged”);
</code></pre><p>This pattern became popular enough that ECMAScript 6 added the <code>Object.assign()</code> method,which behaves the same way,accepting a receiver and any number of suppliers, and then returning the receiver. Since the <code>mixin()</code> function uses the assignment operator (<code>=</code>), it cannot copy accessor properties to the receiver as accessor properties. The name <code>Object.assign()</code> was chosen to reflect this distinction.</p>
<p>You can use <code>Object.assign()</code> anywhere the <code>mixin</code> function would have been used.</p>
<p>The receiver receives the properties in the order in which the suppliers are specified. That means the second supplier might overwrite a value from the first supplier on the receiver.</p>
<blockquote>
<p>Working with Accessor Properties<br>Keep in mind that <code>Object.assign()</code> doesn’t create accessor properties on the receiver when a supplier has a accessor properties. Since <code>Object.assign()</code> uses the assignment operator, an accessor property on a supplier will become a data property on the receiver.</p>
<pre><code>var receiver = {},
supplier = {
    get name(){
        return “file.js”
    }
};
Object.assign(receiver,supplier);
var descriptor = Object.getOwnPropertyDescriptor(receiver,”name”);
console.log(descriptor.value);  //“file.js”
console.log(descriptor.get);    //undefined
</code></pre></blockquote>
<h2 id="Duplicate-Object-Literal-Properties"><a href="#Duplicate-Object-Literal-Properties" class="headerlink" title="Duplicate Object Literal Properties"></a>Duplicate Object Literal Properties</h2><p>ECMAScript 5 strict mode introduced a check for duplicate object literal properties that would throw an error if a duplicate was found.<br>In ECMAScript 6, the duplicate property check was removed. Instead, the last property of the given name becomes the property’s actual value.</p>
<h2 id="Own-Property-Enumeration"><a href="#Own-Property-Enumeration" class="headerlink" title="Own Property Enumeration"></a>Own Property Enumeration</h2><p>ECMAScript 6 strictly defines the order in which own properties must be returned when they are enumerated. This affects how properties are returned using <code>Object.getOwnPropertyNames()</code> and <code>Reflect.ownKeys</code>. It also affects the order in which properties are processed by <code>Object.assign()</code>.</p>
<p>The basic order for own property enumeration is:</p>
<ul>
<li>All numeric keys in ascending order</li>
<li>All string keys in the order in which they were added to the object</li>
<li>All symbol keys in the order in which they were added to the object<pre><code>var obj = {
  a:1,
  0:1,
  c:1,
  2:1,
  b:1,
  1:1
};
obj.d = 1;
console.log(Object.getOwnPropertyNames(obj).join(“”));  //“012acbd”
</code></pre></li>
</ul>
<blockquote>
<p>The <code>for-in</code> loop still has an unspecified enumeration order. The <code>Object.keys()</code> and <code>JSON.stringify()</code> are both specified to use the same (unspecified) enumeration order as <code>for-in</code>.</p>
</blockquote>
<p>ECMAScript 6, by defining the enumeration order, ensures that JavaScript code relying on enumeration will work correctly regardless of where it is executed.</p>
<h2 id="More-Powerful-Prototypes"><a href="#More-Powerful-Prototypes" class="headerlink" title="More Powerful Prototypes"></a>More Powerful Prototypes</h2><h3 id="Changing-an-Object’s-Prototype"><a href="#Changing-an-Object’s-Prototype" class="headerlink" title="Changing an Object’s Prototype"></a>Changing an Object’s Prototype</h3><p>Normally, the prototype of an object is specified when the object is created, via either a constructor or the <code>Object.create()</code> method. ECMAScript 5 did add the <code>Object.getPrototypeOf()</code> method for retrieving the prototype of any given object, but it still lacked a standard way to change an object’s prototype after instantiation.<br>ECMAScript 6 adds the <code>Object.setPrototypeOf()</code> which allows you to change the prototype of any given object. The method accepts two arguments: the object whose prototype should change and the object that should became the first argument’s prototype.</p>
<h3 id="Easy-Prototype-Access-with-Super-References"><a href="#Easy-Prototype-Access-with-Super-References" class="headerlink" title="Easy Prototype Access with Super References"></a>Easy Prototype Access with Super References</h3><p>Another improvement is the introduction of <code>super</code> references, which makes accessing functionality on an object’s prototype easier. For example, to override a method on an object instance such that it also calls the prototype method of the same name, you’d do the following:</p>
<pre><code>let person = {
    getGreeting(){
        return”Hello!”;
    }
};

let dog = {
    getGreeting(){
        return “Woof”;
    }
};

let friend = {
    getGreeting(){
        return Object.getPrototypeOf(this).getGreeting.call(this) + “,hi!”;
    }
};
</code></pre><p>In this example, <code>getGreeting()</code> on <code>friend</code> calls the prototype method of the same name.</p>
<p>Remembering to use <code>Object.getPrototypeOf()</code> and <code>.call(this)</code> to call a method on the prototype is a bit involved, so ECMAScript 6 introduced <code>super</code>. As its simplest, <code>super</code> is a pointer to the current object’s prototype, effectively the <code>Object.getPrototypeOf(this)</code> value. You can simplify the <code>getGreeting()</code> as follows:</p>
<pre><code>let friend = {
    getGreeting(){
        return super.getGreeting() + “,hi!”;
    }
};
</code></pre><p>Similarly, you can call any method on an object’s prototype by using a <code>super</code> reference, so long as it’s inside a concise method. Attempting to use <code>super</code> outside of concise methods results in a syntax error:</p>
<pre><code>let friend = {
    getGreeting:function(){
    //syntax error
    return super.getGreeting() + “,hi”;
    }
};
</code></pre><p>The <code>super</code> reference is really powerful when you have multiple levels of inheritance. Because <code>super</code> reference are not dynamic, they always refer to the correct object, regardless of how many other objects inherit the method.</p>
<h2 id="A-Formal-Method-Definition"><a href="#A-Formal-Method-Definition" class="headerlink" title="A Formal Method Definition"></a>A Formal Method Definition</h2><p>ECMAScript 6 formally defines a  method as a function that has an internal <code>[[HomeObject]]</code> property containing the object to which the method belongs.</p>
<pre><code>let person = {
    // method
    getGreeting(){
        return”Hello”;
    }
};
// not a method
function shareGreeting(){
    return “Hi!”;
}
</code></pre><p>In most cases, this difference isn’t important, but it becomes very important when using <code>super</code> references.</p>
<p>Any reference to <code>super</code> uses the <code>[[HomeObject]]</code> to determine what to do. The first step is to call <code>Object.getPrototypeOf()</code> on the <code>[[HomeObject]]</code> to retrieve a reference to the prototype. Then, the prototype of a function with the same name. Last, the <code>this</code> binding is set and the method is called. </p>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>ECMAScript 6 makes several changes to object literals. Shorthand property definitions make assigning properties with the same names as in-scope variables easier. Computed property names allow you to specify non-literal values as property names. Shorthand methods let you type a lot fewer characters in order to define methods on object literals, by completely omitting the colon and <code>function</code> keyword. ECMAScript 6 loosens the strict mode check for duplicate object literal property names as well.</p>
<p>The <code>Object.assign()</code> method makes it easier to change multiple properties on a single object at once. This can be very useful if you use the mixin pattern. The <code>Object.is()</code> method performs strict equality on any value, effectively becoming a safer version of <code>===</code> when dealing with special JavaScript values.</p>
<p>Finally, you can use the <code>super</code> keyword to call methods on an object’s prototype. The <code>this</code> binding inside a method invoked using <code>super</code> is set up to automatically work with the current value of <code>this</code>.</p>
<h1 id="05-Destructuring-for-Easier-Data-Access"><a href="#05-Destructuring-for-Easier-Data-Access" class="headerlink" title="05.Destructuring for Easier Data Access"></a>05.Destructuring for Easier Data Access</h1><p>Object and array literals are two of the most frequently used notations in JavaScript. It’s quite common to define objects and arrays, and then systematically pull out relevant pieces of information from those structures. ECMAScript 6 simplifies this task by adding <em>destructuring</em>.</p>
<h2 id="Why-is-Destructuring-Useful"><a href="#Why-is-Destructuring-Useful" class="headerlink" title="Why is Destructuring Useful?"></a>Why is Destructuring Useful?</h2><p>In ECMAScript 5 and earlier, the need to fetch information from objects and arrays could lead to a lot of code that looks the same, just to get certain data into local variables:</p>
<pre><code>let options = {
    repeat:true,
    save:false
    };
//extract data from the object
let repeat = options.repeat,
    save = options.save;
</code></pre><p>Imagine if you had a large number of variables to assign; you would have to assign them all one by one. And if there was a nested data structure to traverse to find the information instead, you might have to dig through the entire structure.</p>
<p>That’s why ECMAScript 6 adds destructuring for both objects and arrays.</p>
<h2 id="Object-Destructuring"><a href="#Object-Destructuring" class="headerlink" title="Object Destructuring"></a>Object Destructuring</h2><p>Object destructuring syntax uses an object literal on the left side of an assignment operation:</p>
<pre><code>let node = {
    type:”Identifier”,
    name:”foo”
};
let {type,name} = node;
console.log(type);  //“Identifier”
console.log(name);  //“foo”
</code></pre><p>This syntax is the same as the object literal property initializer shorthand. </p>
<blockquote>
<p>Don’t Forget the Initializer<br>When using destructuring to declare variables using <code>var</code>,<code>let</code>,or <code>const</code>, you must supply an initializer(the value after the equals sign).<br>While <code>const</code> always requires an initializer, even when using nondestructured variables, <code>var</code> and <code>let</code> only require initializers when using destructuring.</p>
</blockquote>
<h3 id="Destructuring-Assignment"><a href="#Destructuring-Assignment" class="headerlink" title="Destructuring Assignment"></a>Destructuring Assignment</h3><p>Except variable declarations,It’s also possible to use destructuring in assignments. For instance, you may decide to change the values of variables after they are defined:</p>
<pre><code>let node = {
    type:”Identifier”,
    name:”foo”
    },
    type = “Literal”,
    name = 5;

//assign different values using destructuring
({type,name} = node);

console.log(type);  //“Identifier”
console.log(name);  //“foo” 
</code></pre><p>Note that you must put parentheses around a destructuring assignment statement. That’s because an opening curly brace is expected to be a block statement, and a block statement cannot appear on the left side of an assignment.</p>
<p>A destructuring assignment expression evaluates to the right side of the expression(after the <code>=</code>). That means you can use a destructuring assignment expression anywhere a value is expected. For instance, passing a value to a function:</p>
<pre><code>let node = {
    type:”Identifier”,
    name:”foo”
    },
    type = “Literal”,
    name = 5;
function outputInfo(value){
    console.log(value === node);    //true
}

outputInfo({type,name} = node); //node is passed into outputInfo
console.log(type);  //“Identifier”
console.log(name);  //“foo”
</code></pre><blockquote>
<p>An error is thrown when the right side of the destructuring assignment expression(the expression after <code>=</code>) evaluates to <code>null</code> or <code>undefined</code>. This happens because any attempt to read a property of <code>null</code> or <code>undefined</code> results in a runtime error.</p>
</blockquote>
<h3 id="Default-Values"><a href="#Default-Values" class="headerlink" title="Default Values"></a>Default Values</h3><pre><code>let node = {
    type:”Identifier”,
    name:”foo”
    };
let {type,name,value = true} = node;
</code></pre><h3 id="Assigning-to-Different-Local-Variable-Names"><a href="#Assigning-to-Different-Local-Variable-Names" class="headerlink" title="Assigning to Different Local Variable Names"></a>Assigning to Different Local Variable Names</h3><p>ECMAScript 6 has an extended syntax that allows you to assign to a local variable with a different name, and that syntax looks like the object literal non shorthand property initializer syntax:</p>
<pre><code>let node = {
    type:”Identifier”,
    name:”foo”
    };
let {type:localType, name:localName} = node;
</code></pre><p>The syntax <code>type:localType</code> says to read the property named <code>type</code> and store it value in the <code>localType</code> variable. </p>
<p>Object destructuring can also be used to retrieve values in nested object structures.</p>
<h3 id="Nested-Object-Destructuring"><a href="#Nested-Object-Destructuring" class="headerlink" title="Nested Object Destructuring"></a>Nested Object Destructuring</h3><pre><code>let node = {
    type:”Identifier”,
    name:”foo”,
    loc:{
        start:{
            line:1,
            column:1
        },
        end:{
            line:1,
            column:4
        }
    }
};

let{loc:{start}} = node;
console.log(start.line);    //1
</code></pre><p>The destructuring pattern in this example uses curly braces to indicate that the pattern should descend into the property named <code>loc</code> on <code>node</code> and look for the <code>start</code> property. Remember that whenever there’s a colon in a destructuring pattern, it means the identifier before the colon is giving a location to inspect, and the right side assigns a value. When there’s a curly brace after the colon, that indicates that the destination is nested another level into the object.</p>
<p>You can go one step further and use a different name for the local variable as well:</p>
<pre><code>...
let{loc:{start:localStart}} = node;
</code></pre><h2 id="Array-Destructuring"><a href="#Array-Destructuring" class="headerlink" title="Array Destructuring"></a>Array Destructuring</h2><pre><code>let colors = [“red”,”green”,”blue”];

let [firstColor,secondColor] = colors;
</code></pre><p>You can also omit items in the destructuring pattern:</p>
<pre><code>let[ , ,thirdColor] = colors;
</code></pre><blockquote>
<p>Similar to object destructuring, you must always provide an initializer when using array destructuring with <code>var</code>,<code>let</code>,or<code>const</code>.</p>
</blockquote>
<h3 id="Destructuring-Assignment-1"><a href="#Destructuring-Assignment-1" class="headerlink" title="Destructuring Assignment"></a>Destructuring Assignment</h3><pre><code>let colors = [“red”,”green”,”blue”],
    firstColor = “black”,
    secondColor = “purple”;
[firstColor,secondColor] = colors;
</code></pre><p>Array destructuring assignment has a very unique use case that makes it easier to swap the values of two variables. Value swapping is a common operation in sorting algorithms, and the ECMAScript 5 way of swapping variables involves a third, temporary variable.</p>
<pre><code>//Swapping variables in ECMAScript 5
let a = 1,
      b = 2,
    tmp;

tmp = a;
a = b;
b = tmp;
</code></pre><pre><code>//Swapping variables in ECMAScript 6 
let a = 1,
      b = 2;
[a,b] = [b,a];
</code></pre><p>The right side is an array literal that is temporarily created for the swap. The destructuring happens on the temporary array.</p>
<h3 id="Default-Values-1"><a href="#Default-Values-1" class="headerlink" title="Default Values"></a>Default Values</h3><pre><code>let colors = [“red”];
let[firstColor,secondColor = “green”] = colors;
</code></pre><h3 id="Nested-Destructuring"><a href="#Nested-Destructuring" class="headerlink" title="Nested Destructuring"></a>Nested Destructuring</h3><p>By inserting another array pattern into the overall pattern, the destructuring will descend into a nested array, like this:</p>
<pre><code>let colors = [“red”,[“green”,”light-green”],”blue”];
//later
let[firstColor,[secondColor]] = colors;
</code></pre><h3 id="Rest-Items"><a href="#Rest-Items" class="headerlink" title="Rest Items"></a>Rest Items</h3><p>Rest items use the <code>...</code> syntax to assign the remaining items in an array to a particular variable.</p>
<pre><code>let colors = [“red”,”green”,”blue”];
let[firstColor,...restColors] = colors;
</code></pre><p>Rest items are useful for extracting certain items from an array and keeping the rest available, but there’s another helpful use.</p>
<p>A glaring omission from JavaScript arrays is the ability to easily create a clone. In ECMAScript 5, developers frequently used the <code>concat()</code> method as an easy way to clone an array.</p>
<pre><code>//cloning an array in ECMAScript 5
var colors = [“red”,”green”,”blue”];
var clonedColors = colors.concat();
</code></pre><p>In ECMAScript 6, you can use rest items to achieve the same thing through syntax intended to function that way.</p>
<pre><code>//cloning an array in ECMAScript 6
let color = [“red”,”green”,”blue”];
let[...clonedColors] = colors;
</code></pre><blockquote>
<p>Rest items must be the last entry in the destructured array and cannot be followed by a comma.</p>
</blockquote>
<h2 id="Mixed-Destructuring"><a href="#Mixed-Destructuring" class="headerlink" title="Mixed Destructuring"></a>Mixed Destructuring</h2><pre><code>let node = {
        type:”Identifier”,
        name:”foo”,
        loc:{
            start:{
                line:1,
                column:1,
            },
            end:{
                line:1,
                column:4
            }
        },
        range:[0,3]
    };

let{
    loc:{start},
    range:[startIndex]
} = node;

console.log(start.line);    //1
console.log(startIndex);    //0
</code></pre><p>This code extracts <code>node.loc.start</code> and <code>node.range[0]</code> into <code>start</code> and <code>startIndex</code>, respectively.<br>This approach is particularly useful for pulling values out of JSON configuration structures without navigating the entire structure.</p>
<h2 id="Destructured-Parameters"><a href="#Destructured-Parameters" class="headerlink" title="Destructured Parameters"></a>Destructured Parameters</h2><p>Destructuring has one more particularly helpful use case, and that is when passing function arguments. When a JavaScript function takes a large number of optional parameters, one common pattern is to create an <code>options</code> object whose properties specify the additional parameters.</p>
<pre><code>//properties on options represent additional parameters
function setCookie(name,value,options){
    options = options || {};
    let secure = options.secure,
        path = options.path,
        domain = options.domain,
        expires = options.expires;

    //code to set the cookie
}

//third argument maps to options
setCookies(“type”,”js”,{
    secure:true,
    expires:60000
});
</code></pre><p>In this function,the <code>name</code> and <code>value</code> arguments are required, but <code>secure</code>,<code>path</code>,<code>domain</code>, and<code>expires</code> are not. It’s efficient to just have an <code>options</code> object with named properties, rather than list extra named parameters. This approach works, but now you can’t tell what input the function expects just by looking at the function definition.</p>
<p>Destructured parameters offer an alternative that makes it clearer what arguments a function expects. A destructured Parameter uses an object or array destructuring pattern in place of a named parameter. </p>
<pre><code>function setCookie(name,value,{secure,path,domain,expires}){
    //code to set the cookie
}

setCookie(“type”,”js”,{
    secure:true,
    expires:60000
});
</code></pre><h3 id="Destructured-Parameters-are-Required"><a href="#Destructured-Parameters-are-Required" class="headerlink" title="Destructured Parameters are Required"></a>Destructured Parameters are Required</h3><p>One quirk of using destructured  parameters is that, by default, an error is thrown when they are not provided in a function call.</p>
<pre><code>//Error!
setCookie(“type”,”js”);
</code></pre><p>This causes an error because destructured parameters are really just a shorthand for destructured declaration. When the <code>setCookie()</code>function is called, the JavaScript engine actually does this:</p>
<pre><code>function setCookie(name,value,options){
    let{secure,path,domain,expires} = options;
    // code to set the cookie
}
</code></pre><p>Since destructuring throws an error when the right side expression evaluates to <code>null</code> or<code>undefined</code>, the same is true when the third argument isn’t passed to the <code>setCookie()</code> function.<br>If you want the destructured parameter to be optional, you can work around this behavior by providing a default value for the destructured parameter.</p>
<pre><code>function setCookie(name,value,{secure,path,domain,expires} = {}){
    //...
}
</code></pre><p>Destructured parameters use the destructuring syntax to make “options” objects more transparent when used as function parameters. The actual data you’re interested in can be listed out along with other named parameters. Destructured parameters can be array patterns, object patterns, or a mixture, and you can use all of the features of destructuring.</p>
<h1 id="06-Symbols-and-Symbol-Properties"><a href="#06-Symbols-and-Symbol-Properties" class="headerlink" title="06.Symbols and Symbol Properties"></a>06.Symbols and Symbol Properties</h1><p>Symbols are a primitive type introduced in ECMAScript 6. Symbols began as a way to create private object members. Before symbols, any property with a string name was easy to access regardless of the obscurity of the name, and the “private name” feature was meant to let developers create non-string property names. The private names proposal eventually evolved into ECMAScript 6 symbols.</p>
<h2 id="Creating-Symbols"><a href="#Creating-Symbols" class="headerlink" title="Creating Symbols"></a>Creating Symbols</h2><p>Symbols don’t have a literal form,like <code>true</code> for booleans or <code>42</code> for numbers. You can create a symbol by using the global <code>Symbol</code> function:</p>
<pre><code>let firstName = Symbol();
let person = {};
person[firstName] = “Nicholas”;
console.log(person[firstName]); //“Nicholas”
</code></pre><p>Here, the symbol <code>firstName</code> is created and used to assign a new property on the <code>person</code> object.</p>
<p>The <code>Symbol</code> function also accepts an optional argument that is the description of the symbol. The description is used for debugging purposes.</p>
<pre><code>let firstName = Symbol(“first name”);
let person = {};

person[firstName] = “Nicholas”;
console.log(firstName); //“Symbol(first name)”
</code></pre><p>A symbol’s description is stored internally in the <code>[[Description]]</code> property. This property is read whenever the symbol’s <code>toString()</code> method is called either explicitly or implicitly. The <code>firstName</code> symbol’s <code>toString()</code> method is called implicitly by <code>console.log</code> in this example, so the description gets printed to the log.</p>
<blockquote>
<p>Identifying Symbols<br><code>console.log(typeof symbol);</code></p>
</blockquote>
<h2 id="Using-Symbols"><a href="#Using-Symbols" class="headerlink" title="Using Symbols"></a>Using Symbols</h2><p>You can use symbols anywhere you’d use a computed property name. You’ve already seen bracket notation used with symbols, but you can use symbols in computed object literal property names as well as with <code>Object.defineProperty()</code> calls, such as:</p>
<pre><code>let firstName = Symbol(“first name”);

//use a computed object literal property
let person = {
    [firstName]:”Nicholas”
};

//make the property read only
Object.defineProperty(person,firstName,{writable:false});

let lastName = Symbol(“last name”);

Object.defineProperties(person,{
    [lastName]:{
        value:”Zakas”,
        writable:false
    }
});
</code></pre><p>While symbols can be used in any place that computed property names are allowed, you’ll need to have a system for sharing these symbols between different pieces of code in order to use them effectively.</p>
<h2 id="Sharing-Symbols"><a href="#Sharing-Symbols" class="headerlink" title="Sharing Symbols"></a>Sharing Symbols</h2><p>Suppose you have two different object types in your application that should use the same symbol property to represent a unique identifier.</p>
<p>When you want to create a symbol to be shared, use the <code>Symbol.for()</code>. This method accepts a single parameter, which is a string identifier for the symbol you want to create, and also used as the symbol’s description.</p>
<pre><code>let uid = Symbol.for(“uid”);
let object = {};
object[uid] = “12345”;

console.log(uid);   //“Symbol(uid)”
</code></pre><p>The <code>Symbol.for()</code> method first searches the global symbol registry to see if a symbol with the key <code>”uid”</code> exists. If so, the method returns the existing symbol. If no such symbol exists, then a new symbol is created and registered to the global symbol registry using the specified key. That means subsequent calls to <code>Symbol.for()</code> using the same  key will return the same symbol,</p>
<pre><code>let uid2 = Symbol.for(“uid”);

console.log(uid === uid2);  //true
</code></pre><p>Another unique aspect of shared symbols is that you can retrieve the key associated with a symbol in the global symbol registry by calling the <code>Symbol.keyFor()</code> method.</p>
<pre><code>let uid2 = Symbol.for(“uid”);
console.log(Symbol.keyFor(uid2));   //“uid”

let uid3 = Symbol(“uid”);
console.log(Symbol.keyFor(uid3));   //undefined
</code></pre><p>The symbol <code>uid3</code> doesn’t exist in the global symbol registry, so it has no key associated with it.</p>
<h2 id="Symbol-Coercion"><a href="#Symbol-Coercion" class="headerlink" title="Symbol Coercion"></a>Symbol Coercion</h2><p>Symbol,however,are quite inflexible when it comes to coercion.<br><code>console.log()</code> calls <code>String()</code> on symbols to create useful output. You can use <code>String()</code> directly to get the same result.</p>
<pre><code>let uid = Symbol.for(“uid”),
    desc = String(uid);

console.log(desc);  //“Symbol(uid)” 
</code></pre><p>If you try to concatenate the symbol directly with a string, however, an error will be thrown.</p>
<pre><code>let uid = Symbol.for(“uid”),
    desc = uid + “”;    //error!
</code></pre><p>Concatenation <code>uid</code> with an empty string requires that <code>uid</code> first be coerced into a string.</p>
<h2 id="Retrieving-Symbol-Properties"><a href="#Retrieving-Symbol-Properties" class="headerlink" title="Retrieving Symbol Properties"></a>Retrieving Symbol Properties</h2><p>The <code>Object.keys()</code> and <code>Object.getOwnPropertyNames()</code> methods can retrieve all property names in an object. The former returns all enumerable property names,and the latter returns all properties regardless of enumerability. The <code>Object.getOwnPropertySymbols()</code> method was added in ECMAScript 6 to allow you to retrieve property symbols from an object.</p>
<p>Objects can inherit symbol properties from their prototypes. ECMAScript 6 predefines several such properties, implemented using what are called well-known symbols.</p>
<h2 id="Explosing-Internal-Operations-with-Well-Known-Symbols"><a href="#Explosing-Internal-Operations-with-Well-Known-Symbols" class="headerlink" title="Explosing Internal Operations with Well-Known Symbols"></a>Explosing Internal Operations with Well-Known Symbols</h2><p>ECMAScript 6 exposes even more of the previously internal logic of the language, primarily by using symbol prototype properties to define the basic behavior of certain objects.</p>
<p>ECMAScript 6 has predefined symbols called <em>well-known symbols</em> that represent common behaviors in JavaScript that were previously considered internal-only operations. </p>
<ul>
<li><code>Symbol.hasInstance()</code> - A method used by <code>instanceof()</code> to determine an object’s inheritance.</li>
<li><code>Symbol.isConcatSpreadable</code> - A Boolean value indicating that  <code>Array.prototype.concat()</code> should flatten the collection’s elements if the collection is passed as a parameter to <code>Array.prototype.concat()</code>.</li>
<li><code>Symbol.iterator</code> - A method that returns an iterator. (Iterators are covered in Chapter 7.)</li>
<li><code>Symbol.match</code> - A method used by <code>String.prototype.match()</code> to compare strings.</li>
<li><code>Symbol.replace</code> - A method used by  <code>String.prototype.replace()</code> to replace substrings.</li>
<li><code>Symbol.search</code> - A method used by <code>String.prototype.search()</code> to locate substrings.</li>
<li><code>Symbol.species</code> - The constructor for making derived objects.</li>
<li><code>Symbol.split</code> - A method used by <code>String.prototype.split()</code> to split up strings. </li>
<li><code>Symbol.toPrimitive</code> - A method that returns a primitive value representation of an object.</li>
<li><code>Symbol.toStringTag</code> - A string used by <code>Object.prototype.toString()</code> to create an object description.</li>
<li><code>Symbol.unscopables</code> - An object whose properties are the names of object properties that should not be included in a <code>with</code> statement.</li>
</ul>
<h3 id="The-Symbol-hasInstance-Property"><a href="#The-Symbol-hasInstance-Property" class="headerlink" title="The Symbol.hasInstance Property"></a>The Symbol.hasInstance Property</h3><p>Every function has a <code>Symbol.hasInstance</code> method,which is defined on <code>Function.prototype</code> so that all functions inherit the default behavior for the <code>instanceof</code> property.</p>
<pre><code>obj instanceof Array;
// equivalent to
Array[Symbol.hasInstance](obj);
</code></pre><p>For instance, suppose you want to define a function that claims no objects as an instance. You can do so by hard coding the return value of <code>Symbol.hasInstance</code> to <code>false</code>, such as:</p>
<pre><code>function Myobject(){
    //...
}

Object.defineProperty(MyObject,Symbol.hasINstance,{
    value:function(v){
        return false;
    }
});

let obj = new MyObject();

console.log(obj instanceof MyObject);       //false
</code></pre><p>Even though <code>obj</code> is actually an instance of the <code>MyObject</code> class, the <code>instanceof</code> operator returns <code>false</code> after the <code>Object.defineProperty()</code> call.<br>Of course, you can also inspect the value and decide whether or not a value should be considered an instance based on any arbitrary condition. For instance, maybe numbers with values between 1 and 100 are to be considered instances of a special number type. </p>
<pre><code>function SpecialNumber(){
    //empty
}

Object.defineProperty(SpecialNumber,Symbol.hasInstance,{
    value:function(v){
        return(v instanceof Number)&amp;&amp;(v &gt;=1 &amp;&amp; v &lt;= 100);
    }
});
</code></pre><p>The left operand to <code>instanceof</code> must be an object to trigger the <code>Symbol.hasInstance</code> call.</p>
<blockquote>
<p>You can also overwhite the default <code>Symbol.hasInstance</code> property for all built-in functions such as <code>Data</code> and <code>Error</code>. This isn’t recommended,it’s a good idea to only overwrite <code>Symbol.hasInstance</code> on your own functions and only when necessary.</p>
</blockquote>
<h3 id="The-Symbol-isConcatSpreadable-Symbol"><a href="#The-Symbol-isConcatSpreadable-Symbol" class="headerlink" title="The Symbol.isConcatSpreadable Symbol"></a>The Symbol.isConcatSpreadable Symbol</h3><p>The <code>Symbol.isConcatSpreadable</code>property is a boolean value indicating that an object has a length property and numeric keys, and that its numeric property values should be added <strong>individually</strong> to the result of a <code>concat()</code> call. The symbol is available as a way to augment how <code>concat()</code> works on certain types of objects, effectively short-circuiting the default behavior. You can define any type to behave like arrays do in a <code>concat()</code> call:</p>
<pre><code>let collection = {
    0:”Hello”,
    1:”world”,
    length:2,
    [Symbol.isConcatSpreadable]:true
};
let messages = [“Hi”].concat(collection);
console.log(messages);  //[“Hi”,”Hello”,”world”]
</code></pre><blockquote>
<p>You can also set <code>Symbol.isConcatSpreadable</code> to <code>false</code> on array subclasses to prevent items from being separated by <code>concat()</code> calls.</p>
</blockquote>
<h3 id="The-Symbol-match-Symbol-replace-Symbol-search-and-Symbol-split-Symbols"><a href="#The-Symbol-match-Symbol-replace-Symbol-search-and-Symbol-split-Symbols" class="headerlink" title="The Symbol.match, Symbol.replace, Symbol.search, and Symbol.split Symbols"></a>The Symbol.match, Symbol.replace, Symbol.search, and Symbol.split Symbols</h3><p>Strings and regular expressions have always had a close relationship in JavaScript. The string type, in particular, has several methods that accept regular expressions as arguments:</p>
<ul>
<li><code>match(regex)</code> - Determines whether the given string matches a regular expression</li>
<li><code>replace(regex, replacement)</code> - Replaces regular expression matches with a <code>replacement</code></li>
<li><code>search(regex)</code> - Locates a regular expression match inside the string</li>
<li><code>split(regex)</code> - Split a string into an array on a regular expression match</li>
</ul>
<p>ECMAScript 6 defines four symbols that correspond to these four methods, effectively outsourcing the native behavior to the <code>RegExp</code> built-in object.</p>
<pre><code>* `Symbol.match` - A function that accepts a string argument and returns an array of matches, or `null` if no match is found.
* `Symbol.replace` - A function that accepts a string argument and a replacement string, and returns a string.
* `Symbol.search` - A function that accepts a string argument and returns an array containing pieces of the string split on the match.
</code></pre><h3 id="The-Symbol-toPrimitive-Method"><a href="#The-Symbol-toPrimitive-Method" class="headerlink" title="The Symbol.toPrimitive Method"></a>The Symbol.toPrimitive Method</h3><p>Javascript frequently attempts to convert objects into primitive values implicitly when certain operations are applied. Exactly what primitive value should be used was previously an internal operation, but ECMAScript 6 exposes that value (making it changeable) through the <code>Symbol.toPrimitive</code> method.</p>
<p>In many cases, standard objects treat default mode as equivalent to number mode(except for <code>Date</code>,which treats default mode as equivalent to string mode).</p>
<blockquote>
<p>Default mode is only used for the <code>==</code> operator, the <code>+</code> operator, and when passing a single argument to the <code>Date</code> constructor.</p>
</blockquote>
<p>To override the default conversion behaviors, use <code>Symbol.toPrimitive</code> and assign a function as its value.</p>
<pre><code>function Temerature(degrees){
    this.degrees = degrees;
}
Temperature.prototype[Symbol.toPrimitive] = function(hint){
    switch(hint){
        case”string”:
            return this.degrees + “\u00b0”; //degrees symbol

        case “number”:
            return this.degrees;

        case”default”:
            return this.degrees + “degrees”;
    }
};

let freezing = new Temperature(32);

console.log(freezing + “!”);    //“32 degrees!”
console.log(freezing/2);    //16
console.log(String(freezing));  //“32°”
</code></pre><h3 id="The-Symbol-toStringTag-Symbol"><a href="#The-Symbol-toStringTag-Symbol" class="headerlink" title="The Symbol.toStringTag Symbol"></a>The Symbol.toStringTag Symbol</h3><p>One of the most interesting problems in JavaScript has been the availability of multiple global execution environments. This occurs in web browsers when a page includes an iframe, as the page and the iframe each have their own execution environments. In most cases, this isn’t a problem, as data can be passed back and forth between the environments with little cause for concern. The problem arises when trying to identify what type of object you’re dealing with after the object has been passed between different objects.</p>
<p>The canonical example of this issue is passing an array from an iframe into the containing page or vice-versa. In ECMAScript 6 terminology, the iframe and the containing page each represent a different <em>realm</em> which is an execution environment for JavaScript. Each realm has its own global scope with its own copy of global objects. In whichever realm the array is created, it is definitely an array. When it’s passed to a different realm, however, an <code>instanceof Array</code> call returns <code>false</code> because the array was created with a constructor from a different realm and <code>Array</code> represents the constructor in the <strong>current</strong> realm.</p>
<h3 id="A-Workaround-for-the-Identification-Problem"><a href="#A-Workaround-for-the-Identification-Problem" class="headerlink" title="A Workaround for the Identification Problem"></a>A Workaround for the Identification Problem</h3><p>Developers discovered that by calling the standard <code>toString()</code> method on the object, a predictable string was always returned. Thus, many JavaScript libraries began including a function like this:</p>
<pre><code>function isArray(value){
    return Object.prototype.toString.call(value) === “[object Array]”;
}

console.log(isArray([]));   //true
</code></pre><p>The <code>toString()</code> method on arrays isn’t useful for identifying an object. But thee<code>toString()</code> method on <code>Object.prototype</code> had a quirk: it included internally-defined named called <code>[[Class]]</code> in the returned result. Developers could use this method on an object to retrieve what the JavaScript environment thought the object’s data type was.</p>
<p>It was possible to use the same approach to distinguish between native objects and those created by developers. The most important case of this was the ECMAScript 5 <code>JSON</code> object.</p>
<p>As browsers started to implement the <code>JSON</code> global object, figuring out whether the global <code>JSON</code> was provided by the JavaScript environment itself or through some other library became necessary.</p>
<pre><code>function supportNativeJSON(){
    return typeof JSON !== “undefined” &amp;&amp; 
        Object.prototype.toString.call(JSON) === “[object JSON]”;
}
</code></pre><h3 id="The-ECMAScript-6-Answer"><a href="#The-ECMAScript-6-Answer" class="headerlink" title="The ECMAScript 6 Answer"></a>The ECMAScript 6 Answer</h3><p>ECMAScript 6 redefines this behavior through the <code>Symbol.toStringTag</code> symbol. This symbol represents a property on each object that defines what value should be produced when <code>Object.prototype.toString.call()</code> is called on it. For an array, the value that function returns is explained by storing “Array” in the <code>Symbol.toStringTag</code> property.</p>
<p>Likewise, you can define the <code>Symbol.toStringTag</code> value for your own objects:</p>
<pre><code>function Person(name){
    this.name = name;
}
Person.prototype[Symbol.toStringTag] = “Person”;
let me = new Person(“Nicholas”);
console.log(me.toString()); //“[object Person]”
console.log(Object.prototype.toString.call(me));        //“[object Person]”
</code></pre><p>Since </p>
<p>Person.prototype inherits the Object.prototype.toString() method, the value returned from <code>Symbol.toStringTag</code> is also used when calling the <code>me.toString()</code>method. However, you can still define your own <code>toString()</code> method that provides a different behavior without affecting the use of the <code>Object.prototype.toString.call()</code> method. </p>
<pre><code>function Person(name){
    this.name = name;
}
Person.prototype[Symbol.toStringTag] = “Person”;
Person.prototype.toString = function(){
    return this.name;
};//Person instances no longer inherit the Object.prototype.toString() method

let me = new Person(“Nicholas”);
console.log(me.toString()); //&quot;Nicholas&quot;
console.log(Object.prototype.toSting.call(me)); //&quot;[object Person]&quot;
</code></pre><p>There is no restriction on which values can be used for <code>Symbol.toStringTag</code> on developer-defined objects. For example, nothing prevents you from using <code>”Array”</code> as the value of the <code>Symbol.toStringTag</code> property. This highlights the fact that <code>Object.prototype.toString()</code> is no longer a completely reliable way of identifying an object’s type.</p>
<h3 id="The-Symbol-unscopables-Symbol"><a href="#The-Symbol-unscopables-Symbol" class="headerlink" title="The Symbol.unscopables Symbol"></a>The Symbol.unscopables Symbol</h3><p>The <code>with</code> statement is one of the most controversial parts of JavaScript. Originally designed to avoid repetitive typing, the <code>with</code> statement later became roundly criticized for making code harder to understand and for negative performance implications as well as being error-prone.As a result, the with statement is not allowed in strict mode.</p>
<p>ECMAScript 6 still supports <code>with</code> in nonstrict mode for backwards compatibility and, as such, had to find ways to allow code that does use <code>with</code> wo continue to work property.<br>To understand the complexity of this task, consider the following code:</p>
<pre><code>let values = [1,2,3],
    colors = [“red”,”green,”blue”],
    color = “black”;

with(colors){   
    push(color);
    push(...values);
}

console.log(colors);    // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;, 1, 2, 3]
</code></pre><p>But ECMAScript 6 added a <code>values</code> method to arrays. That would mean in an ECMAScript 6 environment, the <code>values</code> reference inside the <code>with</code> statement should refer not to the local variable <code>values</code> , but to the array’s <code>values</code> method, which would break the code. This is why the <code>Symbol.unscopables</code> symbol exists.</p>
<p>The <code>Symbol.unscopables</code> symbol is used on <code>Array.prototype</code> to indicate which properties shouldn’t create bindings inside of a with statement. When present, <code>Symbol.unscopables</code> is an object whose keys are the identifiers to omit from <code>with</code> statement bindings and whose values are true to enforce the block. Here’s the default <code>Symbol.unscopables</code> property for arrays:</p>
<pre><code>//built into ECMAScript 6 by default
Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null),{
    copyWithin:true,
    entries:true,
    fill:true,
    find:true,
    findIndex:true,
    keys:true,
    values:true
});
</code></pre><p>In general, you shouldn’t need to define <code>Symbol.unscopables</code> for your objects unless you use the <code>with</code> statement and are making changes to an existing object in your code base.</p>
<h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>Symbols are a new type of primitive value in JavaScript and are used to create properties that can’t be accessed without referencing the symbol.</p>
<p>While not truly private, these properties are hardly to accidentally change or overwrite and are therefore suitable for functionality that needs a level of protection from developers.</p>
<p>You can provide descriptions for symbols that allow for easier identification of symbol values. There is a global symbol registry that allows you to use shared symbols in different parts of code by using the same description. In this way, the same symbol can be used for the same reason in multiple places.</p>
<p>Methods like <code>Object.keys()</code> or <code>Object.getOwnPropertyNames()</code> don’t return symbols, so a new method called <code>Object.getOwnPropertySymbols()</code> was added in ECMAScript 6 to allow retrieval of symbol properties. You can still make changes to symbol properties by calling the <code>Object.defineProperty()</code> and <code>Object.defineProperties()</code> methods.</p>
<p>Well-known symbols define previously internal-only functionality for standard objects and use globally-available symbol constants, such as the <code>Symbol.hasInstance</code> property. These symbols use the prefix <code>Symbol.</code> in the specification and allow developers to modify standard object behavior in a variety of ways.</p>
<h1 id="07-Sets-and-Maps"><a href="#07-Sets-and-Maps" class="headerlink" title="07.Sets and Maps"></a>07.Sets and Maps</h1><p>Javascript only had only type of collection, represented by the <code>Array</code> type. The lack of other collection options meant arrays were often used as queues and stacks. Since arrays only use numeric indices, developers used non-array objects whenever a non-numeric index was necessary. That technique led to custom implementations of sets and maps using non-array objects.</p>
<p>A <em>set</em> is a list of values that cannot contain duplicates. You typically don’t access individual items in a set like you would items in an array; instead,it’s much more common to just check a set to see if a value is present. A <em>map</em> is a collection of keys that correspond to specific values. As such,each item in a map stores two pieces of data, and values are retrieved by specifying the key to read from. Maps are frequently used as caches, for storing data to be quickly retrieved later. While ECMAScript 5 didn’t formally have sets and maps, developers worked around this limitation using non-array objects, too.</p>
<p>ECMAScript 6 added sets and maps to JavaScript.<br>First, I will discuss the workarounds developers used to implement sets and maps before ECMAScript 6, and why those implementations were problematic.</p>
<h2 id="Sets-and-Maps-in-ECMAScript-5"><a href="#Sets-and-Maps-in-ECMAScript-5" class="headerlink" title="Sets and Maps in ECMAScript 5"></a>Sets and Maps in ECMAScript 5</h2><p>In ECMAScript 5, developers mimicked sets and maps by using object properties, like this:</p>
<pre><code>let set = Object.create(null);//ensure there’re no inherited properties
set.foo = true;

//checking for existence
if(set.foo){
    //do something
}
</code></pre><p>The only real difference between an object used as a set and an object used as a map is the value being stored. For instance, this example uses an object as a map:</p>
<pre><code>let map = Object.create(null);
map.foo = “bar”;

//retrieving a value
let value = map.foo;

console.log(value); //“bar”
</code></pre><p>This code stores a string value <code>”bar”</code> under the key <code>foo</code>. Unlike sets, maps are mostly used to retrieve information, rather than just checking for the key’s existence.</p>
<h3 id="Problems-with-Workarounds"><a href="#Problems-with-Workarounds" class="headerlink" title="Problems with Workarounds"></a>Problems with Workarounds</h3><p>While using objects as sets and maps works okay in simple situations, the approach can get more complicated once you run into the limitations of object properties. For example, since all object properties must be strings, you must be certain no two keys evaluate to the same string. Consider the following:</p>
<pre><code>let map = Object.create(null);
map[5] = “foo”;
console.log(map[“5”]);  //“foo”
</code></pre><p>Another problem arises then using objects as keys, like this:</p>
<pre><code>let map = Object.create(null),
    key1 = {},
    key2 = {};
map[key1] = “foo”;
console.log(map[key2]); //“foo”
</code></pre><p>Here, <code>map[key2]</code> and <code>map[key1]</code> reference the same value. The objects <code>key1</code> and <code>key2</code> are converted to strings because object properties must be strings. Since <code>”[object Object]”</code> is the default string  representation for objects, both <code>key1</code> and <code>key2</code> are converted to that string. The conversion to the default string representation makes it difficult to use objects as keys.</p>
<p>Maps with a key whose value is falsy present their own particular problem, too. A falsy value is automatically converted to false when used in situations where a Boolean value is required, such as in the condition of an <code>if</code> statement. </p>
<h2 id="Sets-in-ECMAScript-6"><a href="#Sets-in-ECMAScript-6" class="headerlink" title="Sets in ECMAScript 6"></a>Sets in ECMAScript 6</h2><p>ECMAScript 6 adds a <code>Set</code> type that is an ordered list of values without duplicates. Sets allow fast access to the data they contain, adding a more efficient manner of tracking discrete values.</p>
<h3 id="Creating-Sets-and-Adding-Items"><a href="#Creating-Sets-and-Adding-Items" class="headerlink" title="Creating Sets and Adding Items"></a>Creating Sets and Adding Items</h3><p>Sets are created using <code>new Set()</code> and items are added to a set by calling the <code>add()</code> method. You can see how many items are in a set by checking the <code>size</code> property:</p>
<pre><code>let set = new Set();
set.add(5);
set.add(“5”);
console.log(set.size);  //2
</code></pre><p>Sets do not coerce values to determine whether they are the same. That means a set can obtain both the number <code>5</code> and the string <code>”5”</code> as two separate items. (The only exception is that -0 and +0 are considered to be the same.) You can also add multiple objects to the set, and those objects will remain distinct:</p>
<pre><code>let set = new Set(),
    key1 = {},
    key2 = {};
set.add(key1);
set.add(key2);
console.log(set.size);  //2
</code></pre><p>If the <code>add()</code> method is called more than once with the same value, all calls after the first one are effectively ignored.</p>
<p>You can initialize a set using an array, and the <code>Set</code> constructor will ensure that only unique values are used. </p>
<pre><code>let set = new Set([1,2,3,4,5,5,5,5]);
console.log(set.size);  //5
</code></pre><p>The number <code>5</code> only appears once in the set even though it appears four times in the array. This functionality makes converting existing code or JSON structures to use sets easy.</p>
<blockquote>
<p>The <code>Set</code> constructor actually accepts any iterable object as an argument. Arrays work because they are iterable by default, as are sets and maps. The <code>Set</code> constructor uses an iterator to extract values from the argument.</p>
</blockquote>
<p>You can test which values are in a set using the <code>has()</code> method, like this:</p>
<pre><code>let set = new Set();
set.add(5);
console.log(set.has(5));    //true
console.log(set.has(6));    //false
</code></pre><p>Here, <code>set.has(6)</code> would return false because the set doesn’t have that value.</p>
<h3 id="Removing-Values"><a href="#Removing-Values" class="headerlink" title="Removing Values"></a>Removing Values</h3><p>It’s also possible to remove values from a set. You can remove single value by using the <code>delete()</code> method, or you can remove all values from the set by calling the <code>clear()</code> method.</p>
<p>What if you want to add items it a set and then perform some operation on each item? That’s where the <code>forEach()</code> method comes in.</p>
<h3 id="The-forEach-Method-for-Sets"><a href="#The-forEach-Method-for-Sets" class="headerlink" title="The forEach() Method for Sets"></a>The forEach() Method for Sets</h3><p>If you’re used to working with arrays, then you may already be familiar with the <code>forEach()</code> method. ECMAScript 5 added <code>forEach()</code> to arrays to make working on each item in an array without setting up a <code>for</code> loop easier. The method proved popular among developers, and so the same method is available on sets and works the same way.</p>
<p>The <code>forEach()</code> method is passed a callback function that accepts three arguments:</p>
<ul>
<li>The value from the next position in the set</li>
<li>The same value as the first argument</li>
<li>The set from which the value is read</li>
</ul>
<p>The strange difference between the set version of  <code>forEach()</code> and the array version is that the first and second arguments to the callback function are the same. The other objects that have <code>forEach()</code> methods(arrays and maps) pass three arguments to their callback functions. The first two arguments for arrays and maps are the value and the key(the numeric index for arrays). Sets don’t have keys. ECMAScript 6 found a way to keep the callback function the same and accept three argument: each value in a set is considered to be both the key and the value. As such, the first and second argument are always the same in <code>forEach()</code> on sets to keep this functionality consistent with the other <code>forEach()</code> methods on arrays and maps.</p>
<pre><code>let set = new Set([1,2]);
set.forEach(function(value,key,ownerSet){
    console.log(key + “ ” + value);
    console.log(ownerSet === set);
});

//outputs
1 1
true
2 2
true
</code></pre><p>Also the same as arrays, you can pass a <code>this</code> value as the second argument to <code>forEach()</code> if you need to use <code>this</code> in your callback function:</p>
<pre><code>let set = new Set([1,2]);
let processor = {
    output(value){
        console.log(value);
    },
    process(dataSet){
        dataSet.forEach(function(value){
            this.output(value);
        },this);
    }
};

processor.process(set);
</code></pre><p>In this example, the <code>processor.process()</code> method calls <code>forEach()</code> on the set and passes <code>this</code> as the <code>this</code> value for the callback. That’s necessary so <code>this.output()</code> will correctly resolve to the <code>processor.output()</code> method. The <code>forEach()</code> callback function only make use of the first argument, <code>value</code>, so the others are omitted. You can also use an arrow function to get the same effect without passing the second argument, like this:</p>
<pre><code>let set = new Set([1,2]);
let processor = {
    output(value){
        console.log(value);
    },
    process(dataSet){
        dataSet.forEach((value) =&gt; this.output(value));
    }
};

processor.process(set);
</code></pre><p>The arrow function in this example reads <code>this</code> from the containing <code>process()</code> function, and so it should correctly resolve <code>this.output()</code> to a <code>processor.output()</code> call.</p>
<p>Keep in mind that while sets are great for tracking values and <code>forEach()</code> lets you work on each value sequentially, you can’t directly access a value by index like you can with an array. If you need to do so, then the best option is to convert the set into an array.</p>
<h3 id="Converting-a-Set-to-an-Array"><a href="#Converting-a-Set-to-an-Array" class="headerlink" title="Converting a Set to an Array"></a>Converting a Set to an Array</h3><p>It’s easy to convert a set back into an array using the spread operator. The spread operator(<code>...</code>) is a way to split items in an array into separate function parameters. You can also use the spread to operate to work on iterable objects, such as sets, to convert them into arrays.</p>
<pre><code>let set = new Set([1,2,3,3,3,4,5]),
    array = [...set];
console.log(array); //[1,2,3,4,5]
</code></pre><p>This approach is useful when you already have an array and want to create an array without duplicate.</p>
<pre><code>function eliminateDuplicates(items){
    return [...new Set(items)];
}

let numbers = [1,2,3,3,3,4,5],
    noDuplicates = eliminateDuplicates(numbers);

console.log(noDuplicates);  //[1,2,3,4,5]
</code></pre><h2 id="Weak-Sets"><a href="#Weak-Sets" class="headerlink" title="Weak Sets"></a>Weak Sets</h2><p>The <code>Set</code> type could alternately be called a strong set, because of the way it stores object references. An object stored in an instance of <code>Set</code> is effectively the same as storing that object inside a variable. As long as a reference to the <code>Set</code> instance exists, the object cannot be garbage collected to free memory.</p>
<pre><code>let set = new Set(),
    key = {};
set.add(key);
console.log(set.size);  //1

//eliminate original reference
key = null;
console.log(set.size);  //1

//get the original reference back
key = [...set][0];
</code></pre><p>In this example, setting <code>key</code> to <code>null</code> clears one reference of the <code>key</code> object, but another remains inside <code>set</code>. You can still retrieve <code>key</code> by converting the set to an array with the spread operator and accessing the first item. That result is fine for most programs, but sometimes, it’s better for references in a set to disappear when all other references disappear. For instance, if your JavaScript code in running in a web page and wants to keep track of DOM elements that might be removed by another script, you don’t want your code holding onto the last reference to a DOM element.(That situation is called a <em>memory leak</em>.)</p>
<p>To alleviate such issues, ECMAScript 6 also includes <em>weak sets</em>, which only store weak object references and cannot primitive values. A <em>weak</em> reference to an object does not prevent garbage collocation if it is the only remaining reference.</p>
<h3 id="Creating-a-Weak-Set"><a href="#Creating-a-Weak-Set" class="headerlink" title="Creating a Weak Set"></a>Creating a Weak Set</h3><pre><code>let set = new WeakSet(),
    key = {};

//add the object to the set
set.add(key);
console.log(set.has(key));  //true

set.delete(key);

console.log(set.has(key));  //false
</code></pre><h3 id="Key-Differences-Between-Set-Types"><a href="#Key-Differences-Between-Set-Types" class="headerlink" title="Key Differences Between Set Types"></a>Key Differences Between Set Types</h3><p>The biggest difference between weak sets and regular sets is the weak reference held to the object value. </p>
<pre><code>let set = new WeakSet(),
    key = {};

//add the object to the set
set.add(key);
console.log(set.has(key));  //true

//remove the last strong reference to key,also removes from weak set
key = null;
</code></pre><p>After this code executes, the reference to <code>key</code> in the weak set is no longer accessible.</p>
<ul>
<li>In a <code>WeakSet</code> instance, the <code>add()</code> method throws an error when passed a non-object(<code>has()</code> and <code>delete()</code> always return <code>false</code> for non-object arguments).</li>
<li>Weak sets do not expose any iterable and therefore cannot be used in a <code>for-in</code> loop.</li>
<li>Weak sets do not expose any iterators(such as the <code>key()</code> and <code>values()</code> methods), so there is no way to programmatically determine the contents of a weak set.</li>
<li>Weak sets do not have a <code>forEach()</code> method.</li>
<li>Weak sets do not have a <code>size</code> property.</li>
</ul>
<p>The seemingly limited functionality of weak sets is necessary in order to properly handle memory. In general, if you only need to track object references, then you should use a weak set instead of a regular set.</p>
<p>Sets give you a new way to handle lists of values, but they aren’t useful when you need to associate additional information with those values. That’s why ECMAScript 6 also adds maps.</p>
<h2 id="Maps-in-ECMAScript-6"><a href="#Maps-in-ECMAScript-6" class="headerlink" title="Maps in ECMAScript 6"></a>Maps in ECMAScript 6</h2><p>The ECMAScript 6 <code>Map</code> type is an ordered list of key-value pairs, where both the key and the value can have any type. Keys equivalence is determined by using the same approach as <code>Set</code> objects, so you can both a key of <code>5</code> and a key of <code>”5”</code> because they are different types. This is quite different from using object properties as keys, as object properties always coerce values into strings.</p>
<p>You can add items to maps by calling the <code>set()</code> method and passing it a key and the value to associate with the key. You can later retrieve a value by passing the key to the <code>get()</code> method.</p>
<pre><code>let map = new Map();
map.set(“title”,”Understanding ES6”);
map.set(“year”,2016);

console.log(map.get(“title”));  //“Understanding ES6”
console.log(map.get(“year”));   //2016
</code></pre><p>You can also use objects as keys, which isn’t possible when using object properties to create a map in the old workaround approach.</p>
<pre><code>let map = new Map(),
    key1 = {},
    key2 = {};
map.set(key1,5);
map.set(key2,42);
console.log(map.get(key1)); //5
console.log(map.get(key2)); //42
</code></pre><p>Because these keys are not coerced into another from, each object is considered unique. This allows you to associate additional data with an object without modifying the object itself.</p>
<h3 id="Map-Methods"><a href="#Map-Methods" class="headerlink" title="Map Methods"></a>Map Methods</h3><p>Maps share several methods with sets. That is intentional, and it allows you to interact with maps and sets in similar ways. These three methods are available on both maps and sets:<code>has(key),delete(key),clear()</code> .</p>
<p>Maps also have a <code>size</code> property that indicates how many key-value pairs it contains.</p>
<p>The <code>clear()</code> method is a fast way to remove a lot of data from a map, but there’s also a way to add a lot of data to a map at one time.</p>
<h3 id="Map-Initialization"><a href="#Map-Initialization" class="headerlink" title="Map Initialization"></a>Map Initialization</h3><p>Also similar to sets, you can initialize a map with data by passing an array to the <code>Map</code> constructor. ~Each item in the array must itself be an array where the first item is the key and the second is that key’s corresponding value.~ The entire map, therefore, is an array of these two-item arrays.<br><code>let map = new Map([[“name”,”Nicholas”],[“age”,25]]);</code><br>Storing the keys in an array is the only to ensure they aren’t coerced into another data type before being stored in the map.</p>
<h3 id="The-forEach-Method-on-Maps"><a href="#The-forEach-Method-on-Maps" class="headerlink" title="The forEach Method on Maps"></a>The forEach Method on Maps</h3><p>The <code>forEach()</code> method for maps also accepts a callback function that receives three arguments:</p>
<ul>
<li>The value from the next position in the map</li>
<li>The key for that value</li>
<li>The map from which the value is read</li>
</ul>
<pre><code>let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);
map.forEach(function(value,key,ownerMap){
    console.log(key + “ “ + value);
    console.log(ownerMap === map);
});
</code></pre><blockquote>
<p>You can also provide a second argument to <code>forEach()</code> to specify the <code>this</code> value inside the callback function.</p>
</blockquote>
<h3 id="Weak-Maps"><a href="#Weak-Maps" class="headerlink" title="Weak Maps"></a>Weak Maps</h3><p>Weak maps are to maps what weak sets are to sets: they’re a way to store weak object references. ~In <em>weak maps</em>,every key must be an object, and those object references are held weakly so they don’t interface with garbage collection~. When there are no reference to a weak map key outside a weak map, the key-value pair is removed from the weak map.</p>
<p>The most useful place to employ weak maps is when creating an object related to a particular DOM element in a web page. For example, some JavaScript libraries for web pages maintain one custom object for every DOM element referenced in the library, and that mapping is stored in a cache of objects internally.</p>
<p>The difficult part of this approach is determining when a DOM element no longer exists in the web page, so that the library can remove its associated object. Otherwise, the library would hold onto the DOM element reference past the reference’s usefulness and cause a memory leak. Tracking the DOM elements with a weak map would still allow the library to associate a custom object with every DOM element, and it could automatically destroy any object in the map when that object’s DOM element no longer exists.</p>
<blockquote>
<p>It’s important to note that only weak map keys, and not weak map values, are weak references. </p>
</blockquote>
<h3 id="Using-Weak-Maps"><a href="#Using-Weak-Maps" class="headerlink" title="Using Weak Maps"></a>Using Weak Maps</h3><p>The ECMAScript 6 <code>WeakMap</code> type is an unordered list of key-value pairs, where a key must be a non-null object and a value can be any type. The interface for <code>WeakMap</code> is very similar to that of <code>Map</code> in that <code>set()</code> and <code>get()</code> are used to add and retrieve data, respectively:</p>
<pre><code>let map = new WeakMap(),
    element = document.querySelector(“.element”);
map.set(element,”Original”);
let value = map.get(element);
console.log(value); //“Original”

//remove the element
element.parentNode.removeChild(element);
element = null;

//the weak map is empty at this point
</code></pre><h3 id="Weak-Map-Initialization"><a href="#Weak-Map-Initialization" class="headerlink" title="Weak Map Initialization"></a>Weak Map Initialization</h3><p>Just like initializing a regular map, each array inside the containing array should have two items, where the first item is the non- null object key and the second item is the value(any data type).</p>
<pre><code>let key1 = {}.
    key2 = {},
      map = new WeakMap([[key1,”Hello”],[key2,42]]);
</code></pre><h3 id="Weak-Map-Methods"><a href="#Weak-Map-Methods" class="headerlink" title="Weak Map Methods"></a>Weak Map Methods</h3><p>Weak maps have only two additional methods available to interact with key-value pairs:<code>has(),delete()</code>. There is no <code>clear()</code> because that would require enumerating keys, and like weak sets, that isn’t possible with weak maps.</p>
<h3 id="Private-Object-Data"><a href="#Private-Object-Data" class="headerlink" title="Private Object Data"></a>Private Object Data</h3><p>One practical use of weak maps is to store data that is private to object instances. Consider the following example:</p>
<pre><code>function Person(name){
    this._name = name;
}
Person.prototype.getName = function(){
    return this._name;
};
</code></pre><p>This code uses the common conventions of a leading underscore to indicate that a property is considered private and should not be modified outside the object instance. The intent is to use <code>getName()</code> to read <code>this._name</code> and not allow the <code>_name</code> value to change. However, there is nothing standing in the way of someone writing to the <code>_name</code> property, so it can be overwritten.</p>
<p>In ECMAScript 5, it’s possible to get close to having truly private data, by creating an object using a pattern such as this:</p>
<pre><code>var Person = (function(){
    var privatData = {},
        privateId = 0;
    function Person(name){
        Object.defineProperty(this,”_id”,{value:privateId++});
        privateData[this._id] = {
            name:name
        };
    }
    Person.prototype.getName = function(){
        return privateData[this._id].name;
    };
    return Person;
}());
</code></pre><p>This example wraps the definition of <code>Person</code> in an IIFE that contains two private variables. The <code>privateData</code> object stores private information for each instance while <code>privateId</code> is used to generate a unique ID for each instance. Because <code>privateData</code> is not accessible outside of the IIFE, the actual data is safe, even though <code>this._id</code> is exposed publicly.</p>
<p>The big problem with this approach is that the data in <code>privateData</code> never disappears because there is no way to know when an object instance is destroyed; the <code>privateData</code> object will always contain extra data. This problem can be solved by using a weak map instead.</p>
<pre><code>let Person = (function(){
    let privateData = new WeakMap();
    function Person(name){
        privateData.set(this,{name:name});
    }
    Person.prototype.getName = function(){
        return privateDate.get(this).name;
    };
    return Person;
}());
</code></pre><p>This version of the <code>Person</code> example uses a weak map for the private data instead of an object. Because the <code>Person</code> object instance itself can be used as a key, there’s no need to keep track of a separate ID. When the <code>Person</code> constructor is called, a new entry is made into the weak map with a key of <code>this</code> and a value of an object containing private information. In this case, that value is an object containing only <code>name</code>. The <code>getName()</code> function retrieves that private information by passing <code>this</code> to the <code>privateData.get()</code> method,which fetches the value object and accesses the <code>name</code> property. This technique keeps the private information private,and destroys that information whenever an object instance associated with it is destroyed.</p>
<h3 id="Weak-Map-Uses-and-Limitations"><a href="#Weak-Map-Uses-and-Limitations" class="headerlink" title="Weak Map Uses and Limitations"></a>Weak Map Uses and Limitations</h3><p>When deciding whether to use a weak map or a regular map, the primary decision to consider is whether you want to use only object keys. Anytime you’re going to use only object keys, then the best choice is a weak map. </p>
<p>Keep in mind that weak maps give you very little visibility into their contents, so you can’t use the <code>forEach()</code> method, the <code>size</code> property, or the <code>clear()</code> method to manage the items. If you need some  inspection capabilities, then regular maps are a better choice. Just be sure to keep an eye on memory usage. Of course, if you only want to use non-object keys, then regular maps are your only choice.</p>
<h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>Sets are ordered list of unique values. Values are not coerced to determine equivalence.<br>Weak sets are special sets that can contain only objects. The objects are stored with weak references.</p>
<p>Maps are ordered key-value pairs where the key can be any data type. Similar to sets, keys are not coerced to determine equivalence. A value of any data type can be associated with a key using the <code>set()</code> method, and that value can later be retrieved by using the <code>get()</code> method. Weak maps can only have object keys. The memory management aspect makes weak maps uniquely suited for correlating additional information with objects whose lifecycles are managed outside of the code accessing them.</p>
<h1 id="08-Iterators-and-Generators"><a href="#08-Iterators-and-Generators" class="headerlink" title="08.Iterators and Generators"></a>08.Iterators and Generators</h1><p>Many programming languages have shifted from iterating over data with <code>for</code> loops, which require initializing variables to track position in a collection, to using iterator objects that programmatically return the next item in a collection. Iterators make working with collections of data easier, and ECMAScript 6 adds iterators to Javascript. When coupled with new array methods and new types of collections(such as sets and maps), iterators are key for efficient data processing, and you will find them in many parts of the language. There’s a new <code>for-in</code> loop that works with iterators, the spread(<code>...</code>) operator uses iterators, and iterators even make asynchronous programming easier.</p>
<p>First, it’s important to understand the history behind why iterators were added to JavaScript.</p>
<h2 id="The-Loop-Problem"><a href="#The-Loop-Problem" class="headerlink" title="The Loop Problem"></a>The Loop Problem</h2><pre><code>var colors = [“red”,”green”,”blue”];
for(var i = 0,len = colors.length; i &lt; len; i++){
    console.log(colors[i]);
}
</code></pre><p>While this loop is fairly straightforward, loops grow in complexity when you nest them and need to keep track of multiple variables. Additional complexity can lead to errors, and the boilerplate nature of the <code>for</code> loop lends itself to more errors as similar code is written in multiple places. Iterators are meant to solve that problem.</p>
<h2 id="What-are-Iterators"><a href="#What-are-Iterators" class="headerlink" title="What are Iterators?"></a>What are Iterators?</h2><p>Iterators are just objects with a specific interface designed for iteration. All iterator objects have a <code>next()</code> method that returns a result object. The result object has two properties: <code>value</code>, which is the next value, and <code>done</code>, which is a boolean that’s <code>true</code> when there are no more values to return. The iterator keeps an internal pointer to a location within a collection of values and with each call to the <code>next()</code> method, it returns the next appropriate value.</p>
<p>If you call <code>next()</code> after the last value has been returned, the method returns <code>done</code> as <code>true</code> and <code>value</code> contains the <em>return value</em> for the iterator. That return value is not part of the data set, but rather a final piece of related data, or <code>undefined</code> if no such data exists. An iterator’s return value is similar to a function’s return value in that it’s a final way to pass information to the caller.</p>
<p>With that in mind, creating an iterator using ECMAScript 5 is fairly straightforward:</p>
<pre><code>function createIterator(items){
    var i = 0;
    return{
        next:function(){
            var done = (i &gt;= items.length);
            var value = !done ? items[i++] : undefined;
            return{
                done:done,
                value:value
            };
        }
    };
}

var iterator = createIterator([1,2,3]);
console.log(iterator.next());   //“{value:1,done:false}”
console.log(iterator.next());   //“{value:2,done:false}”
console.log(iterator.next());   //“{value:3,done:false}”
console.log(iterator.next());   //“{value:undefined,done:true}”

//for all further calls
console.log(iterator.next());   //“{value:undefined,done:true}”
</code></pre><p>Fortunately, ECMAScript 6 also provides generators, which make creating iterator objects much simpler.</p>
<h2 id="What-Are-Generators"><a href="#What-Are-Generators" class="headerlink" title="What Are Generators?"></a>What Are Generators?</h2><p>A <em>generator</em> is a function that returns an iterator. Generator functions are indicated by a star character (<code>*</code>) after the <code>function</code> keyword and use the new <code>yield</code> keyword. </p>
<pre><code>//generator
function *createIterator(){
    yield 1;
    yield 2;
    yield 3;
}

//generators are called like regular functions but return an iterator
let iterator = createIterator();

console.log(iterator.next().value); //1
console.log(iterator.next().value); //2
console.log(iterator.next().value); //3
</code></pre><p>The <code>yield</code> keyword specifies values the resulting iterator should return when <code>next()</code> is called, in the order they should be returned. </p>
<p>Perhaps the most interesting aspect of generator functions is that they ~stop execution~ after each <code>yield</code> statement. For instance, after <code>yield 1</code> executes in this code, ~the function doesn’t execute anything else until the iterator’s next() method is called~. At that point, <code>yield 2</code> executes. This ability to stop execution in the middle of a function is extremely powerful and leads to some interesting uses of generator functions.</p>
<p>The <code>yield</code> keyword can be used with any value or expression. For example, here’s one way you could use <code>yield</code> inside a <code>for</code> loop:</p>
<pre><code>function *createIterator(items){
    for(let i = 0;i &lt; items.length; i++){
        yield items[i];
    }
}

let iterator = createIterator([1,2,3]);
</code></pre><p>Inside the function, a <code>for</code> loop yields the elements from the array into the iterator as the loop progresses. </p>
<blockquote>
<p>The <code>yield</code> keyword can only be used inside of generator.</p>
</blockquote>
<h3 id="Generator-Function-Expressions"><a href="#Generator-Function-Expressions" class="headerlink" title="Generator Function Expressions"></a>Generator Function Expressions</h3><pre><code>let createIterator = function *(item){
    for(let i = 0;i &lt; items.length; i++){
        yield items[i];
    }
};
</code></pre><h3 id="Generator-Object-Methods"><a href="#Generator-Object-Methods" class="headerlink" title="Generator Object Methods"></a>Generator Object Methods</h3><p>Because generators are just functions, they can be added to objects, too. For example:</p>
<pre><code>//ECMAScript 5-style object literal
var o = {
    createIterator:function *{item}{
        for(let i = 0; i &lt; items.length; i++){
            yield items[i];
        }
    }
};

//ECMAScript 6 method shorthand
var o = {
    *createIterator(items){
        ...
    }
};
</code></pre><h3 id="Iterables-and-for-of"><a href="#Iterables-and-for-of" class="headerlink" title="Iterables and for-of"></a>Iterables and for-of</h3><p>Closely related to iterators, an <em>iterables</em> is an object with a <code>Symbol.iterator</code> property. The well-known <code>Symbol.iterator</code>symbol specifies a function that returns an iterator for the given object. ~All collection objects(array,sets, and maps) and strings are iterables in ECMAScript 6~ and so they have a default iterator specified. Iterables are designed to be used with a new addition to ECMAScrip: the <code>for-of</code> loop.</p>
<blockquote>
<p>All iterators created by generators are also iterables, as generators assign the <code>Symbol.iterator</code> property by default.</p>
</blockquote>
<p>The <code>for-of</code> loop removes the need to track an index into a collection entirely, leaving you free to focus on working with the contents of the collection.</p>
<p>A <code>for-of</code> loop calls <code>next()</code> on an iterable each time the loop executes and stores the <code>value</code> from the result object in a variable. The loop continues this process until the returned object’s <code>done</code> property is <code>true</code>.</p>
<pre><code>let values = [1,2,3];
for(let num of values){
    console.log(num);
}
//outputs
1
2
3
</code></pre><p>This <code>for-of</code> loop first calls the <code>Symbol.iterator</code> method on the <code>values</code> array to retrieve an iterator. Then <code>iterator.next()</code> is called, and the <code>value</code> property on the iterator’s result is read into <code>num</code>.</p>
<p>If you’re simply iterating over values in an array or collection, the it’s a good idea to use a <code>for-of</code> loop instead of a <code>for</code> loop. Save the traditional <code>for</code> loop for more complex control conditions.</p>
<h3 id="Accessing-the-Default-Iterator"><a href="#Accessing-the-Default-Iterator" class="headerlink" title="Accessing the Default Iterator"></a>Accessing the Default Iterator</h3><p>You can use <code>Symbol.iterator</code> to access the default iterator for an object</p>
<pre><code>let values = [1,2,3];
let iterator = values[Symbol.iterator]();
console.log(iterator.next());
</code></pre><p>Since <code>Symbol.iterator</code> specifies the default iterator, you can use it to detect whether an object is iterable.</p>
<pre><code>function isIterable(object){
    return typeof object[Symbol.iterator] === “function”;
}
</code></pre><p>You can also use the <code>Symbol.iterator</code> property to create your own iterables.</p>
<h3 id="Creating-Iterables"><a href="#Creating-Iterables" class="headerlink" title="Creating Iterables"></a>Creating Iterables</h3><p>Developer-defined objects are not iterable by default, but you can make them iterable by creating a <code>Symbol.iterator</code> property containing a generator.</p>
<pre><code>let collection = {
    items:[],
    *[Symbol.iterator](){
        for(let item of this.items){
            yield item;
        }
    }
};
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);
for(let x of collection){
    console.log(x);
}
//outputs
1
2
3
</code></pre><p>Instead of manually iterating to define values for the default iterator of <code>collection</code> to return, the <code>collection</code> object relies on the default iterator of <code>this.items</code> to do the work.</p>
<h2 id="Built-in-Iterators"><a href="#Built-in-Iterators" class="headerlink" title="Built-in Iterators"></a>Built-in Iterators</h2><h3 id="Collection-Iterators"><a href="#Collection-Iterators" class="headerlink" title="Collection Iterators"></a>Collection Iterators</h3><p>ECMAScript 6 has three types of collection objects: arrays,maps,and sets. All three have the following built-in iterators to help you navigate their content: <code>entries(),values(),keys()</code></p>
<p><strong>The entries() Iterator</strong><br>The <code>entries()</code> iterator returns a two-item array each time <code>next()</code> is called. The two-item array represents the key and value for each item in the collection. </p>
<pre><code>let colors = [“red”,”green”,”blue”];
let tracking = new Set([1234,5678,9012]);
let data = new Map();
data.set(“title”,”Understanding ECMAScript 6”);
data.set(“format”,”ebook”);

for(let entry of colors.entries()){
    console.log(entry);
}
for(let entry of tracking.entries()){
    console.log(entry);
}
for(let entry of data.entries()){
    console.log(entry);
}

//outputs
[0, &quot;red&quot;]
[1, &quot;green&quot;]
[2, &quot;blue&quot;]
[1234, 1234]
[5678, 5678]
[9012, 9012]
[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;]
[&quot;format&quot;, &quot;ebook&quot;]
</code></pre><h3 id="Default-Iterators-for-Collection-Types"><a href="#Default-Iterators-for-Collection-Types" class="headerlink" title="Default Iterators for Collection Types"></a>Default Iterators for Collection Types</h3><p>The <code>values()</code> method is the default iterator for arrays and sets, while the <code>entries()</code> method is the default iterator for maps. These defaults make using collection objects in <code>for-of</code> loops a little easier.</p>
<pre><code>//same as using colors.values()
for(let value of colors){
    console.log(value);
}

//same as using tracking.values()
for(let num of tracking){
    console.log(num);
}

//same as using data.entries()
for(let entry of data){
    console.log(entry);
}

//outputs
“red”
“green”
“blue”
1234
5678
9012
[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;]
[&quot;format&quot;, &quot;print&quot;]
</code></pre><p>The default Iterators are designed to reflect how these objects are initialized.</p>
<blockquote>
<p><strong>Destructuring and for-of Loops</strong><br>The behavior of the default iterator for maps is also helpful when used in <code>for-of</code> loops with destructuring</p>
<pre><code>let data = new Map();
data.set(“title”,”Understanding ES6”);
data.set(“format”,”ebook”);
//same as using data.entries()
for(let [key,value] of data){
    console.log(key + “=” + value);
}
</code></pre><p>In this way, you can easily work with keys and values at the same time without needing to access a two-item array or going back to the map to fetch either the key or the value.</p>
</blockquote>
<h3 id="String-Iterators"><a href="#String-Iterators" class="headerlink" title="String Iterators"></a>String Iterators</h3><p>ECMAScript 5 formalized bracket notation for accessing characters in strings. But bracket notation works on code units rather than characters, so it cannot be used to access double-byte characters correctly.</p>
<pre><code>var message = “A 𠮷 B”;
for(let i=0; i&lt;message.length; i++){
    console.log(message[i]);
}

//output
A
(blank)
(blank)
(blank)
(blank)
B
</code></pre><p>The default string iterator is an attempt to solve the string iteration problem. </p>
<pre><code>for(let c of message){
    console.log(c);
}

//output
A
(blank)
𠮷
(blank)
B
</code></pre><h3 id="Nodelist-Iterators"><a href="#Nodelist-Iterators" class="headerlink" title="Nodelist Iterators"></a>Nodelist Iterators</h3><p> The DOM has a <code>NodeList</code> type that represents a collection of elements in a document. </p>
<pre><code>var divs = document.getElementsByTagName(“div”);
for(let div of divs){
    console.log(div.id);
}
</code></pre><p>This code calls <code>getElementsByTagName()</code> to retrieve a <code>NodeList</code> that represents all of the <code>&lt;div&gt;</code> elements in the <code>document</code> object. </p>
<h2 id="The-Spread-Operator-and-Non-Array-Iterables"><a href="#The-Spread-Operator-and-Non-Array-Iterables" class="headerlink" title="The Spread Operator and Non-Array Iterables"></a>The Spread Operator and Non-Array Iterables</h2><pre><code>let set = new Set([1,2,3,3,3,4,5]),
    array = [...set];
console.log(array); //[1,2,3,4,5]
</code></pre><p>The spread operator works on all iterables and uses the default iterator to determine which values to include. </p>
<pre><code>let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]),
    array = [...map];
console.log(array); //[ [&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]
</code></pre><p>You can use the spread operator in an array literal as many times as you want, and you can use it wherever you want to insert multiple items from an iterable.</p>
<pre><code>let smallNumbers = [1,2,3],
    bigNumbers = [100,101,102],
    allNumbers = [0,...smallNumbers,...bigNumbers];
</code></pre><h2 id="Advanced-Iterator-Functionality"><a href="#Advanced-Iterator-Functionality" class="headerlink" title="Advanced Iterator Functionality"></a>Advanced Iterator Functionality</h2><h3 id="Passing-Arguments-to-Iterators"><a href="#Passing-Arguments-to-Iterators" class="headerlink" title="Passing Arguments to Iterators"></a>Passing Arguments to Iterators</h3><p>Throughout this chapter, examples have shown iterators passing ~values~ out via the <code>next()</code> method or by using <code>yield</code>  in a generator. But you can also pass ~arguments~ to the iterator through the <code>next()</code> method. When an argument is passed to the <code>next()</code> method, that argument becomes the value of the <code>yield</code> statement inside a generator. This capability is important for more advanced functionality such as asynchronous programming.</p>
<pre><code>function *createIterator(){
    let first = yield 1;
    let second = yield first + 2;   // 4 + 2
    yield second + 3;   // 5 + 3
}
let iterator = createIterator();
console.log(iterator.next());   // &quot;{ value: 1, done: false }&quot;
console.log(iterator.next(4));  // &quot;{ value: 6, done: false }&quot;
console.log(iterator.next(5));  // &quot;{ value: 8, done: false }&quot;
console.log(iterator.next());   // &quot;{ value: undefined, done: true }&quot;
</code></pre><h3 id="Throwing-Errors-in-Iterators"><a href="#Throwing-Errors-in-Iterators" class="headerlink" title="Throwing Errors in Iterators"></a>Throwing Errors in Iterators</h3><pre><code>function *createIterator(){
    let first = yield 1;
    let second;
    try{
        second = yield first + 2;   //yield 4 + 2, then throw
    } catch (ex) {
        second = 6; //on error,assign a different value
    }
    yield second + 3;
}
let iterator = createIterator();

console.log(iterator.next());   //“{value:1,done:false}”
console.log(iterator.next(4));  //“{value:6,done:false}”
console.log(iterator.throw(new Error(“Boom”))); //“{value:1,done:false}”
console.log(iterator.next());   //“{value:undefined,done:true}”
</code></pre><p>The <code>throw()</code> method returned a result object just like the <code>next()</code> method. Because the error we caught inside the generator, code execution continued on to the next <code>yield</code> and returned the next value, <code>9</code>.<br>It helps to think of <code>next()</code> and <code>throw()</code> as both being instructions to the iterator. The <code>next()</code> method instructs the iterator to continue executing and <code>throw()</code> instructs the iterator to continue executing by throwing an error. </p>
<h3 id="Generator-Return-Statements"><a href="#Generator-Return-Statements" class="headerlink" title="Generator Return Statements"></a>Generator Return Statements</h3><p>Since generators are functions, you can use the <code>return</code> statement both to exit early and specify a return value for the last call to the <code>next()</code>method. </p>
<pre><code>function *createIterator(){
    yield 1;
    return 42;
    yield 2;
    yield 3;
}
let iterator = createIterator();
console.log(iterator.next());   //&quot;{ value: 1, done: false }&quot;
console.log(iterator.next());   //&quot;{ value: 42, done: true }&quot;
</code></pre><blockquote>
<p>The spread operator and <code>for-of</code> ignore any value specified by a <code>return</code> statement. As soon as they see <code>done</code> is <code>true</code>, they stop without reading the <code>value</code>. Iterator return values are helpful, however, when delegating generators.</p>
</blockquote>
<h3 id="Delegating-Generators"><a href="#Delegating-Generators" class="headerlink" title="Delegating Generators"></a>Delegating Generators</h3><p>In some cases, combining the values from with two iterators into one is useful. Generators can delegate to other iterators using a special form of <code>yield</code> with a star (<code>*</code>) character.</p>
<pre><code>function *createNumberIterator(){
    yield 1;
    yield 2;
}
function *createColorIterator(){
    yield “red”;
    yield “green”;
}
function *createCombinedIterator(){
    yield *createNumberIterator();
    yield *createColorIterator();
    yield true;
}

var iterator = createCombinedIterator();
</code></pre><p>Generator delegation also lets you make further use of generator return values.</p>
<pre><code>function *createNumberIterator(){
    yield 1;
    yield 2;
    return 3;
}
function *createRepeatingIterator(count){
    for(let i=0;i&lt;count; i++){
        yield “repeat”;
    }
}
function *createCombinedIterator(){
    let result = yield *createNumberIterator();
    yield *creteaRepeatingIterator(result);
}
var iterator = createCombinedIterator();
</code></pre><p>Generator delegation using the return value is a very powerful paradigm that allows for some very interesting possibilities, especially when used in conjunction with asynchronous operations.</p>
<blockquote>
<p>You can use <code>yield *</code> directly on strings(such as <code>yield * “hello”</code>) and the string’s default iterator will be used.</p>
</blockquote>
<h2 id="Asynchronous-Task-Running"><a href="#Asynchronous-Task-Running" class="headerlink" title="Asynchronous Task Running"></a>Asynchronous Task Running</h2><p>A lot of the excitement around generators is directly related to asynchronous programming. Since generators allow you to effectively pause code in the middle of execution, they open up a lot of possibilities related to asynchronous processing.</p>
<p>The traditional way to perform asynchronous operations is to call a function that has a callback. For example, consider reading a file from the disk in Node.js:</p>
<pre><code>let fs = require(“fs”);
fs.readFile(“config.json,function(err,contents){
    if(err){
        throw err;
    }
    doSomethingWith(contents);
    console.log(“Done”);
})
</code></pre><p>The <code>fs.readFile()</code> method is called with the file name to read and a callback function. When the operation is finished, the callback checks to see if there’s no error, and if not, processes the returned <code>contents</code>. This works well when you have a small,finite number of asynchronous tasks to complete, but gets complicated when you need to nest callbacks or otherwise sequence a series of asynchronous tasks. This is where generators and <code>yield</code> are helpful.</p>
<h3 id="A-Simple-Task-Runner"><a href="#A-Simple-Task-Runner" class="headerlink" title="A Simple Task Runner"></a>A Simple Task Runner</h3><p>Because <code>yield</code> stops execution and waits for the <code>next()</code> method to be called before starting again, you can implement asynchronous calls without managing callbacks. To start, you need a function that can call a generator and start the iterator, such as this:</p>
<pre><code>function run(taskDef){
    //create the iterator, make available elsewhere
    let task = taskDef();

    //start the task
    let result = task.next();

    //recursive function to keep calling next()
    function step(){
        //if there’s more to do
        if(!result.done){
            result = task.next();
            step();
        }
    }
    //start the process
    step();
}
</code></pre><h3 id="Task-Running-With-Data"><a href="#Task-Running-With-Data" class="headerlink" title="Task Running With Data"></a>Task Running With Data</h3><p>The easiest way to pass data through the task runner is to pass the value specified by <code>yield</code> into the next call to the <code>next()</code> method. To do so, you need only pass <code>result.value</code></p>
<pre><code>...
        if(!result.done){
            result = task.next(result.value);
            step();
        }
</code></pre><p>Now that data is flowing between calls to <code>yield</code>, you just need one small change to allow asynchronous calls.</p>
<h3 id="Asynchronous-Task-Runner"><a href="#Asynchronous-Task-Runner" class="headerlink" title="Asynchronous Task Runner"></a>Asynchronous Task Runner</h3><p>The previous example passed static data back and forth between <code>yield</code> calls, but waiting for an asynchronous process is slightly different.~The task runner needs to know about callbacks and how to use them.~ And since <code>yield</code> expression pass their values into the task runner, that means any function call must return a value that somehow indicates the call is an asynchronous operation that the task runner should wait for.</p>
<p>Here’s one way you might signal that a value is an asynchronous operation:</p>
<pre><code>function fetchData(){
    return function(callback){
        setTimeout(function(){
            callback(null,”Hi!”);
        }, 50);
    };
}
</code></pre><p>For the purposes of this example, any function meant to be called by the task runner will return a function that executes a callback. The <code>fetchData()</code> function returns a function that accepts a callback function as an argument. When the returned function is called, it executes the callback function with a single piece of data. The <code>callback</code> argument needs to come from the task runner to ensure executing the callback correctly interacts with the underlying iterator. You just have to make sure each function that wants to be called using <code>yield</code> follows the same pattern.</p>
<p>With a good understanding of how a function can signal that it’s an asynchronous process, you can modify the task runner to take that fact into account.<br>Anytime <code>result.value</code> is a function, the task runner will execute it.</p>
<pre><code>...
        if(!result.done){
            if(typeof result.value === “function”){
                result.value(function(err,data){
                    if(err){
                        result = task.throw(err);
                        return;
                    }
                    result = task.next(data);
                    step();
                });
            } else {
                result = task.next(result.value);
                step();
            }
        }
    }
    //start the process
    step();
}
</code></pre><p>When <code>result.value</code> is a function, it is called with a callback function. That callback function follows the Node.js convention of passing any possible error as the first argument (<code>err</code>) and the result as the second argument. </p>
<p>This new version of the task runner is ready for all asynchronous tasks. To read data from a file in Node.js, you need to create a wrapper around <code>fs.readFile()</code> that returns a function similar to the <code>fetchData()</code>. For example:</p>
<pre><code>let fs = require(“fs”);
function readFile(filename){
    return function(callback){
        fs.readFile(filename,callback);
    };
}
</code></pre><p>The <code>readFile()</code> method returns a function that calls a callback. The callback is passed directly to the <code>fs.readFile()</code> method, which will execute the callback upon completion. You can then run this task using <code>yield</code> as follows:</p>
<pre><code>run(function*(){
    let contents = yield readFile(“config.json”);
    doSomethingWith(contents);
    console.log(“Done”);
});
</code></pre><p>This example is performing the asynchronous <code>readFile()</code> operation without making any callbacks visible in the main code. </p>
<h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>The <code>Symbol.iterator</code> symbol is used to define default iterators for objects. When <code>Symbol.iterator</code> is provided on an object, the object is considered an iterable.</p>
<p>The <code>for-of</code> loop uses iterables to return a series of values in a loop. Using <code>for-of</code> is easier than iterating with a traditional <code>for</code> loop because you no longer need to track values and control when the loop ends. The <code>for-of</code> loop automatically reads all values from the iterator until there are no more, and then it exits.</p>
<p>To make <code>for-of</code> easier to use, many values in ECMAScript 6 have default iterators. All the collection types—arrays, maps, and sets—have iterators designed to make their contents easy to access. Strings also have a default iterator, which makes iterating over the characters of the string (rather than the code units) easy.</p>
<p>The spread operator works with any iterable and makes converting iterables into arrays easy, too. </p>
<p>A generator is a special function that automatically creates an iterator when called. Generator definitions are indicated by a star (<code>*</code>) character and use of the <code>yield</code> keyword to indicate which value to return for each successive call to the <code>next()</code> method.</p>
<p>Generator delegation encourages good encapsulation of iterator behavior by letting you reuse existing generators in new generators. You can use an existing generator inside another generator by calling <code>yield*</code> instead of <code>yield</code>. This process allows you to create an iterator that returns values from multiple iterators.</p>
<p>Instead of needing to use callbacks everywhere, you can set up code that looks synchronous but in fact uses <code>yield</code> to wait for asynchronous operations to complete.</p>
<h1 id="09-Introducing-Javascript-Classes"><a href="#09-Introducing-Javascript-Classes" class="headerlink" title="09.Introducing Javascript Classes"></a>09.Introducing Javascript Classes</h1><h2 id="Class-Like-Structures-in-ECMAScript-5"><a href="#Class-Like-Structures-in-ECMAScript-5" class="headerlink" title="Class-Like Structures in ECMAScript 5"></a>Class-Like Structures in ECMAScript 5</h2><p>The closest equivalent to a class was creating a constructor and then assigning methods to the constructor’s prototype, an approach typically called creating a custom type. </p>
<pre><code>function PersonType(name){
    this.name = name;
}
PersonType.prototype.sayName = function(){
    console.log(this.name);
};
let person = new PersonType(“Nicholas”);
person.sayName();  
</code></pre><h2 id="Class-Declarations"><a href="#Class-Declarations" class="headerlink" title="Class Declarations"></a>Class Declarations</h2><p>The simplest class form in ECMAScript 6 is the class declaration.</p>
<h3 id="A-Basic-Class-Declaration"><a href="#A-Basic-Class-Declaration" class="headerlink" title="A Basic Class Declaration"></a>A Basic Class Declaration</h3><pre><code>class PersonClass{
    //equivalent of the PersonType constructor
    constructor(name){
        this.name = name;
    }
    //equivalent of PersonType.prototype.sayName
    sayName(){  
        console.log(this.name);
    }
}

let person = new PersonClass(“Nicholas”);
person.sayName();
</code></pre><blockquote>
<p><em>Own properties</em>, properties that occur on the instance rather than the prototype, can only be created inside a class constructor or method. In this example, <code>name</code> is an own property. I recommend creating all possible own properties inside the constructor function so a single place in the class is a respnsible for all of them.</p>
</blockquote>
<p>Interestingly, class declarations are just syntactic sugar on top of the existing custom type declaration.</p>
<h3 id="Why-to-Use-the-Class-Syntax"><a href="#Why-to-Use-the-Class-Syntax" class="headerlink" title="Why to Use the Class Syntax"></a>Why to Use the Class Syntax</h3><p>Despite the similarities between classes and custom types, there are som important differences.</p>
<ol>
<li>Class declarations, unlike function declarations, are not hoisted. Class declarations act like <code>let</code> declarations and so exist in the temporal dead zone until execution reaches the declaration.</li>
<li>All code inside of class automatically runs in strict mode  automatically. </li>
<li>All methods are non-enumerable. This is a significant change from custom types, where you need to use <code>Object.defineProperty()</code> to make a method non-enumerable.</li>
<li>All methods lack an internal <code>[[Construct]]</code> method and will throw an error if you try to call them with <code>new</code>.</li>
<li>Calling the class constructor without <code>new</code> throw an error.</li>
<li>Attempting to overwrite the class name within a class method throws an error.</li>
</ol>
<p>With all of this in mind, the <code>PersonClass</code> declaration from the previous example is directly equivalent to the following code, which doesn’t use the class syntax:</p>
<pre><code>//directly equivalent of PersonClass
let PersonType2 = (function(){
    “use strict”;
    const PersonType2 = function(name){
        //make sure the function was called with new
        if(typeof new.target === “undefined”){
            throw new Error(“Constructor must be called with new.”);
        }
        this.name = name;
    }

    Object.defineProperty(PersonType2.prototype, “sayName”,{
        value:function(){
            //make suer the method wasn’t called with new
            if(typeof new.target !== “undefined”){
                throw new Error(“Method cannot be called with new.”);
            }
            console.log(this.name);
        },
        enumerable:false,
        writable:true,
        configurable:true
    });
    return PersonType2;
}());
</code></pre><p>First, notice that there are two <code>PersonType2</code> declarations: a <code>let</code> declaration in the outer scope and a <code>const</code> declaration inside the IIFE. This is how class methods are forbidden from overwriting the class name while code outside the class is allowed to do so. </p>
<h2 id="Class-Expressions"><a href="#Class-Expressions" class="headerlink" title="Class Expressions"></a>Class Expressions</h2><p>Function and class declarations begin with an appropriate keyword (<code>function</code> or <code>class</code>,respectively) followed by an identifier. These <em>class expressions</em> are designed to be used in variable declarations or passed into functions as arguments.</p>
<h3 id="A-Basic-Class-Expression"><a href="#A-Basic-Class-Expression" class="headerlink" title="A Basic Class Expression"></a>A Basic Class Expression</h3><pre><code>let PersonClass = class{
    //equivalent of the PersonType constructor
    constructor(name){
        this.name = name;
    }
    //equivalent of PersonType.prototype.sayName
    sayName(){
        console.log(this.name);
    }
};

let person = new PersonClass(“Nicholas”);
person.sayName();
</code></pre><p>Aside from the syntax, class expressions are functionally equivalent to class declarations.</p>
<h3 id="Named-Class-Expressions"><a href="#Named-Class-Expressions" class="headerlink" title="Named Class Expressions"></a>Named Class Expressions</h3><pre><code>let PersonClass = class PersonClass2 {
    constructor(name){
        this.name = name;
    }
    sayName(){
        console.log(this.name);
    }
};
console.log(typeof PersonClass);    //“function”
console.log(typeof PersonClass2);   //“undefined”
</code></pre><p>The <code>PersonClass2</code> identifier exists only within the class definition so that it can be used inside the class methods. To understand why,look at an equivalent declaration that doesn’t use classes:</p>
<pre><code>//direct equivalent of PersonClass named class expression
let PersonClass = (function(){
    “use strict”;
    const PersonClass2 = function(name){
        ...
    }

    Object.defineProperty(PersonClass2.prototype,”sayName”,{
        ...
    });
    return PersonClass2;
}());
</code></pre><p>For class declarations, the outer binding (defined with <code>let</code>) has the same name as the inner binding(defined with <code>const</code>). A named class expression uses its name in the <code>const</code> definition, so <code>PersonClass2</code> is defined for use only inside the  class.</p>
<h2 id="Class-as-First-Class-Citizens"><a href="#Class-as-First-Class-Citizens" class="headerlink" title="Class as First-Class Citizens"></a>Class as First-Class Citizens</h2><p>In programming, ~something is said to be a <em>first-class citizen</em> when it can be used as a value~, meaning it can be passed into a function, returned from a function, and assigned to a variable. JavaScript functions are first-class citizens.</p>
<p>ECMAScript 6 continues this tradition by making classes first-class citizens as well.</p>
<pre><code>function createObject(classDef){
    return new classDef();
}
let obj = createObject(class{
    sayHi(){
        console.log(“Hi”);
    }
});
obj.sayHi();    //“Hi!”
</code></pre><p>Another interesting use of class expressions is creating singletons by immediately invoking the class constructor. To do so, you must use <code>new</code> with a class expression and include parentheses at the end.</p>
<pre><code>let person = new class{
    constructor(name){
        this.name = name;
    }
    sayName(){
        console.log(this.name);
    }
}(“Nicholas”);

person.sayName();
</code></pre><p>This pattern allows you to use the class syntax for creating singletons without leaving a class reference available for inspection.<br>You can also create accessor properties on classes using a syntax similar to object literals.</p>
<h2 id="Accessor-Properties"><a href="#Accessor-Properties" class="headerlink" title="Accessor Properties"></a>Accessor Properties</h2><p>While own properties should be created inside class constructors, classes allow you to define accessor properties on the prototype.</p>
<pre><code>class CustomHTMLElement{
    constructor(element){
        this.element = element;
    }
    get html(){
        return this.element.innerHTML;
    }
    set html(value){
        this.element.innerHTML = value;
    }
}
</code></pre><p>In this code, the <code>CustomHTMLElement</code> class is made as a wrapper around an existing DOM element. It has both a getter and setter for <code>html</code> that delegates to the <code>innerHTML</code> method on the element itself. This accessor property is created on the <code>CustomHTMLElement.prototype</code> and, just like any other method would be, is created as non-enumerable.</p>
<h3 id="Computed-Member-Names"><a href="#Computed-Member-Names" class="headerlink" title="Computed Member Names"></a>Computed Member Names</h3><p>The similarities between object literals and classes aren’t quite over yet. Class methods and accessor properties can also have computed names. ~Instead of using an identifier, use square brackets around an expression, which is the same syntax used for object literal computed names~.</p>
<pre><code>let methodName = “sayName”;
class PersonClass{
    constructor(name){
        this.name = name;
    }

    [methodName](){
        console.log(this.name);
    }
}
let me = new PersonClass(“Nicholas”);
me.sayName();   //“Nicholas”
</code></pre><h2 id="Generator-Methods"><a href="#Generator-Methods" class="headerlink" title="Generator Methods"></a>Generator Methods</h2><pre><code>class MyClass{
    *createIterator(){
        yield 1;
        yield 2;
        yield 3;
    }
}
let instance = new MyClass();
let iterator = instance.createIterator();
</code></pre><p>Generator methods are useful when you have an object that represents a collection of values and you’d like to iterate over those values easily.</p>
<p>While generator methods are useful, defining a default iterator for your class is much more helpful if the class represents a collection of values. You can define the default iterator for a class by using <code>Symbol.iterator</code> to define a generator method, such as:</p>
<pre><code>class Collection{   
    constructor(){
        this.items = [];
    }
    *[Symbol.iterator](){
        yield*this.items.values();
    }
}

var collection = new Collection();
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for(let x of collection){
    console.log(x);
}
</code></pre><p>This example uses a computed name for a generator method that delegates to the <code>values()</code> iterator of the <code>this.items</code> array.</p>
<p>Adding methods and accessor properties to a class prototype is useful when you want those to show up on object instance. If, on the other hand, you’d like methods or accessor properties on the class itself, then you’ll need to use static members.</p>
<h2 id="Static-Members"><a href="#Static-Members" class="headerlink" title="Static Members"></a>Static Members</h2><p>Adding additional methods directly onto constructors to simulate static members is another common pattern in ECMAScript 5 and earlier.</p>
<pre><code>function PersonType(name){
    this.name = name;
}

//static method
PersonType.create = function(name){
    return new PersonType(name);
};

//instance method
PersonType.prototype.sayName = function(){
    console.log(this.name);
};

var person = PersonType.create(“Nicholas”);
</code></pre><p>ECMAScript 6 classes simplify the creation of static members by using the formal <code>static</code> annotation before the method or accessor property name.</p>
<pre><code>class PersonClass{
    constructor(name){
        this.name = name;
    }
    sayName(){
        ...
    }
    static create(name){
        return new PersonClass(name);
    }
}

let person = PersonClass.create(“Nicholas”);
</code></pre><blockquote>
<p>Static members are not accessible from instances. You must always access static members from the class directly.</p>
</blockquote>
<h2 id="Inheritance-with-Derived-Classes"><a href="#Inheritance-with-Derived-Classes" class="headerlink" title="Inheritance with Derived Classes"></a>Inheritance with Derived Classes</h2><p>Prior to ECMAScript 6, implementing inheritance with custom types was an extensive process. Proper inheritance required multiple steps:</p>
<pre><code>function Rectangle(length,width){
    this.length = length;
    this.width = width;
}
Rectangle.prototype.getArea = function(){
    return this.length * this.width;
};
function Square(length){
    Rectangle.call(this,length,length);
}
Square.prototype = Object.create(Rectangle.prototype,{
    constructor:{
        value:Square,
        enumerable:true,
        writable:true,
        configurable:true
    }
});
var square = new Square(3);

console.log(square instanceof Square);  //true
console.log(square instanceof Rectangle);   //true
</code></pre><p><code>Square</code> inherits from <code>Rectangle</code>, and to do so, it must overwrite <code>Square.prototype</code> with a new object created from <code>Rectangle.prototype</code> as well as call the <code>Rectangle.call()</code> method.</p>
<p>Classes makes inheritance easier to implement by using the familiar <code>extends</code> keyword to specify the function from which the class should inherit. The prototypes are automatically adjusted, and you can access the base class constructor by calling the <code>super()</code> method.</p>
<pre><code>class Rectangle{
    constructor(length,width){
        this.length = length;
        this.width = width;
    }
    getArea(){
        return this.length * this.width;
    }
}

class Square extends Rectangle{
    constructor(length){
        //same as Rectangle.call(this,length,length)
        super(length,length);
    }
}

var square = new Square(3);
</code></pre><p>The <code>Square</code> constructor uses <code>super()</code> to call the <code>Rectangle</code> constructor with the specified arguments. Note that unlike the ECMAScript 5 version of the code, the Identifier <code>Rectangle</code> is only used within the class declaration(after <code>extends</code>).</p>
<p>Classes that inherit from other classes are referred to as <em>derived classes.</em> Derived classes require you to use <code>super()</code> if you specify a constructor. If you choose not to use a constructor, then <code>super()</code> is automatically called for you with all arguments upon creating a new instance of the class. For instance, the following two classes are identical:</p>
<pre><code>class Square extends Rectangle{
    //no constructor
}

//Is equivalent to

class Square extends Rectangle{
    constructor(...args){
        super(...args);
    }
}
</code></pre><p>The second class in this example shows the equivalent of the default constructor for all derived classes. All of the arguments are passed, in order, to the base class constructor. In this case, the functionality isn’t quite correct because the <code>Square</code> constructor needs only one argument, and so it’s best to manually define the constructor.</p>
<blockquote>
<p>There are a few things to keep in mind when using <code>super()</code></p>
<ol>
<li>You can only use <code>super()</code> in a derived class. If you try to use it in a non-derived class(a class that doesn’t use <code>extends</code>) or a function, it will throw an error.</li>
<li>You must call <code>super()</code> before accessing <code>this</code> in the constructor. Since <code>super()</code> is responsible for initializing <code>this</code>, attempting to access <code>this</code> before calling <code>super()</code> results in an error.</li>
<li>The only way to avoid calling <code>super()</code> is to return an object from the class constructor.</li>
</ol>
</blockquote>
<h3 id="Shadowing-Class-Methods"><a href="#Shadowing-Class-Methods" class="headerlink" title="Shadowing Class Methods"></a>Shadowing Class Methods</h3><p>The methods on derived classes always shadow methods of the same name on the base class. For instance, you can add <code>getArea()</code> to <code>Square</code> to define that functionality.</p>
<pre><code>class Square extends Rectangle{
    constructor(length){
        super(length,length);
    }

    //override and shadow Rectangle.prototype.getArea()
    getArea(){
        return this.length * this.length;
    }
}
</code></pre><p>Since <code>getArea()</code> is defined as part of <code>Square</code>, the <code>Rectangle.prototype.getArea()</code> method will no longer be called by any instances of <code>Square</code>. Of course, you can always decide to call the base class version of the method by using the <code>super.getArea()</code> method.</p>
<h3 id="Inherited-Static-Members"><a href="#Inherited-Static-Members" class="headerlink" title="Inherited Static Members"></a>Inherited Static Members</h3><p>If a base class has static members, those static members are also available on the derived class.</p>
<pre><code>class Rectangle{
    constructor(length,width){
        ...
    }
    getArea(){
        ...
    }
    static create(length,width){
        return new Rectangle(length,width);
    }
}

class Square extends Rectangle{
    constructor(length){
        super(length,length);
    }
}

var rect = Square.create(3,4);

console.log(rect instanceof Rectangle); //true
console.log(rect instanceof Square);    //false
</code></pre><h3 id="Derived-Classes-from-Expressions"><a href="#Derived-Classes-from-Expressions" class="headerlink" title="Derived Classes from Expressions"></a>Derived Classes from Expressions</h3><p>Perhaps the most powerful aspect of derived classes in ECMAScript 6 is the ability to derive a class from an expression. You can use <code>extends</code> with any expression as long as the expression resolves to a function with <code>[[Construct]]</code> and a prototype.</p>
<pre><code>function Rectangle(length,width){
    this.length = length;   this.width = width;
}

Rectangle.prototype.getArea = function(){
    return this.length * this.width;
};

class Square extends Rectangle{
    constructor(length){
        super(length,length);
    }
}

var x = new Square(3);
console.log(x instanceof Rectangle);    //true
</code></pre><p><code>Rectangle</code> is defined as an ECMAScript 5-style constructor while <code>Square</code> is a class. Since <code>Rectangle</code> has <code>[[Construct]]</code> and a prototype, the <code>Square</code> class can still inherit directly from it.</p>
<p>Accepting any type of expression after <code>extends</code> offers powerful possibilities, such as dynamically determining what to inherit from.</p>
<pre><code>function Rectangle(length,width){
    this.length = length;
    this.width = width;
}
Rectangle.prototype.getArea = function(){
    return this.length * this.width;
};
function getBase(){
    return Rectangle;
}
class Square extends getBase(){
    constructor(length){
        super(length,length);
    }
}
</code></pre><p>Since you can determine the base class dynamically, it’s possible to create different inheritance approaches. For instance, you can effectively create mixins:</p>
<pre><code>let SerializableMixin = {
    serialize(){
        return JSON.stringify(this);
    }
};
let AreaMixin = {
    getArea(){
        return this.length * this.width;
    }
};
function mixin(...mixins){
    var base = function(){};
    Object.assign(base.prototype,...mixins);
    return base;
}
class Square extends mixin(AreaMixin,SerializableMixin){
    constructor(length){
        super();
        this.length = length;
        this.width = length;
    }
}

var x = new Square(3);
console.log(x.getArea());       //9
console.log(x.serialize()); //“{“length”:3,”width”:3}”
</code></pre><p>In this example, mixins are used instead of classical inheritance. The <code>mixin()</code> function takes any number of arguments that represent mixin objects. It creates a function called <code>base</code> and assigns the properties of each mixin object to the prototype. The function is then returned so <code>Square</code> can use <code>extends</code>. Keep in mind that since <code>extends</code> is still used, you’re required to call <code>super()</code> in the constructor.</p>
<p>The instance of <code>Square</code> has both <code>getArea()</code> and <code>serialize</code>. This is accomplished through prototype life inheritance. The <code>mixin()</code> function dynamically populates the prototype of a new function with all of the own properties of each mixin.</p>
<blockquote>
<p>Any expression can be used after <code>extends</code>, but not all expressions result in a valid class. Specifically, the following expression types cause errors:<code>null</code> &amp; generator functions, because there’s no <code>[[Construct]]</code> to call.</p>
</blockquote>
<h3 id="Inheriting-from-Built-ins"><a href="#Inheriting-from-Built-ins" class="headerlink" title="Inheriting from Built-ins"></a>Inheriting from Built-ins</h3><p>One goal of ECMAScript 6 classes is to allow inheritance from all built-ins. In order to accomplish this, the inheritance model of classes is slightly different than the classical inheritance model found in ECMAScript 5 and earlier:</p>
<p>In ECMAScript 5 classical inheritance, the value of <code>this</code> is first created by the derived type(for example,<code>MyArray</code>), and then the base type constructor(<code>Array.apply()</code>) is called. That means <code>this</code> starts out as an instance of <code>MyArray</code> and then is decorated with additional properties from <code>Array</code>.</p>
<p>In ECMAScript 6 class-based inheritance, the value of <code>this</code> is first created by the base (<code>Array</code>) and then modified by the derived class constructor(<code>MyArray</code>). The result is that <code>this</code> starts with all the built-in functionality of the base and correctly receives all functionality related to it.</p>
<pre><code>class MyArray extends Array{
    //empty
}

var colors = new MyArray();
colors[0] = “red”;
console.log(colors.length); //1

colors.length = 0;
console.log(colors[0]); //undefined
</code></pre><p><code>MyArray</code> inherits directly from <code>Array</code> and therefore works like <code>Array</code>. </p>
<h3 id="The-Symbol-species-Property"><a href="#The-Symbol-species-Property" class="headerlink" title="The Symbol.species Property"></a>The Symbol.species Property</h3><p>An interesting aspect of inheriting from built-ins is that any method that returns an instance of the built-in will automatically return a derived class instance instead. </p>
<pre><code>class MyArray extends Array{
    //empty
}
let items = new MyArray(1,2,3,4),
      subitems = items.slice(1,3);

console.log(items instanceof MyArray);  //true
console.log(subitems instanceof MyArray);   //true
</code></pre><p>Behind the scenes, it’s the <code>Symbol.species</code> property that is making this change.<br>The <code>Symbol.species</code> well-known symbol is used to define a static accessor property that returns a function. That function is a constructor to use whenever an instance of the class must be created inside of an instance method(instead of using the constructor). The following built in types have <code>Symbol.species</code> defined:</p>
<ul>
<li><code>Array</code></li>
<li><code>ArrayBuffer</code></li>
<li><code>Map</code></li>
<li><code>Promise</code></li>
<li><code>RegExp</code></li>
<li><code>Set</code></li>
<li>Typed Arrays</li>
</ul>
<p>Each of these types has a default <code>Symbol.species</code> property that returns <code>this</code>, meaning the property will always return the constructor function. If you were to implement that functionality on a custom class, the code would look like:</p>
<pre><code>//several builtin types use species similar to this
class MyClass{
    static get[Symbol.species](){
        return this;
    }

    constructor(value){
        this.value = value;
    }
    clone(){
        return new this.constructor[Symbol.species](this.value);
</code></pre><p>In this example, the <code>Symbol.species</code> is used to assign a static accessor property to <code>MyClass</code>. Note that there’s only a getter without a setter, because changing the species of a class isn’t possible. Any call to <code>this.constructor[Symbol.species]</code> returns <code>MyClass</code>. The <code>clone()</code> method uses that definition to return a new instance rather than directly using <code>MyClass</code>, which allows derived classes to override that value.</p>
<pre><code>class MyClass{
    static get [Symbol.species](){
        return this;
    }
    constructor(value){
        this.value = value;
    }
    clone(){
        return new this.constructor[Symbol.species](this.value);
    }
}
class MyDerivedClass1 extends MyClass{
    //empty
}
class MyDerivedClass2 extends MyClass(){
    static get[Symbol.species](){
        return MyClass;
    }
}

let instance1 = new MyDerivedClass1(“foo”),
    clone1 = instance1.clone(),
    instance2 = new MyDerivedClass2(“bar”),
    clone2 = instance2.clone();

console.log(clone1 instanceof MyClass); //true
console.log(clone1 instanceof MyDerivedClass1); //true
console.log(clone2 instanceof MyClass); //true
console.log(clone2 instanceof MyDerivedClass2); //false
</code></pre><p>Here, <code>MyDerivedClass2</code> class inherits from <code>MyClass</code> and override <code>Symbol.species</code> to return <code>MyClass</code>. Using <code>Symbol.species</code>, any derived class can determine what type of value should be returned when a method returns an instance.</p>
<p>For instance, <code>Array</code> uses <code>Symbol.species</code> to specify the class to use for methods that return an array. In a class derived from <code>Array</code>, you can determine the type of object returned from the inherited methods, such as:</p>
<pre><code>class MyArray extends Array{
    static get[Symbol.species](){
        return Array;
    }
}

let items = new MyArray(1,2,3,4),
    subitems = items.slice(1,3);

console.log(items instanceof MyArray);  //true
console.log(subitems instanceof Array); //true
</code></pre><p>This code overrides <code>Symbol.species</code> on <code>MyArray</code>, which inherits from <code>Array</code>. All of the inherited methods that return arrays will now use an instance of <code>Array</code> instead of <code>MyArray</code>.</p>
<h3 id="Using-new-target-in-Class-Constructors"><a href="#Using-new-target-in-Class-Constructors" class="headerlink" title="Using new.target in Class Constructors"></a>Using new.target in Class Constructors</h3><p>In Chapter 3, you learned about <code>new.target</code> and how its value changes depending on how a function is called. You can also use <code>new.target</code> in class constructors to determine how the class is being invoked. In the simple case, <code>new.target</code> is equal to the constructor function for the class, as in this example:</p>
<pre><code>class Rectangle{
    constructor(length,width){
        console.log(new.target === Rectangle);
        this.length = length;
        this.width = width;
    }
}
//new.target is Rectangle
var obj = new Rectangle(3,4);   //outputs true
</code></pre><p>Class constructors can’t be called without <code>new</code>, so the <code>new.target</code> property is always defined inside of class constructors. But the value may not always be the same. Consider this code:</p>
<pre><code>class Rectangle{
    constructor(length,width){
        console.log(new.target === Rectangle);
        this.length = length;
        this.width = width;
    }
}

class Square extends Rectangle{
    constructor(length){
        super(length,length)
    }
}

//new.target is Square
var obj = new Square(3);    //outputs false
</code></pre><p><code>Square</code> is calling the <code>Rectangle</code> constructor, so <code>new.target</code> is equal to <code>Square</code> when the <code>Rectangle</code> constructor is called. This is important because it gives each constructor the ability to alter its behavior based on how it’s being called. For instance, you can create an abstract base class(one that can’t be instantiated directly) by using <code>new.target</code> as follows:</p>
<pre><code>//abstract base class
class Shape{
    constructor(){
        if(new.target === Shape){
            throw new Error(“This class cannot be instantiated directly.”)
        }
    }
}
class Rectangle extends Shape{
    constructor(length,width){
        super();
        this.length = length;
        this.width = width;
    }
}

var x = new Shape();    //throws error
var y = new Rectangle(3,4); //no error
console.log(y instanceof Shape);    //true
</code></pre><blockquote>
<p>Since classes can’t be called without <code>new</code>, the <code>new.target</code> property is never <code>undefined</code> inside of a class constructor.</p>
</blockquote>
<h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>ECMAScript 6 classes work with prototypal inheritance by defining non-static methods on the class prototype, while static methods end up on the constructor itself. All methods are non-enumerable, a feature that better matches the behavior of built-in objects for which methods are typically non-enumerable by default. Additionally, class constructors can’t be called without <code>new</code>, ensuring that you can’t accidentally call a class as a function.</p>
<p>Class-based inheritance allows you to derive a class from another class, function, or expression. This ability means you can call a function to determine the correct base to inherit from, allowing you to use mixins and other different composition patterns to create a new class. Inheritance works in such a way that inheriting from built-in objects like <code>Array</code> is now possible and works as expected.</p>
<p>You can use <code>new.target</code> in class constructors to behave differently depending on how the class is called.</p>
<h1 id="10-Improved-Array-Capabilities"><a href="#10-Improved-Array-Capabilities" class="headerlink" title="10.Improved Array Capabilities"></a>10.Improved Array Capabilities</h1><h2 id="Creating-Arrays"><a href="#Creating-Arrays" class="headerlink" title="Creating Arrays"></a>Creating Arrays</h2><p>Prior to ECMAScript 6, there were two primary ways to create arrays: the <code>Array</code> constructor and array literal syntax. Both approach require listing array items individually and are otherwise fairly limited. Options for converting an array-like object (an object with numeric indices and a <code>length</code> property) into an array were also limited and required extra code. ECMAScript 6 adds the <code>Array.of()</code> and <code>Array.from()</code> methods.</p>
<h3 id="The-Array-of-Method"><a href="#The-Array-of-Method" class="headerlink" title="The Array.of() Method"></a>The Array.of() Method</h3><p>The <code>new Array()</code> constructor actually behaves differently based on the type and number of arguments passed to it. For example:</p>
<pre><code>let items = new Array(2);
console.log(item.length);       //2
console.log(items[0]);  //undefined

items = new Array(“2”);
console.log(items.length);  //1
console.log(items[0]);  //“2”

items = new Array(1,2);
console.log(items.length);  //2
console.log(items[0]);  //1

items = new Array(3,”2”);
console.log(items.length);  //2
console.log(items[1]);  //“2”
</code></pre><p>ECMAScript 6 introduces <code>Array.of()</code> to solve this problem. The <code>Array.of()</code> method always creates an array containing its arguments regardless of the number of arguments or the argument types. Here are some examples that use the <code>Array.of()</code> method.</p>
<pre><code>let items = Array.of(2);
console.log(items.length);  //1
console.log(items[0]);  //2
</code></pre><p>You can use an array literal instead of <code>Array.of()</code> for native arrays most of the time. But if you ever need to pass the <code>Array</code> constructor into a function, then you might want to pass <code>Array.of()</code> instead to ensure consistent behavior.</p>
<pre><code>function createArray(arrayCreator,value){
    return arrayCreator(value);
}
let items = createArray(Array.of,value);
</code></pre><p>It would be dangerous to pass <code>Array</code> directly if you cannot guarantee that <code>value</code> won’t be a number.</p>
<h3 id="The-Array-from-Method"><a href="#The-Array-from-Method" class="headerlink" title="The Array.from() Method"></a>The Array.from() Method</h3><p>To convert an array-like object to an array in ECMAScript 5, you’d like to write a function like the one in this example:</p>
<pre><code>function makeArray(arrayLike){
    var result = [];
    for(var i = 0,len = arrayLike.length; i &lt; len; i++){
        result.push(arrayLike[i]);
    }
    return result;
}

function doSomething(){
    var args = makeArray(arguments);
    //use args
}
</code></pre><p>Eventually, developers discovered they could reduce the amount of code by calling the native <code>slice()</code> method for arrays on array-like objects, like this:</p>
<pre><code>function makeArray(arrayLike){
    return Array.prototype.slice.call(arrayLike);
</code></pre><p>Since <code>slice()</code> needs only numeric indices and <code>length</code> property to function correctly, any array-like object will work.</p>
<p>ECMAScript 6 added the <code>Array.from()</code> method as an obvious, yet clean, way to convert objects into arrays.</p>
<pre><code>function doSomething(){
    var args = Array.from(arguments);
}
</code></pre><h3 id="Mapping-Conversion"><a href="#Mapping-Conversion" class="headerlink" title="Mapping Conversion"></a>Mapping Conversion</h3><p>You can provide <code>Array.from()</code> with a mapping function as a second argument. That function operates on each value from the array-like object and converts it to some final form before storing the result at the appropriate index in the final array.</p>
<pre><code>function translate(){
    return Array.from(arguments, (value) =&gt; value + 1);
}

let numbers = translate(1,2,3);
console.log(numbers);   //2,3,4
</code></pre><p>If the mapping function is on an object, you can also optionally pass a third argument to <code>Array.from()</code> that represents the <code>this</code> value for the mapping function:</p>
<pre><code>let helper = {
    diff:1,
    add(value){
        return value + this.diff;
    }
};

function translate(){
    return Array.from(arguments,helper.add, helper);
}

let numbers = translate(1,2,3);
console.log(numbers);   //2,3,4
</code></pre><p>Since <code>helper.add()</code> uses the <code>this.diff</code>property, you need to provide the third argument to <code>Array.from()</code> specifying the value of <code>this</code>. </p>
<h3 id="Use-on-Iterables"><a href="#Use-on-Iterables" class="headerlink" title="Use on Iterables"></a>Use on Iterables</h3><p>The <code>Array.from()</code> method can convert any object with a <code>Symbol.iterator</code> property into an array. For example:</p>
<pre><code>let numbers = {
    *[Symbol.iterator](){
        yield 1;
        yield 2;
        yield 3;
    }
};

let numbers2 = Array.from(numbers,(value) =&gt; value + 1);
console.log(numbers2);  //2,3,4
</code></pre><h2 id="New-Methods-on-All-Arrays"><a href="#New-Methods-on-All-Arrays" class="headerlink" title="New Methods on All Arrays"></a>New Methods on All Arrays</h2><p>Continuing the trend from ECMAScript 5, ECMAScript 6 adds several new methods to arrays. The <code>find()</code> and <code>findIndex()</code> methods are meant to aid developers using arrays,while <code>fill()</code> and <code>copyWithin()</code> are inspired by use cases for <em>typed arrays,</em> a form of array introduced in ECMAScript 6 that uses only numbers.</p>
<h3 id="The-find-and-findIndex-Methods"><a href="#The-find-and-findIndex-Methods" class="headerlink" title="The find() and findIndex() Methods"></a>The find() and findIndex() Methods</h3><p>ECMAScript 5 added the <code>indexOf()</code> and <code>lastIndexOf()</code>, allowing developers to search for specific values inside an array, yet they were still fairly limited because you could only search for one value at a time. ECMAScript 6 solved that problem by introducing the <code>find()</code> and <code>findIndex()</code> methods.</p>
<p>Both <code>find()</code> and <code>findIndex()</code> accept two arguments: a callback function and an optional value to use for <code>this</code> inside the callback function. The callback function is passed an array element, the index of that element in the array, and the array itself—the same arguments passed to methods like <code>map()</code> and <code>forEach()</code>. The callback should return <code>true</code> if the given value matches some criteria you define. Both <code>find()</code> and <code>findIndex()</code> also stop searching the array the first time the callback function returns <code>true</code>.</p>
<p>The only difference is that <code>find()</code> returns the value whereas <code>findIndex()</code> returns the index at which the value was found.</p>
<pre><code>let numbers = [25,30,35,40,45];
console.log(numbers.find(n =&gt; n &gt; 33)); //35
console.log(numbers.findIndex(n =&gt; n &gt; 33));    //2
</code></pre><p>Both <code>find()</code> and <code>findIndex()</code> are useful to find an array element that matches a condition rather than a value. If you only want to find a value, then <code>indexOf()</code> and <code>lastIndexOf()</code> are better choices.</p>
<h3 id="The-fill-Method"><a href="#The-fill-Method" class="headerlink" title="The fill() Method"></a>The fill() Method</h3><pre><code>let numbers = [1,2,3,4];
numbers.fill(1);
console.log(numbers.toString());    //1,1,1,1
</code></pre><p>If you only want to change some of the elements, rather than all of them, you can optionally include a start index and an exclusive and an exclusive end index.</p>
<pre><code>numbers.fill(1,2);  //start filling at index 2
console.log(numbers.toString());    //1,2,1,1

numbers.fill(0,1,3);
console.log(numbers.toString());    //1,0,0,1
</code></pre><h3 id="The-copyWithin-Method"><a href="#The-copyWithin-Method" class="headerlink" title="The copyWithin() Method"></a>The copyWithin() Method</h3><pre><code>let numbers = [1,2,3,4];

//paste values into array starting at index 2
//copy values from array starting at index 0
//stop copying values when you hit index 1
numbers.copyWithin(2,0,1);
console.log(numbers.toString());    //1,2,1,4
</code></pre><h2 id="Typed-Arrays"><a href="#Typed-Arrays" class="headerlink" title="Typed Arrays"></a>Typed Arrays</h2><p>Typed arrays are special-purpose arrays designed to work with numeric types and provide better performance for arithmetic operations. The concept is that any single number can be treated like an array of bits and thus use the familiar methods available on JavaScript arrays.</p>
<h3 id="Numeric-Data-Types"><a href="#Numeric-Data-Types" class="headerlink" title="Numeric Data Types"></a>Numeric Data Types</h3><p>JavaScript numbers are stored in IEEE 754 format, which uses 64 bits to store a floating-point representation of the number. This format represents both integers and floats in JavaScript, with conversion between the two formats happening frequently as numbers change. Typed arrays allow the storage and manipulation of eight different numeric types:</p>
<ol>
<li>Signed 8-bit integer (int8)</li>
<li>Unsigned 8-bit integer (uint8) </li>
<li>Signed 16-bit integer (int16)</li>
<li>Unsigned 16-bit integer (uint16)</li>
<li>Signed 32-bit integer (int32)</li>
<li>Unsigned 32-bit integer (uint32)</li>
<li>32-bit float (float32) </li>
<li>64-bit float (float64)<br>Using bits more efficiently is one of the use cases typed arrays address.</li>
</ol>
<h3 id="Array-Buffers"><a href="#Array-Buffers" class="headerlink" title="Array Buffers"></a>Array Buffers</h3><p>The foundation for all typed arrays is an <em>array buffer</em>, which is a memory location that can contain a specified number of bytes. Creating an array buffer is akin to calling <code>malloc()</code> in C to allocate memory without specifying what the memory block contains. You can create an array buffer by using the <code>ArrayBuffer</code> constructor as follows:<br><code>let buffer = new ArrayBuffer(10);  // allocate 10 bytes</code></p>
<p>You can also use the <code>slice()</code> method to create a new array buffer that contains part of an existing array buffer.</p>
<pre><code>let buffer = new ArrayBuffer(10);   // allocate 10 bytes

let buffer2 = buffer.slice(4,6);
console.log(buffer2.byteLength);    //2
</code></pre><h3 id="Manipulating-Array-Buffers-with-Views"><a href="#Manipulating-Array-Buffers-with-Views" class="headerlink" title="Manipulating Array Buffers with Views"></a>Manipulating Array Buffers with Views</h3><p>Array buffers represent memory locations, and <em>views</em> are the interfaces you’ll use to manipulate that memory. The <code>DataView</code> type is a generic view on an array buffer that allows you to operate on all eight numeric data types.</p>
<pre><code>let buffer = new ArrayBuffer(10),
    view = new DataView(buffer);
</code></pre><pre><code>let buffer = new ArrayBuffer(10),
    view = new DataView(buffer,5,2);    // cover bytes 5 and 6
</code></pre><h3 id="Retrieving-View-Information"><a href="#Retrieving-View-Information" class="headerlink" title="Retrieving View Information"></a>Retrieving View Information</h3><h3 id="Reading-and-Writing-Data"><a href="#Reading-and-Writing-Data" class="headerlink" title="Reading and Writing Data"></a>Reading and Writing Data</h3><h3 id="Typed-Arrays-Are-Views"><a href="#Typed-Arrays-Are-Views" class="headerlink" title="Typed Arrays Are Views"></a>Typed Arrays Are Views</h3><h3 id="Creating-Type-Specific-Views"><a href="#Creating-Type-Specific-Views" class="headerlink" title="Creating Type-Specific Views"></a>Creating Type-Specific Views</h3><h2 id="Similarities-Between-Typed-and-Regular-Arrays"><a href="#Similarities-Between-Typed-and-Regular-Arrays" class="headerlink" title="Similarities Between Typed and Regular Arrays"></a>Similarities Between Typed and Regular Arrays</h2><h3 id="Common-Methods"><a href="#Common-Methods" class="headerlink" title="Common Methods"></a>Common Methods</h3><h3 id="The-Same-Iterators"><a href="#The-Same-Iterators" class="headerlink" title="The Same Iterators"></a>The Same Iterators</h3><h3 id="of-and-from-Methods"><a href="#of-and-from-Methods" class="headerlink" title="of() and from() Methods"></a>of() and from() Methods</h3><h2 id="Differences-Between-Typed-and-Regular-Arrays"><a href="#Differences-Between-Typed-and-Regular-Arrays" class="headerlink" title="Differences Between Typed and Regular Arrays"></a>Differences Between Typed and Regular Arrays</h2><h3 id="Behavioral-Differences"><a href="#Behavioral-Differences" class="headerlink" title="Behavioral Differences"></a>Behavioral Differences</h3><h3 id="Missing-Methods"><a href="#Missing-Methods" class="headerlink" title="Missing Methods"></a>Missing Methods</h3><h3 id="Additional-Methods"><a href="#Additional-Methods" class="headerlink" title="Additional Methods"></a>Additional Methods</h3><h2 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h2><h1 id="11-Promises-and-Asynchronous-Programming"><a href="#11-Promises-and-Asynchronous-Programming" class="headerlink" title="11.Promises and Asynchronous Programming"></a>11.Promises and Asynchronous Programming</h1><h2 id="Asynchronous-Programming-Background"><a href="#Asynchronous-Programming-Background" class="headerlink" title="Asynchronous Programming Background"></a>Asynchronous Programming Background</h2><p>JavaScript engines can only execute one piece of code at a time, so they need to keep track of code that is meant to run. Whenever a piece of code is ready to be executed, it is added to the job queue. When the JavaScript engine is finished executing code, the event loop executes the next job in the queue. The <em>event loop</em> is a process inside the JavaScript engine that monitors code execution and manages the job queue. </p>
<h3 id="The-Event-Model"><a href="#The-Event-Model" class="headerlink" title="The Event Model"></a>The Event Model</h3><p>The event handler code doesn’t execute until the event fires, and when it does execute, it has the appropriate context.</p>
<pre><code>let button = document.getElementById(“my-btn”);
button.onclick = function(event){
    console.log(“Clicked”);
};
</code></pre><p>When <code>button</code> is clicked, the function assigned to <code>onclick</code> is added to the back of the job queue and will be executed when all other jobs ahead of it are complete.</p>
<p>Events work well for simple interactions, but chaining multiple separate asynchronous calls together is more complicated because you must keep track of the event target (<code>button</code> in the previous example) for each event. Additionally, you need to ensure all appropriate event handlers are added before the first time an event occurs. For instance, if <code>button</code> were clicked before <code>onclick</code> is assigned, nothing would happen. So while events are useful for responding to user interactions and similar infrequent functionality, they aren’t very flexible for more complex needs.</p>
<h3 id="The-Callback-Pattern"><a href="#The-Callback-Pattern" class="headerlink" title="The Callback Pattern"></a>The Callback Pattern</h3><p>The callback pattern is similar to the event model because the asynchronous code doesn’t execute until a later point in time. It’s different because the function to call is passed in as an argument:</p>
<pre><code>readFile(“example.txt”, function(err,contents){
    if(err){
        throw err;
    }
    console.log(contents);
});
    console.log(“Hi!”);
</code></pre><p>This example uses the traditional Node.js <em>error-first</em> callback style. </p>
<p>The callback pattern is more flexible than events because chaining multiple calls together is easier with callback.</p>
<pre><code>readFile(“example.txt”, function(err,content){
    if(err){
        throw err;
    }
    writeFile(“example.txt”, function(err){
        if(err){
            throw err;
        }
        console.log(“File was written!”);
    });
});
</code></pre><p>Callbacks also present problems when you want to implement more complex functionality. What if you want two asynchronous operations to run in parallel and notify you when they’re both complete? What if you’d like to start two asynchronous operations at a time but only take the result of the first one to complete?</p>
<p>In these cases, you’d need to track multiple callbacks and cleanup operations, and promises greatly improve such situations.</p>
<h2 id="Promise-Basics"><a href="#Promise-Basics" class="headerlink" title="Promise Basics"></a>Promise Basics</h2><p>A promise is a placeholder for the result of an asynchronous operation. Instead of subscribing to an event or passing a callback to a function, the function can return a promise:</p>
<pre><code>//readFile promises to complete at some point in the future
let promise = readFile(“example.txt”);
</code></pre><p><code>readFile()</code> doesn’t actually start reading the file immediately; that will happen later. Instead, the function returns a promise object representing the asynchronous read operation so you can work with it in the future.</p>
<h3 id="The-Promise-Lifecycle"><a href="#The-Promise-Lifecycle" class="headerlink" title="The Promise Lifecycle"></a>The Promise Lifecycle</h3><p>Each promise goes through a short lifecycle starting in the <em>pending</em> state. A pending promise is considered <em>unsettled</em>. The promise in the last example is in the pending state as soon as the <code>readFile()</code> function returns it. Once the asynchronous operation completes, the promise is considered <em>settled</em> and enters one of two possible states:</p>
<ul>
<li><em>Fulfilled</em>: The promise’s asynchronous operation has completed sucessfully.</li>
<li><em>Rejected</em>: The promise’s asynchronous operation didn’t complete successfully due to either an error or some other cause.</li>
</ul>
<p>You can take a specific action when a promise changes state by using the <code>then()</code> method. The <code>then()</code> method is present on all promises and takes two arguments. The first argument is a function to call when the promise is fulfilled. Any additional data related to the asynchronous operation is passed to this fulfillment function. The second argument is a function to call when the promise is rejected. Similar to the fulfillment function, the rejection function is passed any additional data related to the rejection.</p>
<p>Both arguments to <code>then()</code> are optional, so you can listen for any combination of fulfillment and rejection. For example, consider this set of <code>then()</code> calls:</p>
<pre><code>let promise = readFile(“example.txt”);

promise.then(function(contents){
    //fulfillment
    console.log(contents);
},function(err){
    //rejection
    console.error(err.message);
});

promise.then(function(contents){
    //fulfillment
    console.log(contents);
});

promises.then(null,function(err){
    //rejection
    console.log(err.message);
});
</code></pre><p>Promises also have a <code>catch()</code> method that behave the same as <code>then()</code> when only a rejection handler is passed. For example, the following <code>catch()</code> and <code>then()</code> calls are functionally equivalent:</p>
<pre><code>promise.catch(function(err){
    //rejection
    console.log(err.message);
});

// is the same as:

promise.then(null, function(err){
    //rejection
    console.error(err.message);
});
</code></pre><p>The intent behind <code>then()</code> and <code>catch()</code> is for you to use them in combination to properly handle the result of asynchronous operations. This system is better than events and callbacks because it makes whether the operation succeeded or failed completely clear. (Events tend not to fire when there’s an error, and in callbacks you must always remember to check the error argument.) Just know that if you don’t attach a rejection handler to a promise, all failures will happen silently. Always attach a rejection handler, even if the handler just logs the failure.</p>
<pre><code>let promise = readFile(“example.txt”);
// original fulfillment handler
promise.then(function(contents){
    console.log(contents);
    //now add another
    promise.then(function(contents){
        console.log(contents);
    });
});
</code></pre><p>In this code, the fulfillment handler adds another fulfillment handler to the same promise. The promise is already fulfilled at this point, so the new fulfillment handler is added to the job queue and called when ready. Rejection handlers work the same way.</p>
<blockquote>
<p>Each call to <code>then()</code>or<code>catch()</code> creates a new job to be executed when the promise is resolved. But these jobs end up in separate job queue that is reserved strictly for promises.</p>
</blockquote>
<h3 id="Creating-Unsettled-Promises"><a href="#Creating-Unsettled-Promises" class="headerlink" title="Creating Unsettled Promises"></a>Creating Unsettled Promises</h3><p>The <code>Promise</code> constructor accepts a single argument: a function called the <em>executor</em>, which contains the code to initialize the promise. The executor is passed two functions named <code>resolve()</code> and <code>reject()</code> as arguments.<br>Here’s an example that uses a promise in Node.js to implement the <code>readFile()</code> function:</p>
<pre><code>let fs = require(“fs”);
function readFile(filename){
    return new Promise(function(resolve,reject){
        //trigger the asynchronous operation
        fs.readFile(filename,{encoding:”utf8”}, function(err,contents){

            //check for errors
            if(err){
                reject(err);
                return;
            }
            //the read succeeded
            resolve(contents);
        });
    });
}

let promise = readFile(“example.txt”);

//listen for both fulfillment and rejection
promise.then(function(contents){
    //fulfillment
    console.log(contents);
}, function(err){
    //rejection
    console.log(err.message);
});
</code></pre><p>In this example, the native Node.js <code>fs.readFile()</code> asynchronous call is wrapped in a promise. The executor either passes the error object to the <code>reject()</code> or pass the file content to the <code>resolve()</code>.</p>
<p>When either <code>resolve()</code> or <code>reject()</code>is called inside the executor, a job is added to the job queue to resolve the promise. This is called <em>job scheduling</em>. In job scheduling, you add a new job to the job queue to say, “Don’t execute this right now, but execute it later.”</p>
<p>The promise executor execute immediately, before anything that appears after it in the source code. For instance:</p>
<pre><code>let promise = new Promise(function(resolve,reject){
    console.log(“Promise”);
    resolve();
});
console.log(“Hi!”);

//output
Promise
Hi!
</code></pre><p>Calling <code>resolve()</code> triggers an asynchronous operation. Functions passed to <code>then()</code> and <code>catch()</code> are executed asynchronously, as these are also added to the job queue.</p>
<pre><code>let promise = new Promise(function(resolve,reject){
    console.log(“Promise”);
    resolve();
});
promise.then(function(){
    console.log(“Resolved”);
});
console.log(“Hi!”);

//output
Promise
Hi!
Resolved
</code></pre><p>Fulfillment and rejection handlers are always added to the end of the job queue after the executor has completed.</p>
<h3 id="Creating-Settled-Promise"><a href="#Creating-Settled-Promise" class="headerlink" title="Creating Settled Promise"></a>Creating Settled Promise</h3><p>Th <code>Promise</code> constructor is the best way to create unsettled promises due to the dynamic nature of what the promise execute does. But if you want a promise to represent just a single known value, then it doesn’t make sense to schedule a job that simply passes a value to the <code>resolve()</code> function. Instead, there are two methods that create settled promises given a specific value.</p>
<p><strong>Using Promise.resolve()</strong><br>The <code>Promise.resolve()</code> method accepts a single argument and returns a promise in the fulfilled state. That means no job scheduling occurs, and you need to add one or more fulfillment handlers to the promise to retrieve the value.</p>
<pre><code>let promise = Promise.resolve(42);
promise.then(function(value){
    console.log(value); //42
});
</code></pre><p><strong>Using Promise.reject()</strong><br>You can also create rejected promises by using the <code>Promise.reject()</code> method. This works like <code>Promise.resolve()</code> except the created promise is in the rejected state, as follows:</p>
<pre><code>let promise = Promise.reject(42);
promise.catch(function(value){
    console.log(value); //42
});
</code></pre><p><strong>Non-Promise Thenables</strong><br>Both <code>Promise.resolve()</code> and <code>Promise.reject()</code> also accept non-promise thenables as arguments. When passed a non-promise thenable, these methods create a new promise that is called after the <code>then()</code> function.</p>
<pre><code>let thenable = {
    then: function(resolve,reject){ 
        resolve(42);
    }
};

let p1 = Promise.resolve(thenable);
p1.then(function(value){
    console.log(value); //42
});
</code></pre><h3 id="Executor-Errors"><a href="#Executor-Errors" class="headerlink" title="Executor Errors"></a>Executor Errors</h3><p>If an error is thrown inside an executor, then the promise’s rejection handler is called.</p>
<pre><code>let promise = new Promise(function(resolve,reject){
    throw new Error(“Explosion!”);
});

promise.catch(function(error){
    console.log(error.message); //“Explosion!”
});
</code></pre><p>There is an implicit <code>try-catch</code> inside every executor such that the error is caught and then passed to the rejection handler. The previous example is equivalent to:</p>
<pre><code>let promise = new Promise(function(resolve,reject){
    try{
        throw new Error(“Explosion!”);
    } catch (ex){
        reject(ex);
    }
});

promise.catch(function(error){
    console.log(error.message); //“Explosion!”
});
</code></pre><h2 id="Global-Promise-Rejection-Handling"><a href="#Global-Promise-Rejection-Handling" class="headerlink" title="Global Promise Rejection Handling"></a>Global Promise Rejection Handling</h2><p>One of the most controversial aspects of promises is the silent failure that occurs when a promise is rejected without a rejection handler. Some consider this the biggest flaw in the specification as it’s the only part of the JavaScript language that doesn’t make errors apparent.</p>
<p>Determining whether a promise rejection was handled isn’t straightforward due to the nature of promises. For instance, consider this example:</p>
<pre><code>let rejected = Promise.reject(42);
// at this point, rejected is unhandled
//some time later...
rejected.catch(function(value){
    //now rejected has been handled
    console.log(value);
});
</code></pre><p>You can call <code>then()</code> or <code>catch()</code> at any point and have them work correctly regardless of whether the promise is settled or not, making it hard to know precisely when a promise is going to be handled. </p>
<h3 id="Node-js-Rejection-Handling"><a href="#Node-js-Rejection-Handling" class="headerlink" title="Node.js Rejection Handling"></a>Node.js Rejection Handling</h3><p>In Node.js, there are two events on the <code>process</code> object related to promise rejection handling:</p>
<ul>
<li><code>unhandledRejection</code>: Emitted when a promise is rejected and no rejection handler is called within one turn of the event loop</li>
<li><code>rejectionHandled</code>: Emitted when a promise is rejected and a rejection handler is called after one turn of the event loop</li>
</ul>
<p>These events are designed to work together to help identify promises that are rejected and not handled.</p>
<pre><code>let rejected;
process.on(“unhandledREejection”,function(reason,promise){
    console.log(reason.message);    //“Explosion!”
    console.log(rejected === promise);  //true
});
rejected === Promise.reject(new Error(“Explosion!”));
</code></pre><p>This example creates a rejected promise with an error object and listens for the <code>unhandledRejection</code>event. The event handler receives the error object as the first argument and the promise as the second.</p>
<p>The <code>rejectionHandled</code> event handler has only one argument, which is the promise that was rejected.</p>
<pre><code>let rejected;
process.on(“rejectionHandled”, function(promise){
    console.log(rejected === promise);  //true
});

rejected = Promise.reject(new Error(“Explosion!”));

//wait to add the rejection handler
setTimeout(function(){
    rejected.catch(function(value){
        console.log(value.message); //“Explosion!”
    });
}, 1000);
</code></pre><p>To properly track potentially unhandled rejections, use the <code>rejectionHandled</code> and <code>unhandledRejection</code> events to keep a list of potentially unhandled rejections. Then wait some period of time to inspect the list. For example:</p>
<pre><code>let possibleUnhandledRejections = new Map();
//
process.on(“unhandledRejection”, function(reason,promise){
    possiblyUnhandledRejections.set(promise,reason);
});

process.on(“rejectionHandled”, function(promise){
    possiblyUnhandledRejections.delete(promise);
});

setInterval(function(){
    possiblyUnhandledRejections.forEach(function(reason, promise){
        console.log(reason.message ? reason.message : reason);
        //do something
        handleRejection(promise, reason);
    });
    possiblyUnhandledRejections.clear();
}, 60000);
</code></pre><p>Each time <code>unhandledRejection</code> is emitted, the promise and its rejection reason are added to the map. Each time <code>rejectionHandled</code> is emitted, the handled promise is removed from the map. As a result, <code>possiblyUnhandledRejections</code> grows and shrinks as events are called. The <code>setInterval()</code> call periodically checks the list of possible unhandled rejections and outputs the information to the console.</p>
<h3 id="Browser-Rejection-Handling"><a href="#Browser-Rejection-Handling" class="headerlink" title="Browser Rejection Handling"></a>Browser Rejection Handling</h3><p>Browsers also emit two events to help identify unhandled rejections. These events are emitted by the <code>window</code> object and are effectively the same as their Node.js equivalents.<br>While the Node.js implementation passes individual parameters to the event handler, the event handler for these browser events receives an event object with the following properties:</p>
<ul>
<li><code>type</code>: The name of the event (<code>”unhandledrejection”</code> or <code>”rejectionhandled”</code>).</li>
<li><code>promise</code>: The promise object that was rejected.</li>
<li><code>reason</code>: The rejection value from the promise</li>
</ul>
<p>The other difference in the browser implement is that the rejection value (<code>reason</code>) is available for both events.</p>
<pre><code>let rejected;

window.onunhandledrejection = function(event){
    console.log(event.type);    //“unhandledrejection”
    console.log(event.reason.message);  //“Explosion!”
console.log(rejected === event.promise);    //true
};

window.onrejectionhandled = function(event){
    console.log(event.type);    //“rejectionhandled”
    console.log(event.reason.message);  //“Explosion!”
    console.log(rejected === event.promise);    //true
};

rejected = Promise.reject(new Error(“Explosion!”));
</code></pre><h2 id="Chaining-Promises"><a href="#Chaining-Promises" class="headerlink" title="Chaining Promises"></a>Chaining Promises</h2><p>Each call to <code>then()</code> or <code>catch()</code> actually creates and returns another promise. This second promise is resolved only once the first has been fulfilled or rejected. Consider this:</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});
p1.then(function(value){
    console.log(value);
}).then(function(){
    console.log(“Finished”);
});

//outputs
42
Finished
</code></pre><h3 id="Catching-Errors"><a href="#Catching-Errors" class="headerlink" title="Catching Errors"></a>Catching Errors</h3><p>Promise chaining allows you to catch errors that may occur in a fulfillment or rejection handler from a previous promise.</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});
p1.then(function(value){
    throw new Error(“Boom!”);
}).catch(function(error){
    console.log(error.message); //“Boom!”
});
</code></pre><p>~The chained promise calls are aware of errors in other promises in the chain.~</p>
<blockquote>
<p>Always have a rejection handler at the end of a promise chain to ensure that you can properly handle any errors that may occur.</p>
</blockquote>
<h3 id="Returning-Values-in-Promise-Chains"><a href="#Returning-Values-in-Promise-Chains" class="headerlink" title="Returning Values in Promise Chains"></a>Returning Values in Promise Chains</h3><p>You’ve already seen that a value passed to the <code>resolve()</code> handler inside an executor is passed to the fulfillment handler for that promise. You can continue passing data along a chain by specifying a return value from the fulfillment handler.</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});

p1.then(function(value){
    console.log(value); //“42”
    return value + 1;
}).then(function(value){
    console.log(value); //“43”
});
</code></pre><p>You could do the same thing with the rejection handler. When a rejection handler is called, it may return a value. If it does, that value is used to fulfill the next promise in the chain.</p>
<h3 id="Returning-Promises-in-Promise-Chains"><a href="#Returning-Promises-in-Promise-Chains" class="headerlink" title="Returning Promises in Promise Chains"></a>Returning Promises in Promise Chains</h3><pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});

let p2 = new Promise(function(solve,reject){
    resolve(43);
});
p1.then(function(value){
    //first fulfillment handler
    console.log(value); //42
    return p2;
}).then(function(value){
    //second fulfillment handler
    console.log(value); //43
});
</code></pre><p>The important thing to recognize about this pattern is that the second fulfillment handler is not added to <code>p2</code>, but rather to a third promise. This is a subtle but important distinction, as the second fulfillment handler will not be called if <code>p2</code> is rejected.</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resole(42);
});

let p2 = new Promise(function(resolve,reject){
    reject(43);
});

p1.then(function(value){
    //first fulfillment handler
    console.log(value); //42
    return p2;
}).then(function(value){
    //second fulfillment handler
    console.log(value); //never called
});
</code></pre><p>The second fulfillment handler is never called because <code>p2</code> is rejected. You could, however, attach a rejection handler instead:</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});

let p2 = new Promise(function(resolve,reject){
    reject(43);
});

p1.then(function(value){
    //first fulfillment handler
    console.log(value); //42
    return p2;
}).catch(function(value){
    //rejection handler
    console.log(value); //43
});
</code></pre><p>Returning thenables from fulfillment or rejection handlers doesn’t change when the promise executors are executed. The first defined promise will run its executor first, then the second promise executor will run, and so on. Returning thenables simply allows you to define additional responses to the promise results. You defer the execution of fulfillment handlers by creating a new promise within a fulfillment handler.</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});

p1.then(function(value){
    console.log(value); //42

    //create a new promise
    let p2 = new Promise(function(resolve,reject){
        resolve(43);
    });
    return p2;
}).then(function(value){
    console.log(value); //43
});
</code></pre><p>A new promise is created within the fulfillment handler for <code>p1</code>. That means the second fulfillment handler won’t execute until after <code>p2</code> is fulfilled. This pattern is useful when you want to wait until a previous promise has been settled before triggering another promise.</p>
<h2 id="Responding-to-Multiple-Promises"><a href="#Responding-to-Multiple-Promises" class="headerlink" title="Responding to Multiple Promises"></a>Responding to Multiple Promises</h2><p>Sometimes, you’ll want to monitor the progress of multiple promises in order to determine the next action. ECMAScript 6 provides two methods that monitor multiple promises: <code>Promise.all()</code> and <code>Promise.race()</code>.</p>
<h3 id="The-Promise-all-Method"><a href="#The-Promise-all-Method" class="headerlink" title="The Promise.all() Method"></a>The Promise.all() Method</h3><p>The <code>Promise.all()</code> method accepts a single argument, which is an iterable(such as an array) of promises to monitor, and returns a promise that is resolved only when every promise in the iterable is resolved. The returned promise is fulfilled when every promise in the iterable is fulfilled, as in this example:</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});

let p2 = new Promise(function(resolve,reject){
    resolve(43);
});

let p3 = new Promise(function(resolve,reject){
    resolve(44);
});

let p4 = Promise.all([p1,p2,p3]);

p4.then(function(value){
    console.log(Array.isArray(value));  //true
    console.log(value[0]);  //42
console.log(value[1]);  //43
console.log(value[2]);  //44
});
</code></pre><p>If any promise passed to <code>Promise.all()</code> is rejected, the returned promise is immediately rejected without waiting for the other promises to complete.</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    resolve(42);
});

let p2 = new Promise(function(resolve,reject){
    reject(43);
});

let p3 = new Promise(function(resolve,reject){
    reject(44);
});

let p4 = Promise.all([p1,p2,p3]);

p4.then(function(value){
    console.log(Array.isArray(value));  //false
    console.log(value); //43
</code></pre><h3 id="The-Promise-race-Method"><a href="#The-Promise-race-Method" class="headerlink" title="The Promise.race() Method"></a>The Promise.race() Method</h3><p>Instead of waiting for all promises to be fulfilled like the <code>Promise.all()</code> method, the <code>Promise.race()</code> method returns an appropriate promise as soon as any promise in the array is fulfilled.</p>
<pre><code>let p1 = Promise.resolve(42);

let p2 = new Promise(function(resolve,reject){
    resolve(43);
});

let p3 = new Promise(function(resolve,reject){
    resolve(44);
});

let p4 = Promise.race([p1,p2,p3]);

p4.then(function(value){
    console.log(value); //42
});
</code></pre><p><code>p1</code> is created as a fulfilled promise while the other schedule jobs. The promise passed to <code>Promise.race()</code> are truly in a race to see which is settled first. If the first promise to settle is fulfilled, then the returned promise is fulfilled; if the first promise to settle is rejected, then the returned promise is rejected.</p>
<pre><code>let p1 = new Promise(function(resolve,reject){
    setTimeout(function(){
        resolve(42);
    }, 100);
});

let p2 = new Promise(function(resolve,reject){
    reject(43);
});

let p3 = new Promise(function(resolve,reject){
    setTimeout(function(){
        resolve(44);
    }, 50);
});

let p4 = Promise.race([p1,p2,p3]);

p4.catch(function(value){
    console.log(value); //43
});
</code></pre><h2 id="Inheriting-from-Promises"><a href="#Inheriting-from-Promises" class="headerlink" title="Inheriting from Promises"></a>Inheriting from Promises</h2><p>Just like other built-in types, you can use a promise as the base for a derived class. This allows you to define your own variation of promises to extend what built-in promises can do.</p>
<pre><code>class MyPromise extends Promise{
    //use default constructor
    success(resolve,reject){
    return this.then(resolve,reject);
    }

    failure(reject){
        return this.catch(reject);
    }
}

let promise = new MyPromise(function(resolve,reject){
    resolve(42);
});

promise.success(function(value){
    console.log(value); //42
}).failure(function(value){
    console.log(value);
});
</code></pre><p>Each added method uses <code>this</code> to call the method it mimics.<br>Both <code>MyPromise.resolve()</code> and <code>MyPromise.reject()</code> will return an instance of <code>MyPromise</code> regardless of the value passed because those methods use the <code>Symbol.species</code> property to determine the type of promise to return.</p>
<h2 id="Asynchronous-Task-Running-1"><a href="#Asynchronous-Task-Running-1" class="headerlink" title="Asynchronous Task Running"></a>Asynchronous Task Running</h2><p>Use generators for asynchronous task running:</p>
<pre><code>let fs = require(&quot;fs&quot;);

function run(taskDef) {    
    // create the iterator, make available elsewhere    
    let task = taskDef();    

    // start the task
    let result = task.next();    

    // recursive function to keep calling next()    
    function step() {        
        // if there&#39;s more to do        
        if (!result.done) {            
            if (typeof result.value === &quot;function&quot;) {                
                result.value(function(err, data) {                    
                    if (err) {                        
                        result = task.throw(err);                        
                        return;                    
                    }                    
                    result = task.next(data);                    
                    step();                
                });            
            } else {                
                result = task.next(result.value);                
                step();            
            }        
        }
    }    

    // start the process    
    step();
}

// Define a function to use with the task runner
function readFile(filename) {    
    return function(callback) {        
        fs.readFile(filename, callback);    
    };
}

// Run a task
run(function*() {    
    let contents = yield readFile(&quot;config.json&quot;);    
    doSomethingWith(contents);    
    console.log(&quot;Done&quot;);
});
</code></pre><p>With promises, you can greatly simplify and generalize this process by ensuring that each asynchronous operation returns a promise. </p>
<pre><code>let fs = require(“fs”);

function run(taskDef){
    //create the iterator
    let task = taskDef();
    //start the task
    let result = task.next();
    //recursive function to iterate through
    (function step(){
        //if there’s more to do
        if(!result.done){
            //resolve to a promise to make it easy
            let promise = Promise.resolve(result.value);
            promise.then(function(value){
                result = task.next(value);
                step();
            }).catch(function(error){
                result = task.throw(error);
                step();
            });
        }
    }());
}

//Define a function to use with the task runner
function readFile(filename){
    return new Promise(function(resolve,reject){
        fs.readFile(filename,function(err,contents){
            if(err){
                reject(err);
            } else {
                resolve(contents);
            }
        });
    });
}

//Run a task
run(function*(){
    let contents = yield readFile(“config.json”);
    doSomethingWith(contents);
    console.log(“Done”);
});
</code></pre><p>A generic <code>run()</code> function executes a generator to create an iterator. It calls <code>task.next()</code> to start and recursively calls <code>step()</code> until the iterator is complete.</p>
<p>Inside the <code>step()</code> function, if there’s more work to do, then <code>result.done</code> is <code>false</code>. At that point, <code>result.value</code> should be a promise, but <code>Promise.resolve()</code> is called just in case the function in question didn’t return a promise. (<code>Promise.resolve()</code> just passes through any promise passed in and wraps any non-promise in a promise.) Then, a fulfillment handler is added that retrieves the promise value and passes the value back to the iterator. After that, <code>result</code> is assigned to the next yield result before the <code>step()</code> function calls itself.</p>
<p>This <code>run()</code> function can run any generator that uses <code>yield</code> to achieve asynchronous code without exposing promises to the developer.</p>
<h2 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h2><p>Promises schedule jobs to be added to the JavaScript engine’s job queue for execution later, while a second job queue tracks promise fulfillment and rejection handlers to ensure proper execution.</p>
<p>A promise starts in a pending state and becomes fulfilled on a successful execution or rejected on a failure. In either case, handlers can be added to indicate when a promise is settled. The <code>then()</code> method allows you to assign a fulfillment and rejection handler and the <code>catch()</code> method allows you to assign only a rejection handler.</p>
<p>You can chain promises together in a variety of ways and pass information between them. Each call to <code>then()</code> creates and returns a new promise that is resolved when the previous one is resolved. Such chains can be used to trigger responses to a series of asynchronous events. You can also use <code>Promise.race()</code> and <code>Promise.all()</code> to monitor the progress of multiple promises and respond accordingly.</p>
<p>Asynchronous task running is easier when you combine generators and promises, as promises give a common interface that asynchronous operations can return. You can then use generators and the <code>yield</code> operator to wait for asynchronous responses and respond appropriately. </p>
<h1 id="12-Proxies-and-the-Reflection-API"><a href="#12-Proxies-and-the-Reflection-API" class="headerlink" title="12.Proxies and the Reflection API"></a>12.Proxies and the Reflection API</h1><p>ECMAScript 6 gives further access to JavaScript engine capabilities previously available only to built-in objects. The language exposes the inner workings of objects through <em>proxies</em>, which are wrappers that can intercept and alter low-level operations of the JavaScript engine.</p>
<h2 id="The-Array-Problem"><a href="#The-Array-Problem" class="headerlink" title="The Array Problem"></a>The Array Problem</h2><p>The JavaScript array object behaves in ways that developers couldn’t mimic in their own objects before ECMAScript 6, but proxies change that.</p>
<h3 id="What-are-Proxies-and-Reflection"><a href="#What-are-Proxies-and-Reflection" class="headerlink" title="What are Proxies and Reflection?"></a>What are Proxies and Reflection?</h3><p>You can create a proxy to use in place of another object(called the <em>target</em>) by calling <code>new Proxy()</code>. The proxy <em>virtualizes</em> the target so that the proxy and the target appear to be the same object to functionality using the proxy.</p>
<p>Proxies allow you to intercept low-level object operations on the target that are otherwise internal to the JavaScript engine. These low-level operations are intercepted using a <em>trap</em>, which is a function that responds to a specific operation. </p>
<p>The reflection API, represented by the <code>Reflect</code> object, is a collection of methods that provide the default behavior for the same low-level operations that proxies can override. There is a <code>Reflect</code> method for every proxy trap. Those methods have the same name and are passed the same arguments as their respective proxy traps. </p>
<h1 id="13-Encapsulating-Code-With-Modules"><a href="#13-Encapsulating-Code-With-Modules" class="headerlink" title="13.Encapsulating Code With Modules"></a>13.Encapsulating Code With Modules</h1><h2 id="What-are-Modules"><a href="#What-are-Modules" class="headerlink" title="What are Modules?"></a>What are Modules?</h2><p><em>Modules</em> are JavaScript files that are loaded in a different mode(as opposed to <em>scripts</em>, which are loaded in the original way JavaScript worked). Modules have very different semantics than scripts:</p>
<ol>
<li>Module code automatically runs in strict mode</li>
<li>Variables created in the top level of a module aren’t automatically added to the shared global scope. They exist only within the top-level scope of the module.</li>
<li>The value of <code>this</code> in the top level of a module is <code>undefined</code>.</li>
<li>Modules don’t allow HTML-style comments within code.</li>
<li>Modules must export anything that should be available to code outside of the module.</li>
<li>Modules may import bindings from other modules.</li>
</ol>
<p>The real power of modules is the ability to export and import only bindings you need, rather than everything in a file.</p>
<h2 id="Basic-Exporting"><a href="#Basic-Exporting" class="headerlink" title="Basic Exporting"></a>Basic Exporting</h2><p>You can use the <code>export</code> keyword to expose parts of published code to other modules. </p>
<pre><code>//export data
export var color = “red”;
export let name = “Nicholas”;
export const magicNumber = 7;

//export function
export function sum(num1,num2){
    return num1 + num2;
}

//export class
export class Rectangle{
    constructor(length,width){
        ...
    }
}

//this function is private to the module
function substract(num1,num2){
    return num1 - num2;
}

//define a function...
function multiply(num1,num2){
    return num1 * num2;
}

//...and then export it later
export {multiply};
</code></pre><p>Consider the <code>multiply()</code> function, which isn’t exported when it’s defined. That works because you need not always export a declaration: you can also export references. </p>
<h2 id="Basic-Importing"><a href="#Basic-Importing" class="headerlink" title="Basic Importing"></a>Basic Importing</h2><p>The two parts of an <code>import</code> statement are the identifiers you’re importing and the module from which those identifiers should be imported.<br><code>import{identifier1, identifier2} from “./example.js”;</code></p>
<p>When importing a binding from a module, the binding acts as if it were defined using <code>const</code>. That means you can’t define another variable with the same name(including importing another binding of the same name), use the identifier before the <code>import</code> statement, or change its value.</p>
<h3 id="Importing-All-of-a-Module"><a href="#Importing-All-of-a-Module" class="headerlink" title="Importing All of a Module"></a>Importing All of a Module</h3><pre><code>//import everything
import * as example from “./example.js”;
console.log(example.sum(1,example.magicNumber));        //8
console.log(example.multiply(1,2)); //2
</code></pre><p>This import format is called a <em>namespace</em> import because the <code>example</code> object doesn’t exist inside of the <code>example.js</code> file and is instead created to be used as a namespace object for all of the exported members of <code>example.js</code>.</p>
<h3 id="A-Subtle-Quirk-of-Imported-Bindings"><a href="#A-Subtle-Quirk-of-Imported-Bindings" class="headerlink" title="A Subtle Quirk of Imported Bindings"></a>A Subtle Quirk of Imported Bindings</h3><p>ECMAScript 6’s <code>import</code> statements create read-only bindings to variables, functions, and classes rather than simply referencing the original bindings like normal variables. Even though the module that imports the bindings can’t change its value, the module that exports that identifier can. For example, suppose you want to use this module:</p>
<pre><code>export var name = “Nicholas”;
export function setName(newName){
    name = newName;
}
</code></pre><p>When you import those two bindings, the <code>setName()</code> function can change the value of <code>name</code>:</p>
<pre><code>import {name,setName} from “./example.js”;

console.log(name);  //“Nicholas”
setName(“Greg”);
console.log(name);  //“Greg”
name = “Nicholas”;  //error
</code></pre><h2 id="Renaming-Exports-and-Imports"><a href="#Renaming-Exports-and-Imports" class="headerlink" title="Renaming Exports and Imports"></a>Renaming Exports and Imports</h2><pre><code>function sum(num1,num2){
    return num1 + num2;
}

export {sum as add};
</code></pre><p><code>import {add} from “./example.js”;</code></p>
<h2 id="Default-Values-in-Modules"><a href="#Default-Values-in-Modules" class="headerlink" title="Default Values in Modules"></a>Default Values in Modules</h2><p>The <em>default value</em> for a module is a single variable, function, or class as specified by the <code>default</code> keyword, and you can only set one default export per module. Using the <code>default</code> keyword with multiple exports is a syntax error.</p>
<h3 id="Exporting-Default-Values"><a href="#Exporting-Default-Values" class="headerlink" title="Exporting Default Values"></a>Exporting Default Values</h3><pre><code>export default function(num1,num2){
    return num1 + num2;
}
</code></pre><p>This module exports a function as its default value.</p>
<p>You can also specify an identifier as the default export by placing it after <code>export default</code>:</p>
<pre><code>function sum(num1,num2){
    return num1 + num2;
}

export default sum;
</code></pre><p>Here, the <code>sum()</code> function is defined first and later exported as the default value of the module. You may want to choose this approach if the default value needs to be calculated.</p>
<p>A third way to specify an identifier as the default export is by using the renaming syntax as follows:</p>
<pre><code>function sum(num1, num2){
    return num1 + num2;
}

export { sum as default };
</code></pre><h3 id="Importing-Default-Values"><a href="#Importing-Default-Values" class="headerlink" title="Importing Default Values"></a>Importing Default Values</h3><pre><code>// import the default
import sum from “./example.js”;
console.log(sum(1,2));  //3
</code></pre><p>For modules that export both a default and one or more non-default bindings, you can import all exported bindings with one statement. For instance, suppose you have this module:</p>
<pre><code>export let color = “red”;
export default function(num1,num2){
    return num1 + num2;
}
</code></pre><p>You can import both <code>color</code> and the default function using the following <code>import</code> statement:</p>
<pre><code>import sum, {color} from “./example.js”;
console.log(sum(1,2));  //3
console.log(color); //“red”
</code></pre><p>As with exporting defaults, you can import defaults with the renaming syntax:</p>
<pre><code>// equivalent to previous example
import {default as sum, color} from “example”;
</code></pre><h3 id="Re-exporting-a-Binding"><a href="#Re-exporting-a-Binding" class="headerlink" title="Re-exporting a Binding"></a>Re-exporting a Binding</h3><pre><code>import { sum } from &quot;./example.js&quot;;
export { sum }
</code></pre><h3 id="Importing-Without-Bindings"><a href="#Importing-Without-Bindings" class="headerlink" title="Importing Without Bindings"></a>Importing Without Bindings</h3><p>For instance, if you want to add a <code>pushAll()</code> method to all arrays, you might define a module like this:</p>
<pre><code>//module code without exports or imports
Array.prototype.pushAll = function(items){
    //items must be an array
    if(!Array.isArray(items)){
        throw new TypeError(“...”);
    }

    // use built-in push() and spread operator
    return this.push(...items);
};
</code></pre><p>Since it doesn’t export anything, you can use a simplified import to execute the module code without importing any bindings:</p>
<pre><code>import “./example.js”;

let colors = [“red”,”green”,”blue”];
let items = [];

items.pushAll(colors);
</code></pre><blockquote>
<p>Imports without bindings are most likely to be used to create polyfills and shims.</p>
</blockquote>
<h2 id="Loading-Modules"><a href="#Loading-Modules" class="headerlink" title="Loading Modules"></a>Loading Modules</h2><h3 id="Using-Modules-in-Web-Browsers"><a href="#Using-Modules-in-Web-Browsers" class="headerlink" title="Using Modules in Web Browsers"></a>Using Modules in Web Browsers</h3><ul>
<li>Using Modules with <code>script</code><br><code>`</code><!-- load a module JavaScript file -->
<script type="module" src="module.js"></script>

</li>
</ul>
<!-- include a module inline -->
<script type="module">

<p>import { sum } from “./example.js”;</p>
<p>let result = sum(1, 2);</p>
<p></script><br><code>`</code><p></p>
<ul>
<li>Module Loading Sequence in Web Browsers</li>
<li>Asynchronous Module Loading in Web Browsers</li>
<li>Loading Modules as Workers</li>
</ul>
<h3 id="Browser-Module-Specifier-Resolution"><a href="#Browser-Module-Specifier-Resolution" class="headerlink" title="Browser Module Specifier Resolution"></a>Browser Module Specifier Resolution</h3><h2 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h2><p>Modules behave differently than scripts, as they don’t modify the global scope with their top-level variables, functions, and classes, and <code>this</code> is <code>undefined</code>.</p>
<p>Module files loaded with <code>&lt;script type=“module”&gt;</code> are loaded as if the <code>defer</code> attribute is applied to them. Modules are also executed in the order in which they appear in the containing document once the document is fully parsed.</p>
<p></p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://xhdnoah.github.io/2018/11/03/ES6/%20电子月亮%20《Understanding ECMAScript6》Notes" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2018/11/05/js-callback/" title="JavaScript 同步、异步、回调、闭包"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: JavaScript 同步、异步、回调、闭包</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2018/10/19/《你不知道的 JavaScript》/" title="《你不知道的 JavaScript》笔记">下一篇: 《你不知道的 JavaScript》笔记&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="https://cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script><script src="https://cdn.bootcss.com/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="https://cdn.bootcss.com/jquery-migrate/1.2.1/jquery-migrate.min.js"></script><script src="https://cdn.bootcss.com/jquery.appear/0.3.3/jquery.appear.js"></script><script src="/js/typography.js"></script></body></html>