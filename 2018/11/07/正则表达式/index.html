<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Noah Xu"><title>正则表达式学习笔记 · Electronic Moon</title><meta name="description" content="描述一张字符串匹配的模式，可以用来检查一个穿是否含有某种子串、将匹配的子串替换或从某个串里取出符合某个条件的子串等
元字符


.
匹配除换行符以外的任意字符




\w
匹配字母或数字或下划线或汉字


\s
匹配任意空白符


\d
匹配数字


\b
匹配单词的开始和结束


^
匹配字符串"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">电子月亮</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://github.com/xhdnoah" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="https://twitter.com/xhdnoah" target="_blank" rel="noopener noreferrer"><i class="fa fa-twitter">&nbsp;</i></a><a href="http://xhdnoah.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>正则表达式学习笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2018-11-07</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/正则表达式/" title="正则表达式" class="a-tag">正则表达式</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>描述一张字符串匹配的模式，可以用来检查一个穿是否含有某种子串、将匹配的子串替换或从某个串里取出符合某个条件的子串等</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th style="text-align:center">.</th>
<th style="text-align:center">匹配除换行符以外的任意字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任意空白符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词的开始和结束</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串结束</td>
</tr>
</tbody>
</table>
<p>匹配abc开头字符串<br><code>\babc</code>或<code>^abc</code><br>匹配8位数字的QQ号<br><code>^\d\d\d\d\d\d\d\d$</code><br>匹配1开头11位数字的手机号<br><code>^1\d\d\d\d\d\d\d\d\d\d$</code></p>
<h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><p>处理正则表达式中的重复问题</p>
<table>
<thead>
<tr>
<th style="text-align:center">*</th>
<th style="text-align:center">重复零次或更多次</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">重复一次或更多次</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">重复零次或一次</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">重复n次</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">重复n次或更多次</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">重复n到m次</td>
</tr>
</tbody>
</table>
<p>匹配8位数字QQ号<br><code>^\d{8}$</code><br>匹配1开头11位数字的手机号码<br><code>^1\d{10}$</code><br>匹配银行卡号是14～18位的数字<br><code>^\d{14,18}$</code><br>匹配以a开头，0个或多个b结尾的字符串<br><code>^ab*$</code></p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>重复限定符作用在与它左边最近的字符，如果想要ab同时被限定，用小括号来分组(ab)</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>如果匹配的字符串本身包括小括号，正则提供转义的方式<br>匹配以<code>(ab)</code>开头：<code>^(\(ab\))*</code></p>
<h2 id="条件或"><a href="#条件或" class="headerlink" title="条件或"></a>条件或</h2><p>联通有130|131|132|155|156|185|186|145|176等号段，匹配一个联通的号码：<br><code>^(130|131|132|155|156|185|186|145|176)\d{8}$</code></p>
<h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>正则提供一个元字符中括号[]表示区间条件</p>
<blockquote>
<p>限定0到9可以写成[0-9]<br>限定A-Z写成[A-Z]<br>限定某一些数字[165]<br>匹配联通号码可以改成<br><code>^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$</code></p>
</blockquote>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><blockquote>
<p>断言：正则可以指明在指定的内容前或后会出现满足指定规则的内容，正则只有当断言为真时才会继续匹配。<br>零宽：正则中，断言只是匹配位置，不占字符，匹配结果不会返回断言本身  </p>
</blockquote>
<p>假如要抓取网页文章的阅读量，看到这样的结构：<br><code>”&lt;span class=“read-count”&gt;阅读数：641&lt;/span&gt;</code><br>其中只有‘641’这个变量，获得里边的‘641’有很多办法，如果使用正则应该怎么匹配？</p>
<h3 id="正向先行断言（正前瞻）"><a href="#正向先行断言（正前瞻）" class="headerlink" title="正向先行断言（正前瞻）"></a>正向先行断言（正前瞻）</h3><p>语法：(?=pattern) 匹配 pattern 表达式前面的内容，不返回本身。<br>回到栗子，要取得阅读量，意味着要能匹配到’’前面的数字内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String reg=“\\d+(?=&lt;/span&gt;)”;</span><br><span class="line">String test = “&lt;span class=\”read-count\”&gt;阅读数：641&lt;/span&gt;”;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Matched mc = [atern.matcher(test);</span><br><span class="line">while(mc.find())&#123;</span><br><span class="line">    System.out.println(mc.group());</span><br><span class="line">&#125;</span><br><span class="line">//匹配结果：641</span><br></pre></td></tr></table></figure>
<h3 id="正向后行断言（正后顾）"><a href="#正向后行断言（正后顾）" class="headerlink" title="正向后行断言（正后顾）"></a>正向后行断言（正后顾）</h3><p>语法：(?&lt;=pattern) 匹配 pattern 表达式后面的内容，不返回本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String reg=“(?&lt;=&lt;span class=\”read-count\”&gt;阅读数：)\\d+”;</span><br><span class="line">String test=“&lt;span class=\”read-count\”&gt;阅读数：641&lt;span&gt;”;</span><br><span class="line">Pattern pattern = Pattern.compile(reg);</span><br><span class="line">Match mc = Pattern.matcher(test);</span><br><span class="line">while(mc.find())&#123;</span><br><span class="line">    System.out.println(mc.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负向先行断言（负前瞻）"><a href="#负向先行断言（负前瞻）" class="headerlink" title="负向先行断言（负前瞻）"></a>负向先行断言（负前瞻）</h3><p>语法：(?!pattern) 匹配非 pattern 表达式前面的内容，不返回本身<br>栗子：“我爱祖国，我是祖国的花朵”<br>匹配不是’的花朵‘前面的祖国<br><code>祖国(?!的花朵)</code></p>
<h3 id="负向后行断言（负后顾）"><a href="#负向后行断言（负后顾）" class="headerlink" title="负向后行断言（负后顾）"></a>负向后行断言（负后顾）</h3><p>语法：(?&lt;!pattern) 匹配非 pattern 表达式后面的内容，不返回本身</p>
<h2 id="捕获和非捕获"><a href="#捕获和非捕获" class="headerlink" title="捕获和非捕获"></a>捕获和非捕获</h2><blockquote>
<p>捕获组：匹配表达式的内容，把匹配结果保存到内存中的数字编号或显示命名的组里，以深度优先进行编号，之后可通过序号或名称来使用这些匹配结果  </p>
</blockquote>
<p>根据命名方式的不同，又可以分为两种组：</p>
<h3 id="数字编号捕获组"><a href="#数字编号捕获组" class="headerlink" title="数字编号捕获组"></a>数字编号捕获组</h3><p>语法：(exp)<br>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。</p>
<p>比如固定电话：020-85653333<br>正则表达式为：<code>(0\d{2})-(\d{8})</code></p>
<p>按左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">编号</th>
<th style="text-align:center">分组</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">(0\d{2})-(\d{8})</td>
<td style="text-align:center">020-85653333</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">(0\d{2})</td>
<td style="text-align:center">020</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">(\d{8})</td>
<td style="text-align:center">85653333</td>
</tr>
</tbody>
</table>
<h3 id="命名编号捕获组"><a href="#命名编号捕获组" class="headerlink" title="命名编号捕获组"></a>命名编号捕获组</h3><p>语法：<code>(?&lt;name&gt;exp)</code><br>解释：分组的命名由表达式中的 name 指定</p>
<p>固定电话也可以这样写：<code>(?&lt;quhao&gt;\0\d{2})-(?&lt;haoma&gt;\d{8})</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">编号</th>
<th style="text-align:center">分组</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">(0\d{2})-(\d{8})</td>
<td style="text-align:center">020-85653333</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">quhao</td>
<td style="text-align:center">(0\d{2})</td>
<td style="text-align:center">020</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">haoma</td>
<td style="text-align:center">(\d{8})</td>
<td style="text-align:center">85653333</td>
</tr>
</tbody>
</table>
<h3 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h3><p>语法：(?:exp)</p>
<p>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，你可以根据需要保存分组。</p>
<p>如果程序不需要用到第一个分组：</p>
<p><code>(?:\0\d{2})-(\d{8})</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">编号</th>
<th style="text-align:center">分组</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">(0\d{2})-(\d{8})</td>
<td style="text-align:center">020-85653333</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">(\d{8})</td>
<td style="text-align:center">85653333</td>
</tr>
</tbody>
</table>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>捕获会返回一个捕获组，这个分组保存在内存，不仅可以在正则表达式外部通过程序进行引用，也可以在内部进行引用，这种引用方式就是反向引用。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<ul>
<li>数字编号组反向引用：\k 或 \number</li>
<li>命名编号组反向引用：\k 或 \’name’</li>
</ul>
<p>捕获组通常和反向引用一起使用，捕获组是匹配子表达式的<strong>内容</strong>按序号或命名保存起来以便<strong>使用</strong>。主要作用是查找一些重复的内容或者做替换指定字符。</p>
<p>比如要查找一串字母中成对的字母：</p>
<ol>
<li>匹配到第一个字母</li>
<li>匹配下一个字母，检查是否和上一个字母一样</li>
<li>如果一样，则匹配成功，否则失败</li>
</ol>
<p>步骤2中匹配下一个字母需要记住上一个字母，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。首先匹配一个字母：<code>\w</code>，需要做成分组才能捕获=&gt;<code>(\w)</code>。我们用这个捕获组作为条件<code>(\w)\1</code>，\1表示是根据捕获分组顺序命名。因此要引用第一个捕获组，根据反向引用的数字命名规则，需要<code>\k&lt;1&gt;</code>或<code>\1</code> =&gt; <code>(\\w)\\1</code></p>
<h2 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h2><blockquote>
<p>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这种匹配方式叫做贪婪匹配。</p>
<p>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p>
</blockquote>
<p>重复限定词就是贪婪量词，<code>\d{3,6}</code>用来匹配3到6位数字，这种情况下就是一种贪婪模式的匹配，如果字符串有6个数字可以匹配，那就是全部匹配到。</p>
<p>多个贪婪量词组合，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p>
<h3 id="懒惰（非贪婪）"><a href="#懒惰（非贪婪）" class="headerlink" title="懒惰（非贪婪）"></a>懒惰（非贪婪）</h3><blockquote>
<p>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这种匹配方式叫懒惰匹配</p>
<p>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依次循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</p>
</blockquote>
<p>懒惰量词再贪婪量词后+“ ？”</p>
<table>
<thead>
<tr>
<th style="text-align:center">*？</th>
<th style="text-align:center">重复任意次，但尽可能少重复</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+？</td>
<td style="text-align:center">重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td style="text-align:center">?？</td>
<td style="text-align:center">重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td style="text-align:center">{n,m}?</td>
<td style="text-align:center">重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td style="text-align:center">{n,}？</td>
<td style="text-align:center">重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">匹配任意非数字的字符</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">[^x]</td>
<td style="text-align:center">匹配除了x以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[^aeiou]</td>
<td style="text-align:center">匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://xhdnoah.github.io/2018/11/07/正则表达式/%20Electronic Moon%20正则表达式学习笔记" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2018/12/26/eslint-format/" title="ESlint 自动格式化正确姿势"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: ESlint 自动格式化正确姿势</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2018/11/03/ES6/" title="《Understanding ECMAScript6》学习笔记">Next post: 《Understanding ECMAScript6》学习笔记&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><div id="lv-container" data-id="city" data-uid="livere_data_uid"><script type="text/javascript">(function (d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') {
        return;
    }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script><noscript> Please activate JavaScript for write a comment in LiveRe</noscript></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>