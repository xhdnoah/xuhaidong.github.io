<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Noah Xu"><title>《JavaScript 高级程序设计》笔记 · 电子月亮</title><meta name="description" content="基本概念数据类型Undefined 类型Null 类型null 值表示一个空对象指针
Boolean 类型Number类型NaN是一个特殊的数值，表示本来要返回数值的操作数未返回数值的情况。NaN与任何值不相等数值转换：

Number ()
var num1 = Number(“Hello wor"><meta name="keywords" content><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">Electronic Moon</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/resume/resume.html">简历</a></li><li class="soc"><a href="https://github.com/xhdnoah" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="http://xhdnoah.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>《JavaScript 高级程序设计》笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2018-10-19</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/JavaScript/" title="JavaScript" class="a-tag">JavaScript</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>null 值表示一个空对象指针</p>
<h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>NaN是一个特殊的数值，表示本来要返回数值的操作数未返回数值的情况。NaN与任何值不相等<br>数值转换：</p>
<ul>
<li>Number ()<blockquote>
<p>var num1 = Number(“Hello world!”);      //NaN<br>var num2 = Number(“”);                  //0<br>var num3 = Number(“000011”);          //11<br>var num4 = Number(true);              //1 </p>
</blockquote>
</li>
<li>parseInt()<blockquote>
<p>var num1 = parseInt(“1234blue”);    // 1234<br>var num2 = parseInt(“”);            // NaN<br>var num3 = parseInt(“0xA”);         // 10（十六进制数）<br>var num4 = parseInt(22.5);          // 22<br>var num5 = parseInt(“070”);         // 56（八进制数）<br>var num6 = parseInt(“70”);         // 70（十进制数）<br>var num7 = parseInt(“0xf”);         // 15（十六进制数） </p>
</blockquote>
</li>
<li>parseFloat()<br>与 parseInt() 区别：小数点有效、忽略前导零、十六进制格式字符串转为0<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3>数值、布尔值、对象和字符串值都有toString()方法，null 和undefined 值没有。<br>String()函数能够将任何类型的值转换为字符串<h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3>var o = new Object();<br>ECMAScript 中的对象是一组数据和功能的集合</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>包括算术操作符、位操作符、关系操作符和相等操作符</p>
<h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>递增和递减 ++/- -：前置时变量的值在语句被求值之前改变；后置时变量的值在语句被求值之后改变</p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>负数使用二进制补码格式，即二进制反码加1</p>
<ol>
<li>按位非 ～</li>
<li>按位与 &amp;</li>
<li>按位或 |</li>
<li>按位异或  ^：只有一个1返回1，两位全1或全0返回0</li>
<li>左移  &lt;&lt;</li>
<li>有符号右移 &gt;&gt; 保留符号位</li>
<li>无符号右移 &gt;&gt;&gt;<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3></li>
<li>逻辑非 ！<blockquote>
<p>alert(!false);       // true alert(!”blue”);      // false<br>alert(!0);           // true<br>alert(!NaN);         // true alert(!””);          // true<br>alert(!12345);       // false<br>同时使用两个逻辑非操作符， 就会模拟 Boolean()转型函数的行为</p>
</blockquote>
</li>
<li>逻辑与 &amp;&amp;<br>~短路语法~：第一个true，抛出第二个；第一个false，直接抛出第一个</li>
<li>逻辑或 ||<br>第一个true，直接抛出第一个；第一个false，抛出第二个。<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3>var num1 = 5;<br>var num2 = 10;<br>var message = “The sum of 5 and 10 is “ + num1 + num2;<br>alert(message);    // “The sum of 5 and 10 is 510”  <h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><strong>== 先转换再比较</strong><blockquote>
<p>null == undefined true<br>true == 1 true<br>“NaN” == NaN false<br>true == 2 false<br>5 == NaN false<br>undefined == 0 false<br>NaN == NaN false<br>null == 0 false<br>NaN != NaN true<br>“5”==5 true<br>false == 0 true<br><strong>=== 仅比较而不转换</strong></p>
</blockquote>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3>variable = boolean_expression ? true_vaule : false_value;<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3></li>
</ol>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if (condition) statement else statement2</code></p>
<h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><pre><code>do{
    statement;
} while (expression);   //后测试循环
</code></pre><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p><code>while (expression) statement;  //前测试循环</code></p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p><code>for (initialization; expression; post-loop-expression) statement;// 前测试循环</code></p>
<h3 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h3><p><code>for (property in expression) statement;    // 枚举对象属性的迭代语句</code></p>
<h3 id="label语句"><a href="#label语句" class="headerlink" title="label语句"></a>label语句</h3><p><code>label:statement;   //添加标签</code></p>
<h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>用于在循环中精确控制代码执行</p>
<h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p><code>with(expression) statement;    //将代码作用域设置到特定对象</code></p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><pre><code>switch (expression) {
case value: statement;
    break;
case value: statement;
    break;
case value: statement;
    break;
default: statement;
}
</code></pre><p>省略break关键字，导致执行完当前case后，继续执行下一个case</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>function functionName(arg0,arg1,…,argN) {<br>    statements;<br>}<br>return 语句可以不带返回值，函数停止执行后返回undefined，一般用在需要提前停止函数执行而又不需要返回值的情况。</p>
<h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><p>ECMAScript 中的参数在内部用一个数组表示，函数接收到的始终是这个数组，不关心包含的参数。函数体内可通过<code>arguments</code>对象访问参数数组。<br>命名的参数只提供便利，但不必需。可以让函数能够接收任意参数并分别实现适当功能。<br><code>arguments</code>对象可以与命名对象一起使用，且值与对应命名参数的值保持同步</p>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>如果 ECMAScript 定义好两个名字相同的函数，只属于后定义的函数。<br>通过检查传入函数的参数的类型和数量并做出不同反应，可以模仿方法的重载。</p>
<h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>引用类型的值是保存在内存中的对象。JS不允许直接访问内存中的位置，在操作对象时， 实际上是在操作对象的引用而不是实际的对象。 为此，引用类型的值是按引用访问的。</p>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>只能给引用类型动态添加属性</p>
<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在变量对象上创建一个新值（副本）。<br>从一个变量向另一个变量复制<strong>引用类型</strong>的值， 也将变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，指向存储在堆中的一 个对象。改变其中一个变量，会影响另一个。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><blockquote>
<p><strong>按值传递</strong>(call by value)：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。<br><strong>按引用传递</strong>(call by reference)：函数的形参接收实参的隐式引用，而不再是副本。函数形参的值如果被修改，实参也会被修改，同时两者指向相同的值。<br>~JS 函数参数只能按值传递~ ：</p>
<ul>
<li>在向参数传递基本类型的值时，被传递值会复制给一个局部变量（即命名参数，或者 ECMAScript 的概念——<code>arguments</code>对象中的一个元素） 。</li>
<li>在向参数传递引用类型的值时，会把值在内存中的地址复制给一个局部变量， 这个局部变量的变化会反映在函数外部，可以把 ECMAScript 函数的参数想象成局部变量。</li>
</ul>
</blockquote>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p><code>typeof variable</code> 检测基本类型<br><code>variable instanceof constructor</code> 检测引用类型的值</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p><strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定各自行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在变量对象中。在web浏览器中，全局执行环境被认为是window对象。<br>当执行流进入一个函数，函数的环境就会被推入一个环境栈。而在函数执行之后，栈将其环境弹出，控制权返回给之前的执行环境。<br>当代码在一个环境中执行，会创建变量对象的一个<strong>作用域链(scope chain)</strong>，保证对执行环境有权访问的所有变量和函数的有序访问。scope chain 的前端始终都是 ~当前执行代码所在环境的变量对象~ ,下一个变量来自包含（外部）环境，这一直延续到全局执行环境。内部环境可以通过作用域链访问所有外部环境，外部环境不能访问内部环境中的任何变量和函数。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>有些语句可以在作用域链的前端临时增加变量对象，并在代码执行后被移除。</p>
<ul>
<li>try-catch语句的catch块：创建一个新的变量对象</li>
<li>with语句：将指定对象添加到作用域链中<h3 id="JS-没有块级作用域"><a href="#JS-没有块级作用域" class="headerlink" title="JS 没有块级作用域"></a>JS 没有块级作用域</h3></li>
</ul>
<ol>
<li>声明变量<br>var 声明的变量自动添加到最接近的环境中。 在函数内部，最接近的就是函数的局部环境；在 with 语句中，最接近的是函数环境。初始化没有使用var声明，该变量会自动被添加到全局环境。</li>
<li>查询标识符<br>在某个环境中为读取或写入而引用一个标识符时，要通过搜索来确定标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。</li>
</ol>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>当变量进入环境（例如，在函数中声明一个变量）时，标记为“进入环境”；当变量离开环境时，标记为“离开环境“。</p>
<h3 id="引用计数（不常用）"><a href="#引用计数（不常用）" class="headerlink" title="引用计数（不常用）"></a>引用计数（不常用）</h3><p>跟踪记录每个值被引用的次数。当引用次数变成 0 ，说明没有办法再访问，可以将其占用的内存空间回收。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器周期性运行， 而且如果为变量分配的内存数量很可观， 那么回收工作量也是相当大 的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。</p>
<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>确保占用最少的内存可以让页面获得更好的性能，最佳方式就是为执行中的代码只保存必要的数据，数据一旦不再有用，最好通过将其值设置为null释放其引用——解除引用。做法适用于大多数全局变量和对象的属性。局部变量会在离开执行环境是自动被解除引用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； </li>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本； </li>
<li>引用类型的值是对象，保存在堆内存中； </li>
<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针； </li>
<li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同 一个对象； </li>
<li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分</li>
<li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链； </li>
<li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境； </li>
<li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li>
<li>变量的执行环境有助于确定应该何时释放内存</li>
<li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回 收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用</li>
<li><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1>引用类型（相当于Java中的类）的值（对象）是引用类型的一个实例。<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2>ECMAScript 中使用最多的一个类型，创建Object两种方式：</li>
</ul>
<ol>
<li>new<pre><code>var person = new Object();
person.name = “Nicholas”;
person.age = 29;
</code></pre></li>
<li>对象字面量表示法<pre><code>var person = {
 name : “Nicholas”,
 age:29
};
</code></pre>对象字面量是向函数传递大量可选参数的首选方式。最好的做法是对那些必需值使用命名参数，用对象字面量来封装多个可选参数。<br>除了点表示法，JS 还可以用方括号表示法来访问对象属性，主要优点是可以通过变量来访问属性<pre><code>var propertyName = “name”;
alert(person[propertyName]);
</code></pre></li>
</ol>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>ECMAScript 数组的每一项可以保存任何类型的数据，创建数组两种基本方法：</p>
<ol>
<li><code>var colors = new Array(“red”,”blue”,”green”);</code></li>
<li>数组字面量表示法<br><code>var colors = [“red&quot;, &quot;blue&quot;, &quot;green&quot;];</code><br><code>var names = [];    //创建空数组</code><br>可以设置数组的 length 属性从数组的末尾移除项或向数组中添加项（新增项取得 undefined 值）。<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><code>instanceof</code>的问题在于它假定只有一个全局执行环境<br>ES5 新增 <code>Array.isArray()</code>方法，最终确定是否数组<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><pre><code>var colors = [“red”,”blue”,”green”];
alert(colors.toString());       //red,blue,green
alert(colors.valueOf());        //red,blue,green
alert(colors);
alert(colors.join(“||”));       //red,blue,green
</code></pre><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3>栈是一种LIFO(Last-In-First-Out,后进先出)的数据结构，而栈中项的推入和弹出只发生在栈的顶部。<br>ES 为数组专门提供了<code>push(),pop()</code>方法，<code>push()</code>方法接收任意数量参数，逐个添加到数组末尾，返回修改后数组的长度。<code>pop()</code>方法从数组末尾移除最后一项，减少数组的 length，返回移除的项<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3>队列数据结构的访问规则是FIFO（First-In-First-Out,先进先出)。队列在列表末端添加项，从列表前端移除项。push()实现末端添加，shift()实现前端移除并返回该项。<br><code>unshift()</code>在数组前端添加任意项并返回数组长度。因此使用<code>unshift()</code>和<code>pop()</code>方法可以反向模拟队列<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><code>reverse()</code>反转数组项的顺序<br>默认情况下，<code>sort()</code>调用<code>toString()</code>转型方法按升序排列数组项——最小的值位于最前，即使数组项为数值，比较的也是字符串。<code>sort()</code>可以接收比较函数作为参数来指定排序。<br>比较函数的第一个参数如果应该在第二个参数之前则返回负数，相等返回0，位于之后返回正数。<pre><code>function compare(value1,value2){
 if(value1&lt;value2){
     return -1;
 }else if (value1&gt;value2){
     return 1;
 }else{
     return 0;
 }
}
var values = [0,1,5,10,15];
values.sort(compare);
alert(values);  //0,1,5,10,15
</code></pre>对于数值类型或其<code>valueOf()</code>方法返回数值类型的对象类型，可以更简单：<pre><code>function compare(value1,value2){
 return value2-value1;
}
</code></pre><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><code>concat()</code>可以基于当前数组中的所有项创建一个新数组。具体会创建当前数组的副本，然后将接收到的参数添加到副本的末尾。<br><code>slice()</code>基于当前数组中的一个或多个项创建新数组，接收一或两个参数，即要返回项的起始和结束位置。<br><code>splice()</code>主要用途是向数组的中部插入项，方式有三种：</li>
</ol>
<ul>
<li><strong>删除</strong><br>提供2个参数：起始位置和删除项数，<code>splice(0,2)</code>会删除数组前两项</li>
<li><strong>插入</strong><br>提供3个参数：起始位置，0（删除项数），插入项。</li>
<li><strong>替换</strong><br>向指定位置插入任意数量的项同时删除任意数量的项，提供3个参数：起始位置，删除项数和要插入的任意数量的项。<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3>ES5 为数组实例添加位置方法: <code>indexOf()</code> 和 <code>lastIndexOf()</code>。都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。两者分别从数组开头和末尾开始全等查找，都返回要查找项在数组的位置，没找到返回-1。<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3>ES5 为数组定义5个迭代方法，接收两个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象——影响this的值。传入函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。</li>
<li><code>every()</code>:如果函数对数组每一项都返回true，则返回true</li>
<li><code>filter()</code>:返回该函数会返回true的项组成的数组</li>
<li><code>forEach()</code>:没有返回值</li>
<li><code>map()</code>:返回每次函数调用的结果组成的数组</li>
<li><code>some()</code>:函数对任一项返回true，则返回true<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3>ES5新增归并数组的方法：<code>reduce()</code> 和 <code>reduceRight()</code>。都会迭代数组所有项，构建一个最终返回值。<code>reduce()</code> 从数组的第一项开始，逐个遍历到最后；<code>reduceRight()</code>从数组最后一项开始向前遍历到第一项。<br>都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。传入函数接收4个参数：前一个值、当前值、项的索引和数组对象。函数返回的任何值都会作为第一个参数自动传给下一项。<pre><code>var value = [1,2,3,4,5];
var sum = values.reduce(function(prev,cur,index,array){
  return prev+cur;
});
alert(sum); //15
</code></pre></li>
</ul>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p><code>var now = new Date();</code><br>在不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数） 。为简化这一计算过程，ECMAScript 提供了两个方法：<code>Date.parse()</code>和 <code>Date.UTC()</code>。<br><code>Date.parse()</code>方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。<br><code>var someDate = new Date(Date.parse(“May 25,2004”));</code><br>Date.UTC()方法同样也返回表示日期的毫秒数，但构建参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推） 、月中的哪一天 （1 到 31） 、小时数（0 到 23） 、分钟、秒以及毫秒数。</p>
<pre><code>//GMT时间2000年1月1日午夜零时
var y2k = new Date(Date.UTC(2000,0));

//GMT时间2005年5月5日下午5:55:55
var allFives = new Date(Date.UTC(2005,4,5,17,55,55));
</code></pre><p>ES5 添加<code>Date.now()</code>方法，返回调用方法时日期和时间的毫秒数。</p>
<h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他引用类型一样，Date类型也重写了<code>toLocalString(),toString(),valueOf()</code>方法；其中 <code>valueOf()</code> 方法返回日期的毫秒表示方便使用操作符比较日期值</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ul>
<li><code>toDateString()</code>——以特定于实现的格式显示星期几、月、日和年； </li>
<li><code>toTimeString()</code>——以特定于实现的格式显示时、分、秒和时区； </li>
<li><code>toLocaleDateString()</code>——以特定于地区的格式显示星期几、月、日和年； </li>
<li><code>toLocaleTimeString()</code>——以特定于实现的格式显示时、分、秒； </li>
<li><code>toUTCString()</code>——以特定于实现的格式完整的 UTC 日期。<br>UTC时间指的是在没有时区偏差的情况下的日期值</li>
</ul>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ES通过RegExp类型支持正则表达式：<br><code>var expression = /pattern/flags;</code></p>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>每个函数都是Function类型的实例，由于函数都是对象，函数名实际上也是一个指向函数对象的指针，而不与某个函数绑定。<br>通常使用<strong>函数声明语法定义</strong></p>
<pre><code>function functionName(){
    statements;
}
</code></pre><p><strong>函数表达式定义</strong></p>
<pre><code>var functionName = function(){
    statements;
};      //注意分号
</code></pre><p><strong>Function 构造函数</strong></p>
<pre><code>var sum = new Function(“num1”,”num2”,”return num1+num2”);   
//不推荐，但可用于理解“函数是对象，函数名是指针”
</code></pre><h3 id="没有重载-1"><a href="#没有重载-1" class="headerlink" title="没有重载"></a>没有重载</h3><p>将函数名想象成指针，有助于理解ES中没有函数重载的概念。<br>声明两个同名函数，结果后面的函数覆盖了前面的函数，在创建第二个函数时，实际上覆盖了引用一个函数的变量。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器会 ~率先读取函数声明~ ，并使其在执行任何代码之前可用（可以访问） ；函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行。所以即使声明函数的代码在调用它的代码后面，JS引擎也能把 ~函数声明提升到顶部~ ，函数表达式则会报错。</p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>ES的函数名本身就是变量，所以函数也可以作为值来使用.不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。要访问函数的指针而不执行函数的话，去掉函数名后面的括号。</p>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有两个特殊的对象： arguments 和 this。arguments是一个类数组对象，包含传入函数中的所有参数，这个对象还有一个名叫 callee 的属性，该属性是一个指向拥有此 arguments 对象的函数的指针。</p>
<pre><code>//阶乘函数
function factorial(num){
    if (num&lt;=1){
    return 1;
    } else {
    return num*factorial(num-1)
    }
}
</code></pre><p>用到递归算法后，函数的执行与函数名 factorial 紧紧耦合，为了消除耦合，可以使用 return num*<del>factorial</del> arguments.callee(num-1)</p>
<p>另一个特殊对象 this 引用的是函数据以执行的环境对象——或者也可以说是`this 值 （当在网页的全局作用域中调用函数时，this 对象引用的就是window）<br>ES5也规范化了另一个函数对象的属性：caller，保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null</p>
<pre><code>function outer(){
    inner();
}
function inner(){
    alert(arguments.callee.caller);
}
outer();
</code></pre><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>ES中函数是对象，也有属性和方法，每个函数都包含两个属性：length,prototype。length属性表示函数希望接收的命名参数的个数；对于ES中的引用类型而言，prototype 是保存它们所有实例方法（诸如 toString(),valueOf() ）的真正所在。<br>每个函数包含两个非继承方法：<code>apply(),call()</code>用途都是在特定作用域中调用函数，实际上等于设置函数体内 this 对象的值。<code>apply()</code>接收两个参数，一个是在其中运行函数的作用域，另一个参数数组。<code>call()</code>方法作用相同，区别在于接收参数的方式，使用<code>call()</code> 时，传递给函数的参数必须逐个列举。<br><code>apply(),call()</code>真正强大的地方是能扩充函数赖以运行的作用域，好处就是对象不需要与方法有任何耦合关系，不再非要把方法放到对象中才能被调用。<br>ES5 还定义一个方法：<code>bind()</code>，创建一个函数的实例，其 this 值会被绑定到传给 <code>bind()</code>的值。</p>
<pre><code>window.color = “red”;
var o = {color:”blue”};
function sayColor（）{
    alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor();    //blue
</code></pre><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了操作基本类型值，ES还提供3个特殊的引用类型：Boolean,Number,String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<pre><code>var s1 = “some text”;
var s2 = s1.substring(2);
</code></pre><p>后台自动完成下列处理：<br>(1) 创建 String 类型的一个实例； (2) 在实例上调用指定的方法； (3) 销毁这个实例。<br>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例， 在执行流离开当前作用域之前都一直保存在内存中。 而自动创建的基本包装类型的对象， 则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着不能在运行时为基本类型值添加属性和方法。</p>
<pre><code>var value = &quot;25&quot;; 
var number = Number(value);  //转型函数 
alert(typeof number);        //&quot;number&quot;  

var obj = new Number(value); //构造函数 
alert(typeof obj);           //&quot;object&quot; 
</code></pre><p>尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>var booleanObject = new Boolean(true);<br>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false；重写了 toString() 方法，返回字符串”true”和”false”。我们的建议是永远不要使 用Boolean 对象。 </p>
<h3 id="Number类型-1"><a href="#Number类型-1" class="headerlink" title="Number类型"></a>Number类型</h3><p>var numberObject = new Number(10);<br>除了继承的方法之外，Number 类型还提供了一些用于将数值格式化为字符串的方法</p>
<pre><code>var num = 10; alert(num.toFixed(2));     //&quot;10.00&quot; 
alert(num.toExponential(1));  //&quot;1.0e+1&quot; 
</code></pre><h3 id="String类型-1"><a href="#String类型-1" class="headerlink" title="String类型"></a>String类型</h3><p>var stringObject = new String(“hello world”);</p>
<ol>
<li>字符方法<br>charAt(),charCodeAt() 两个方法都接收一个参数，即基于0的字符位置，还可以使用方括号加数字索引访问string中的特定字符</li>
<li>字符操作方法、<br>concat()用于将一个或多个字符串拼接<br>ES还提供三个基于子字符串创建新字符串的方法：slice(),substr(),substring() 都返回被操作字符串的一个子字符串。第一个参数指定子字符串的开始位置，第二个参数（在指定情况下）表示子字符串到哪里结束。<br>具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符<strong>后面</strong>的位置。 而substr()的第二个参数指定返回的字符个数。<pre><code>var stringValue = &quot;hello world&quot;; alert(stringValue.slice(3));         //&quot;lo world&quot; alert(stringValue.substring(3));     //&quot;lo world&quot; alert(stringValue.substr(3));        //&quot;lo world&quot; alert(stringValue.slice(3, 7));      //&quot;lo w&quot; alert(stringValue.substring(3,7));   //&quot;lo w&quot; alert(stringValue.substr(3, 7));     //&quot;lo worl&quot; 
</code></pre></li>
<li>字符串位置方法<br><code>indexOf(),lastIndexOf()</code> 返回子字符串位置</li>
<li><code>trim()</code>方法<br>创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果</li>
<li>字符串大小写转换方法<br><code>toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()</code></li>
<li>字符串的模式匹配方法<br><code>match()</code> 方法只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象</li>
<li><code>localCompare()</code>方法<br>比较两个字符串：<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（-1）</li>
<li>如果字符串等于字符串参数，则返回0</li>
<li>如果字符串在字母表中应该排在字符串参数之后， 则返回一个正数（1）</li>
</ul>
</li>
<li>静态方法 <code>fromCharCode()</code><br>接收一或 多个字符编码，然后将它们转换成一个字符串，与实例方法 <code>charCodeAt()</code> 相反</li>
</ol>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>内置对象的定义：由ES实现提供，不依赖于宿主环境的对象，在ES程序执行之前就已经存在。<br>开发人员不必显式地实例化内置对象，因为它们已经实例化了。除了Object,Array,String等，ECMA-262还定义了两个单体内置对象：Global,Math</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>ES中的Global对象在某种意义作为一个终极的“兜底”对象。所有在全局作用域中定义的属性和函数，都是Global 对象的属性。除了<code>isNaN()、isFinite()、parseInt()、parseFloat()</code>，Global 对象还包含其他一些方法：</p>
<ol>
<li>URL编码方法<br><code>encodeURI(),encodeURIComponent()</code>方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。<br><code>`</code><br>var uri = “<a href="http://www.wrox.com/illegal" target="_blank" rel="noopener">http://www.wrox.com/illegal</a> value.htm#start”;  </li>
</ol>
<p>//“<a href="http://www.wrox.com/illegal%20value.htm#start&quot;" target="_blank" rel="noopener">http://www.wrox.com/illegal%20value.htm#start&quot;</a> alert(encodeURI(uri));  #不对URI本身的特殊字符编码</p>
<p>//“http%3A%2F%2F<a href="http://www.wrox.com%2Fillegal%20value.htm%23start&quot;" target="_blank" rel="noopener">www.wrox.com%2Fillegal%20value.htm%23start&quot;</a> alert(encodeURIComponent(uri));  #对发现的任何非标准字符进行编码</p>
<pre><code>与之相对应的 `decodeURI(),decodeURIComponent()`
其中`decodeURI()`只能对使用`encodeURI()`替换的字符进行编码；`decodeURIComponent()` 能够解码使用 `encodeURIComponent()` 编码的所有字符，即可以解码任何特殊字符的编码。
</code></pre><p>var uri = “http%3A%2F%2F<a href="http://www.wrox.com%2Fillegal%20value.htm%23start&quot;" target="_blank" rel="noopener">www.wrox.com%2Fillegal%20value.htm%23start&quot;</a>;  </p>
<p>//http%3A%2F%2F<a href="http://www.wrox.com%2Fillegal" target="_blank" rel="noopener">www.wrox.com%2Fillegal</a> value.htm%23start alert(decodeURI(uri));  </p>
<p>//<a href="http://www.wrox.com/illegal" target="_blank" rel="noopener">http://www.wrox.com/illegal</a> value.htm#start alert(decodeURIComponent(uri));  #非有效URI</p>
<pre><code>2. `eval()`方法
eval 就像一个完整的ES解析器，只接受一个参数，即要执行的ES（JS）字符串。
在 `eval()` 中创建的任何变量函数不会被提升，他们被包含在一个字符串中，只在 `eval()` 执行时创建。严格模式下，外部访问不到 `eval()` 中创建的任何变量函数
3. Global对象的属性
4. window 对象
Web浏览器将Global这个全局对象作为window对象的一部分加以实现。JS中的window对象除了扮演ES规定的Global对象的角色外，还承担很多别的任务。
另一种取得Global对象的方法：
</code></pre><p>var global = function(){<br>    return this;<br>}();</p>
<pre><code>### Math对象
1. Math 对象的属性
2. `min(),max()` 方法
</code></pre><p>var max = Math.max(3, 54, 32, 16); alert(max);    //54 </p>
<pre><code>要找到数组中的最大或最小值
</code></pre><p>var values = [1,2,3,4,5,6,7,8];<br>var max = Math.max.apply(Math,values);</p>
<pre><code>这个技巧的关键是把 Math 对象作为`apply()`的第一个参数，从而正确地设置 this 值。然后，可以将任何数组作为第二个参数。
### 舍入方法
* `Math.ceil()`执行向上舍入
* `Math.floor()`执行向下舍入
* `Math.round()`执行标准舍入，四舍五入
### random() 方法
`Math.random()` 方法返回一个大于等于0小于1的随机数，套用公式可以利用方法从某个整数范围随机选择值
`值 = Math.floor(Math.random()*可能值的总数+第一个可能的值）`
多数情况都可以通过一个函数来计算可能值的总数和第一个可能的值：
</code></pre><p>function selectFrom(lowerValue,upperValue){<br>    var choices = upperValue-lowerValue+1;<br>    return Math.floor(Math.random()*choices+lowerValue);<br>}</p>
<p>var num = selectFrom(2,10);<br>alert(num); //介于2和10之间的数值</p>
<pre><code>
# 面向对象的程序设计
ECMA-262定义对象：“无序属性的集合， 其属性可以包含基本值、 对象或者函数。”可以想象成散列表，一组名值对。每个对象都是基于一个引用类型创建的，可以原生也可以自定义。
## 理解对象
创建自定义对象最简单就是创建一个Object实例，在为它添加属性和方法。
现在，对象字面量成为创建这种对象的首选模式：
</code></pre><p>var person = {<br>    name:”Nicholas”,<br>    age:29,<br>    job:”Software Engineer”,</p>
<pre><code>sayName:function(){
    alert(this.name);
}
</code></pre><p>};</p>
<pre><code>### 属性类型
1. 数据属性
包含一个数据值的位置，有4个描述其行为的特性(attribute)
* [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为访问器属性
* [[Enumerable]]：表示能否通过 for-in 循环返回属性
* [[Writable]]： 表示能否修改属性的值
* [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候， 把新值保存在这个位置.
要修改属性默认的特性，必须使用 ECMAScript 5 的`Object.defineProperty()`方法。这个方法 接收三个参数：属性所在对象、属性名字和一个描述符对象（descriptor 对象的属性必须是：configurable、enumerable、writable 和 value）
</code></pre><p>var person = {};<br>Object.defineProperty(person,”name”,{<br>    writable:false,<br>    value:”Nicholas”<br>});</p>
<p>alert(person.name); //“Nicholas”<br>person.name = “Greg”;<br>alert(person.name); //“Nicholas”</p>
<pre><code>如果不指定，configurable、enumerable 和 writable 特性的默认值都是false
2. 访问器属性
不包含数据值，包含一对`getter`和`setter`函数。在读取访问器属性时，会调用`getter`函数，负责返回有效的值；在写入访问器属性时，会调用`setter`函数并传入新值，负责决定如何处理数据。有如下4个特性：
* [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。
* [[Enumerable]]：表示能否通过 for-in 循环返回属性。
* [[Get]]：在读取属性时调用的函数
* [[Set]]：在写入属性时调用的函数
访问器属性不能直接定义，必须使用`Object.defineProperty()`来定义
</code></pre><p>var book = {<br>    _year:2004,     //下划线表示只能通过对象方法访问的属性<br>    edition:1<br>};</p>
<p>Object.defineProperty(book,”year”,{<br>    get:function(){<br>        return this._year;<br>    },<br>    set:function(newValue){<br>        if(newValue&gt;2004){<br>            this._year = newValue;<br>            this.edition += newValue - 2004;<br>        }<br>    }<br>});</p>
<p>book.year = 2005;<br>alert(book.edition);    //2</p>
<pre><code>使用访问器属性的常见方式，即设置一个属性的值导致其他属性发生变化。
### 定义多个属性
`Object.defineProperties()` 接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。
</code></pre><p>var book = {};</p>
<p>Object.defineProperties(book,{<br>    _year:{<br>        value:2004<br>    },<br>    edition:{<br>        value:1<br>    },<br>    year:{<br>        get:function(){<br>            return this._year;<br>        },<br>        set:function(newValue){<br>            if (newValue&gt;2004){<br>                this._year = newValue;<br>                this.edition += newValue-2004;<br>            }<br>        }<br>    }<br>});</p>
<pre><code>### 读取属性的特性
`Object.getOwnPropertyDescriptor()` 方法可以取得给定属性的描述符，接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回一个对象，如果是访问器属性，返回对象的属性有configurable、enumerable、get 和 set；如果是数据属性，这 个对象的属性有configurable、enumerable、writable 和value。

## 创建对象
Object构造函数或对象字面量创建单个对象的缺点：使用同一接口创建很多对象，产生大量重复代码。
### 工厂模式
工厂模式抽象了创建具体对象的过程。考虑到ES无法创建类，发明了一种函数封装以特定接口创建对象的细节
</code></pre><p>function createPerson(name,age,job){<br>    var o = new Object();<br>    o.name = name;<br>    o.job = job;<br>    o.sayName = function(){<br>        alert(this.name);<br>    };<br>    return o;<br>}</p>
<p>var person1 = createPerson(“Nicholas”,29,”Software Engineer”);<br>var person2 = createPerson(“Greg”,27,”Doctor”);</p>
<pre><code>工厂模式解决了创建多个相似对象的问题，但没有解决对象识别的问题。
### 构造函数模式
ES的构造函数可以创建特定类型的对象，如 Object,Array 等原生构造函数。也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法
</code></pre><p>function Person(name,age,job){<br>    this.name = name;<br>    this.age = age;<br>    this.job = job;<br>    this.sayName = function(){<br>        alert(this.name);<br>    };<br>}<br>var person1 = new Person(“Nicholas”,29,”Software Engineer”);<br>var person2 = new Person(“Greg”,27,”Doctor”);</p>
<pre><code>`Person()`与`createPerson()`不同之处：
* 没有显式创建对象
* 直接将属性和方法赋给 this 对象
* 没有 return 语句
按照惯例，构造函数以大写字母开头，非构造函数以小写字母开头
1. 将构造函数当作函数
构造函数与其他函数的唯一区别，就在于调用它们的方式不同。
</code></pre><p>// 当作构造函数使用<br>var person = new Person(“Nicholas”, 29, “Software Engineer”); person.sayName(); //“Nicholas”  </p>
<p>// 作为普通函数调用<br>Person(“Greg”, 27, “Doctor”); // 添加到window window.sayName(); //“Greg”  </p>
<p>// 在另一个对象的作用域中调用<br>var o = new Object();<br>Person.call(o, “Kristen”, 25, “Nurse”);<br>o.sayName(); //“Kristen”  </p>
<pre><code>2. ::构造函数的问题::
~构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍。~
person1和person2都有的`sayName()`方法不是同一个Function的实例——ES中函数是对象，每定义一个函数也就是实例化了一个对象。
`this.sayName = new Function(“alert(this.name)”);   //与声明函数逻辑上等价`
以这种方式创建函数，导致不同的作用域链和标识符解析，不同实例上的同名函数是不相等的。
`alert(person1.sayName == person2.sayName); //false`
**通过把函数定义转移到构造函数外部解决该问题**
</code></pre><p>…<br>    this.sayName = sayName;<br>}</p>
<p>function sayName(){<br>    alert(this.name);<br>}</p>
<pre><code>这样person1和person2对象共享了全局作用域定义的同一个函数，新的问题是如果对象需要定义多个方法，就要定义多个全局函数，自定义的引用类型不再有封装性。
### 原型模式
创建的每一个函数都有一个 prototype（原型）属性，这个属性是一个指向一个对象的指针，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中
</code></pre><p>function Person(){}<br>Person.prototype.name = “Nicholas”;<br>Person.prototype.age = 29;<br>Person.prototype.job = “Software Engineer”;<br>Person.prototype.sayName = function(){<br>    alert(this.name);<br>};</p>
<p>var person1 = new Person();<br>person1.sayName();  //“Nicholas”</p>
<p>var person2 = new Person();<br>person2.sayName();  //“Nicholas”<br>alert(person1.sayName == person2.sayName);  //true</p>
<pre><code>要理解原型模式的工作原理必须先理解ES中原型对象的性质
1. **理解原型对象**
原型对象默认获得一个 constructor（构造函数）属性，该属性高喊一个指向 prototype 属性所在函数的指针，Person.prototype.constructor 指向 Person。
调用构造函数创建新实例后，实例内部包含一个指针[[Prototype]]指向原型函数。可以通过 isPrototypeOf() 方法确定对象之间是否存在这个连接。使用Object.getPrototypeOf() 方法返回[[Prototype]]的值。
当为对象实例添加一个属性时，这个属性就会**屏蔽**原型对象中保存的同名属性，但不会改变原型对象的数值。使用 hasOwnProperty() 检测方法在给定属性存在于对象实例中而不是原型中时，返回true
2. **原型与 in 操作符**
in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在实例中还是原型中。结合使用 hasOwnProperty() 方法可以确定属性到底存在对象还是原型：
</code></pre><p>function hasPrototypeProperty(object,name){<br>    return !object.hasOWnProperty(name)&amp;&amp;(name in object);<br>}</p>
<pre><code>使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，无论在实例中还是原型中。
要取得对象上所有可枚举的实例属性， 可以使用 ES5的Object.keys()，方法接收一个对象参数，返回包含属性的字符串数组。
3. **更简单的原型语法**
将 `Person.prototype`以对象字面量形式重写
</code></pre><p>function Person(){}<br>Person.prototype = {<br>    name:”Nicholas”,<br>    age:29,<br>    job:”Software Engineer”,<br>    sayName:function(){<br>        alert(this.name);<br>    }<br>};</p>
<pre><code>4. **原型的动态性**
在原型中查找值的过程是一次搜索， 我们对原型对象的任何修改都能够立即从实例上反映——实例与原型之间的连接是指针而非副本。
如果重写了 prototype，就会把原型修改为另一个对象切断了现有原型与之前已存在的对象实例之间的联系。
5. **原生对象的原型**
不仅是自定义对象，所有原生引用类型（Object、Array、String，等等）也在其构造函数的原型上定义了方法。通过原生对象的原型，可以取得所有默认方法的引用，也可以定义新方法。
6. **原型对象的问题**
除了因为省略为构造函数传递初始化参数而导致所有实例默认取得相同属性值，原型模式在共享引用类型值的属性时存在最大问题。
</code></pre><p>function Person(){}<br>Person.prototype = {<br>    friends:[“Shelby”,”Court”]<br>};<br>var person1 = new Person();<br>var person2 = new Person();</p>
<p>person1.friends.push(“Van”);<br>alert(person1.friends); //“Shelby,Court,Van”<br>alert(person2.friends); //“Shelby,Court,Van”<br>alert(person1.friends === person2.friends);     //true</p>
<pre><code>### 组合使用构造函数模式和原型模式
组合使用是创建自定义类型最常见方式。构造函数模式定义实例属性，原型模式定义方法和共享的属性。每个实例都有自己的一份实例属性副本， 同时共享对方法的引用，最大限度节省内存。这种混成模式还支持向构造函数传递参数
</code></pre><p>function Person(name,age,job){<br>    this.name = name;<br>    this.age = age;<br>    this.job = job;<br>    this.friends = [“Shelby”,”Court”];<br>}</p>
<p>Person.prototype = {<br>    constructor:Person,<br>    sayName:function(){<br>        alert(this.name);<br>    }<br>}</p>
<pre><code>### 动态原型模式
它把所有信息封装在构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下）。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。
</code></pre><p>function Person(name,age,job){<br>    //属性<br>    this.name = name;<br>    this.age = age;<br>    this.job = job;<br>    //方法<br>    if (typeof this.sayName !=“function”){<br>        Person.prototype.sayName = function(){<br>            alert(this.name);<br>        };<br>    }<br>}</p>
<pre><code>这里只在`sayName()`方法不存在时，才将它添加到原型。
&gt; 使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。

### 寄生构造函数模式
基本思想是创建一个函数，仅封装创建对象的代码，然后再返回新创建的对象
</code></pre><p>function Person(name,age,job){<br>    var o = new Object()；<br>    o.name = name;<br>    o.age = age;<br>    o.job = job;<br>    o.sayName = function(){<br>        alert(this.name);<br>    };<br>    return o;<br>}<br>var friend = new Person(“Nicholas”,29,”Software Engineer”);</p>
<pre><code>除了使用 new 操作符，这个模式和工厂模式其实一样。
寄生模式在特殊情况下用来为对象创建构造函数。 假设我们想创建一个具有额外方法的特殊 数组。由于不能直接修改 Array 构造函数，可以使用寄生模式。 
### 稳妥构造函数模式
稳妥对象，指没有公共属性，且其方法也不引用this的对象。稳妥对象最适合在一些安全环境中 （禁用 this 和 new ），或者在防止数据被其他应用程序 （如 Mashup程序）改动时使用。
</code></pre><p>function Person(name,age,job){<br>    //创建要返回的对象<br>    var o = new Object();<br>    //可以在这里定义私有变量和函数<br>    //添加方法<br>    o.sayName = function(){<br>        alert(name);<br>    };</p>
<pre><code>//返回对象
return o;
</code></pre><p>}</p>
<pre><code>以这种模式创建的对象中，只能通过sayName()方法访问到name值。
&gt; 与寄生构造函数模式类似， 使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof 操作符对这种对象也没有意义。

## 继承
~~原型链~~ES6增加了class概念

# 函数表达式
**定义函数：函数声明，函数表达式。**
函数声明的重要特征是 ~函数声明提升~ ，即执行代码之前会先读取函数声明，函数声明可以放在调用它的语句后面。function.name属性可以访问”functionName”。
函数表达式看起来像常规的变量赋值语句，即创建一个函数并将它赋值给变量 functionName。由于 function 关键字后面没有标识符，创建的函数叫**匿名函数**，其 name 属性是空字符串。**函数表达式在使用前必须先赋值(给变量）**，这是其与函数声明的区别。 ~在把函数当成值来使用的情况下，都可以使用匿名函数。~

## 递归
递归函数是在一个函数通过名字调用自身的情况下构成的。
使用`arguments.callee`代替递归内部的函数名更保险，但是严格模式下`arguments.callee`不能通过脚本访问，可以使用命名函数表达式达成相同效果。
</code></pre><p>var factorial = (function f(num){<br>    if(num&lt;=1){<br>        return 1;<br>    } else {<br>        return num*f(num-1);<br>    }<br>});</p>
<pre><code>
## 闭包
~闭包是指有权访问另一个函数作用域中变量的函数~ 。创建闭包常见方式，就是在一个函数内部创建另一个函数。
当某个函数被调用时， 会创建一个执行环境 （execution context） 及相应的作用域链。然后，使用`arguments`和其他命名参数的值来初始化函数的活动对象（activation object） 。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，直至作为作用域链终点的全局执行环境。
后台的每一个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而局部环境（函数）的变量对象只在函数执行过程中存在。在创建函数时，会创建一个预先包含全局变量对象的作用域链，被保存在内部[[Scope]]属性中。调用函数时会为函数创建一个执行环境，通过复制[[Scope]]属性中的对象构建执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入作用域链的前端。**作用域链本质上是一个指向变量对象的指针列表，只引用不实际包含变量对象。**
在函数中访问变量时，会从作用域链搜索相应名字的变量。一般执行完毕后局部活动对象被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。
~闭包的情况有所不同~ ，在另一个函数内部定义的函数会将外部包含函数的活动对象添加到作用域链。外部函数执行完毕后，执行环境的作用域链被销毁，其活动对象不会被销毁，因为内部函数的作用域链链仍在引用它，直到内部函数被销毁。
闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。
### 闭包与变量
返回函数不立刻执行，闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象。
</code></pre><p>function createFunction(){<br>    var result = new Array();</p>
<pre><code>for (var i=0;i&lt;10;i++){
    result[i] = function(){
        return i;
    };
}
return result;
</code></pre><p>}</p>
<pre><code>可以使用“**创建一个匿名函数并立刻执行**“语法重写
</code></pre><p>function createFunction(){<br>    var result = new Array();</p>
<pre><code>for(var i=0;i&lt;10;i++){
    result[i] = function(num){
        return function(){
            return num;
        };
    }(i);
}
return result;
</code></pre><p>}</p>
<pre><code>### 关于this对象
以变量方式定义的函数实际上也是一个全局变量，因此匿名函数的执行环境具有全局性，其 this 对象通常指向window。
函数在被调用时自动取地两个特殊变量：this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止。如果 想要访问外部作用域里的 this 和 arguments 对象，必须将对该对象的引用保存到一个闭包能访问的变量中。
### 内存泄漏
闭包在IE9之前的版本会导致特殊的问题，如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。
</code></pre><p>function assignHandler(){<br>    var element = document.getElementById(“someElement”);<br>    element.onclick = function(){<br>        alert(element.id);<br>    };<br>}</p>
<pre><code>由于匿名函数保存了一个对`assignHandler()`的活动对象的引用，会导致无法减少 element 的引用数，解决方案：
</code></pre><p>function assignHandler(){<br>    var element = document.getElementById(“someElement”);<br>    var id = element.id;<br>    element.onclick = function(){<br>        alert(id);<br>};<br>    element = null;<br>}</p>
<pre><code>通过把 element.id 的副本保存在一个变量中， 并且在闭包中引用该变量消除了循环引用。必须要记住：**闭包会引用包含函数的整个活动对象**，而其中包含着 element。即使闭包不直接引用 element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把 element 变量设置为 null，解除对DOM对象的引用，确保正常回收内存

## 模仿块级作用域
JS没有块级作用域概念，意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。
JS不会告诉你是否多次声明了同一变量，只会对后续的声明视而不见（但会执行后续声明中的变量初始化） 。匿名函数可以用来模仿块级作用域并避免这个问题。 
用作块级作用域的匿名函数的语法：
</code></pre><p>(function(){<br>    //这里是块级作用域<br>})();</p>
<pre><code>以上代码定义并立即调用了一个匿名函数。 将函数声明包含在一对圆括号中表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。
临时需要一些变量时，就可以使用私有作用域。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。 只要函 数执行完毕，就可以立即销毁其作用域链了。 

## 私有变量
任何在函数中定义的变量， 都可以认为是私有变量， 因为不能在函数的外部访问这些变量。 包括函数的参数、局部变量和在函数内部定义的其他函数。如果在函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。利用这一点就可以创建用于访问私有变量的公有方法。
**有权访问私有变量和私有函数的公有方法称为特权方法。**两种在对象上创建特权方法的方式，第一种是在构造函数中定义：
</code></pre><p>function MyObject(){<br>    //私有变量和私有函数<br>    var privateVariable = 10;<br>    function privateFunction(){<br>        return false;<br>    }<br>    //特权方法<br>    this.publicMethod = function(){<br>        privateVariable++;<br>        return privateFunction();<br>    };<br>}</p>
<pre><code>特权方法作为闭包有权访问构造函数中定义的所有变量和函数。在创建 MyObject 的实例后，除了使用`publicMethod()`这一个途径外，没有任何办法可以直接访问`privateVariable`和`privateFunction()`。 
利用私有和特权成员可以隐藏不应该被直接修改的数据：
</code></pre><p>function Person(name){<br>    this.getName = function(){<br>        return name;<br>    };<br>    this.setName = function(value){<br>        name = value;<br>    };<br>}</p>
<p>var person = new Person(“Nicholas”);<br>alert(person.getName());    //“Nicholas”<br>person.setName(“Greg”);<br>alert(person.getName());    //“Greg”</p>
<pre><code>缺点就是必须使用构造函数模式，构造函数模式的缺点就是针对每个实例创建同样一组新方法，使用静态私有变量实现特权方法可以避免此问题。

### 静态私有变量
在私有作用域中定义私有变量或函数
</code></pre><p>(function(){<br>    //私有变量和私有函数<br>    var privateVariable = 10;<br>    function privateFunction(){<br>        return false;<br>    }<br>    //构造函数<br>    MyObject = function(){<br>    };<br>    //公有/特权方法<br>    MyObject.prototype.publicMethod = function(){<br>        privateVariable++;<br>        return privateFunction();<br>    };<br>})();</p>
<pre><code>定义构造函数使用函数表达式，且声明 MyObject 时没有使用 var 关键词，初始化未经声明的变量总会创建一个全局变量。因此 MyObject 成了全局变量。
这个模式与在构造函数中定义特权方法的主要区别， 在于私有变量和函数是由实例共享的。 由于 特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。
### 模块模式
模块模式为单例（只有一个实例的对象）创建私有变量和特权方法。
JS 以对象字面量的方式创建单例对象:
</code></pre><p>var singleton = {<br>    name:value,<br>    method:function(){<br>        //这里是方法的代码<br>    }<br>};</p>
<pre><code>模块模式通过为单例添加私有变量和特权方法能够使其得到增强:
</code></pre><p>var singleton = function(){<br>    //私有变量和私有函数<br>    var privateVariable = 10;<br>    function privateFunction(){<br>    return false;<br>}<br>    //特权/公有方法和属性<br>    return{<br>        publicProperty:true,<br>        publicMethod:function(){<br>            privateVariable++;<br>            return privateFunction();<br>        }<br>    };<br>}();</p>
<pre><code>模块模式使用了一个返回对象的匿名函数。 在匿名函数内部， 首先定义私有变量和函数。 然后将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化， 同时又需要维护其私有变量时非常有用，例：
</code></pre><p>var application = function(){<br>    //私有变量和函数<br>    var components = new Array();<br>    //初始化<br>    components.push(new BaseComponent());</p>
<pre><code>//公共
return{
    getComponentCount:function(){
        return components.length;
    },
    registerComponent:function(component){
        if(typeof component == “object”){
            components.push(component);
        }
    }
};
</code></pre><p>}();</p>
<pre><code>Web 应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的 application 对象。
如果必须创建一个对象并以某些数据对其进行初始化， 同时还要公开一些能够访问这些私有数据的方法， 就可以使用模块模式。 以这种模式创建的每个单例都是 Object 的实例， 因为最终要通过一个对象字面量来表示它——单例通常作为全局对象存在，不会将它传递给一个函数。
### 增强的模块模式
适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况
</code></pre><p>var singleton = function(){<br>    //私有变量和私有函数<br>    var privateVariable = 10;<br>    function privateFunction(){<br>        return false;<br>    }<br>    //创建对象<br>    var object = new CustomType();<br>    //添加特权/公有属性和方法<br>    object.publicProperty = true;<br>    object.publicMethod = function(){<br>        privateVariable++;<br>        return privateFunction();<br>    };<br>    //返回这个对象<br>    return object;<br>}();</p>
<pre><code>如果前面演示模块模式的例子中的 application 对象必须是 BaseComponent 的实例，可以使用以下代码
</code></pre><p>var application = function(){<br>    //私有变量和函数<br>    var components = new Array();<br>    //初始化<br>    components.push(new BaseComponent());<br>    //创建 application 的一个局部副本<br>    var app = new BaseComponent();<br>    //公共接口<br>    app.getComponentCount = function(){<br>        return components.length;<br>    };<br>    app.registerComponent = function(component){<br>        if (typeof component == “object”){<br>            component.push(component);<br>        }<br>    };<br>    //返回这个副本<br>    return app;<br>}();</p>
<pre><code>
## 小结
* 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表 达式也叫做匿名函数。 
* 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
* 递归函数应该始终使用`arguments.callee`来递归地调用自身， 不要使用函数名——函数名可 能会发生变化。 
* 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
* 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁
* 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 
* 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
* 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外 部作用域）中的变量。 
* 即使 JavaScript 中没有正式的私有对象属性的概念， 但可以使用闭包来实现公有方法， 而通过公 有方法可以访问在包含作用域中定义的变量。 
* 有权访问私有变量的公有方法叫做特权方法
* 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。 

# 事件
Javascript 与 HTML 之间的交互通过**事件**实现。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间。
## 事件流
事件流描述的是从页面中接受时间的顺序
### 事件冒泡
事件开始是有最具体的元素（文档嵌套最深的节点）接收，然后逐级向上传播。
### 事件捕捉
用意在于在事件到达预定目标之前捕获它
### DOM事件流
包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段

## 事件处理程序
事件就是用户或浏览器自身执行的动作，如 click,load,mouse over。而响应某个事件的函数就叫做事件处理程序，名字以”on“开头，如 onclick,onload
### HTML事件处理程序
`&lt;input type=“button” value=“Click Me” onclick=“alert(‘Clicked’)”/&gt;`
HTML 事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本：
</code></pre><p>&lt;script type=“text/javascript”&gt;<br>    function showMessage(){<br>        alert(“Hello world!”);<br>    }<br></p>
<p><input type="“button”" value="“Click" me” onclick="“showMessage()”/"></p>
<pre><code>这样指定事件处理程序，首先会创建一个封装着元素属性值的函数，函数中有一个局部变量 event，即事件对象。
通过event变量，可以直接访问事件对象。
</code></pre><p>&lt;!—-输出 “Click Me” —-&gt;</p>
<p><input type="“button”" value="“Click" me” onclick="“alert(this.value)”"></p>
<pre><code>在HTML中指定事件处理程序的缺点。首先存在一个时差问题，因为用户可能会在HTML元素已出现在页面上就触发响应事件，但处理程序可能尚不具备执行条件，为此很多HTML事件处理程序会被封装在 try-catch 块中。
`&lt;input type=“button” value=“Click Me” onclick=“try{showMessage();} catch(ex){}”&gt;`
另一个缺点，扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。
最后，HTML 与 Javascript 代码紧密耦合，不便于维护。

### DOM0 级事件处理程序
通过 Javascript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。首先必须取得一个要操作对象的引用。
每个元素（包括window和document）都有自己的事件处理程序：
</code></pre><p>var btn = document.getElementById(“myBtn”);<br>btn.onclick = function(){<br>    alert(“Clicked”);<br>};</p>
<pre><code>使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此这个时候的事件处理程序是在元素作用域中运行，this 引用当前元素。
可以在事件处理程序通过 this 访问元素的任何属性和方法，以这种方法添加的事件处理程序会在事件流的冒泡阶段被处理。
删除事件处理程序：
`btn.onclick = null;`
### DOM2 级事件处理程序
“DOM2 级事件” 定义了两个方法， 用于处理指定和删除事件处理程序的操作：addEventListener() 和removeEventListener()。它们都接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（true：表示在捕获阶段调用事件处理程序；false：表示在冒泡阶段调用事件处理程序）
</code></pre><p>var btn = document.getElementById(“myBtn”);<br>btn.addEventListener(“cilck”,function(){<br>    alert(this.id);<br>},false);</p>
<pre><code>通过`addEventListener()`添加的事件处理程序只能使用 removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。意味着通过`addEventListener()`添加的匿名函数将无法移除。
大多数情况下， 都是将事件处理程序添加到事件流的冒泡阶段，可以兼容浏览器，最好只在需要在事件到达目标之前截获它的时候将处理程序添加到捕获阶段。
### IE事件处理程序
IE实现了与DOM类似的方法：`attachEvent()`和 `detachEvent()`。接收相同两个参数：事件处理程序名称与事件处理程序函数。
### 跨浏览器的事件处理程序
要保证处理事件的代码能跨浏览器运行，只需关注冒泡阶段。
第一个要创建的方法是`addHandler()`，职责是视情况分别使用 DOM0 级方法、DOM2 级方法或IE方法添加事件。`addHandler()`属于 EventUtil 对象，接收3个参数：要操作元素、事件名称、事件处理程序函数。
`removeHandler()`接受相同参数，职责是移除之前添加的事件处理程序。
</code></pre><p>var EventUtil = {<br>    addHandler : function(element,type,handler){<br>        if(element.addEventListener){<br>            element.addEventListener(type,handler,false);<br>        } else if (element.attachEvent){<br>            element.attachEvent(“on”+type,handler);<br>        } else {<br>            element[“on”+type] = handler;<br>        }<br>    },<br>    removeHandler : function(element,type,handler){<br>        if(element.removeEventListener){<br>            element.removeEventListener(type,handler,false);<br>        } else if (element.detachEvent){<br>            element.detachEvent(“on”+type,handler);<br>        } else {<br>            element[“on”+type] = null;<br>        }<br>    }<br>};</p>
<pre><code>
## 事件对象
在触发DOM上某个事件时，会产生一个事件对象 event，这个对象中包含所有与事件有关的信息。包括导致事件的元素、事件类型以及其他与特定事件相关的信息。
### DOM中的事件对象
兼容DOM的浏览器会将一个 event 对象传入事件处理程序。
event 对象包含与创建它的特定事件有关的属性和方法，触发的事件类型不一样，可用的属性和方法也不一样。
需要通过一个函数处理多个事件时，可以使用 type 属性：
</code></pre><p>var btn = document.getElementById(“myBtn”);<br>var handler = function(event){<br>    switch(event.type){<br>        case “click”:<br>            alert(“Clicked”);<br>            break;<br>        case “mouseover”:<br>            event.target.style.backgroundColor = “red”;<br>            break;</p>
<pre><code>    case “mouseout”:
        event.target.style.backgoundColor = “”;
        break;
}
</code></pre><p>};</p>
<p>btn.onclick = handler;<br>btn.onmouseover = handler;<br>btn.onmouseout = handler;</p>
<pre><code>阻止特定事件的默认行为，使用`preventDefault()`方法。
`stopPropagation()`用于立即停止事件在DOM层次中的传播，即取消进一步事件捕捉或冒泡。
事件对象的 eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。捕获阶段调用等于1，事件处理程序处于目标对象上等于2，冒泡阶段调用等于3.
### IE中的事件对象
在使用 DOM0 级方法添加事件处理程序时，event 对象作为 window 对象的一个属性存在。
如果是通过 HTML 特性指定的事件处理程序， 那么还可以通过一个名叫 event 的变量来访问 event 对象（与 DOM 中的事件模型相同）。
### 跨浏览器的事件对象
基于DOM和IE中 event 对象的相似性拿出跨浏览器的方案：
</code></pre><p>var EventUtil = {<br>    addHandler:function(element,type,handler){<br>        //省略的代码<br>    },<br>    getEvent:function(event){<br>        return event ? event:window.event;<br>    },<br>    getTarget:function(event){<br>        return event.target || event.srcElement;<br>    },<br>    preventDefault:function(event){<br>        if(event.preventDefault){<br>            event.preventDefault();<br>        } else {<br>            event.returnValue = false;<br>        }<br>    },<br>    removeHandler:function(element,type,handler){<br>    //省略的代码<br>    },<br>    stopPropagation:function(event){<br>        if(event.stopPropagation){<br>            event.stopPropagation();<br>        } else {<br>            event.cancelBubble = true;<br>        }<br>    }<br>};</p>
<pre><code>
## 事件类型
### UI（User Interface）事件
* load
JS 定义 onload 事件处理程序：
</code></pre><p>EventUtil.addHandler(window,”load”,function(event){<br>    alert(“Loaded!”);<br>});</p>
<pre><code>* unload
利用这个事件最多的情况是清除引用，以避免内存泄漏
* abort
* error
* select
* resize
* scroll
### 焦点事件
* blur
* focus
* focusin
* focusout
### 鼠标事件
* click
* dbclick
* mousedown
* mouseenter
* moseleave
* mousemove
* mouseout
* mouseover
* mouseup
### 滚轮事件
### 文本事件
### 键盘事件
* keydown
* keypress
* keyup
### 合成事件
### 变动事件

## 内存和性能
### 事件委托
对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用事件冒泡，只指定一个事件处理程序， 就可以管理某一类型的所有事件。相当于一个经理同时管理多名职员的某类工作。
</code></pre><p>//HTML</p>
<p><ul id="“myLinks”"><br>    <li id="“goSomewhere”">Go somewhere</li><br>    <li id="“doSomething”">Do something</li><br>    <li id="“sayHi”">Say hi</li><br></ul></p>
<pre><code>
</code></pre><p>//JS<br>var list = document.getElementById(“myLinks”);</p>
<p>EventUtil.addHandler(list,”click”,function(event){<br>    event = EventUtil.getEvent(event);<br>    var target = EventUtil.getTarget(event);</p>
<pre><code>switch(target.id){
    case “doSomething”:
        document.title = “I changed the document’s title”;
        break;

    case “goSomewhere”:
        location.href = “”;
        break;

    case “sayHi”:
        alert(“hi”);
        break;
}
</code></pre><p>});</p>
<pre><code>最适合采用事件委托的事件包括click、 mousedown、 mouseup、 keydown、 keyup 和 keypress。
* document 对象访问快
* 只添加一个事件处理程序所需DOM引用更少
* 页面占用内存更少
### 移除事件处理程序
内存中过时不用的“空事件处理程序” （dangling event handler） ，也会造成 Web 应用程序内存与性能问题。
有两种情况可能会造成上述问题。第一种发生在使用 innerHTML 替换页面中某一部分时。如果带有事件处理程序的元素被 innerHTML 删除了，那么原来添加到元素中的事件处理程序极可能无法被当作垃圾回收。
</code></pre><p><div id="“myDiv”"><br>    <input type="“button”" value="“Click" me” id="“myBtn”"><br></div></p>
<p>&lt;script type=“text/javascript”&gt;<br>    var btn = document.getElementById(“myBtn”);<br>    btn.onclick = function(){<br>        //先执行某些操作<br>        document.getElementById(“myDiv”).innerHTML = “Processing…”;   //麻烦了！<br>    };<br></p>
<pre><code>为避免双击，单击按钮时将按钮移除并替换成一 条消息——这是非常流行的一种做法。但问题在于，当按钮被从页面中移除时，还连接着事件处理程序。
</code></pre><p><div id="“myDiv”"><br>    <input type="“button”" value="“Click" me” id="“myBtn”"><br></div></p>
<p>&lt;script type=“text/javascript”&gt;<br>    var btn = document.getElementById(“myBtn”);<br>    btn.onclick = function(){<br>        //先执行某些操作<br>        btn.onclick = null; //移除事件处理程序<br>        document.getElementById(“myDiv”).innerHTML = “Processing…”;   //麻烦了！<br>    };<br><br><code>`</code><br>导致“空事件处理程序”另一种情况就是卸载页面时。最好的做法是在页面卸载之前， 先通过onunload 事件处理程序移除所有事件处理程序。事件委托技术再次表现出它的优势——需要跟踪的事件处理程序越少，移除它们就越容易。</p>
<h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>在测试 Web 应用程序，模拟触发事件是一种极其有用的技术。</p>
<h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><p>在document 对象上使用createEvent()方法创建 event 对象，方法接收一个参数， 即表示要创建的事件类型的字符串：</p>
<ul>
<li>UIEvents</li>
<li>MouseEvents</li>
<li>MutationEvents</li>
<li>HTMLEvents<br>创建了 event 对象后，还需要使用与事件有关的信息对其初始化。模拟事件的最后一步就是触发事件 dispatchEvent()，需要传入参数——表示要触发事件的event对象。</li>
</ul>
<ol>
<li>模拟鼠标事件<br>createEvent(“MouseEvents”) 返回的对象有一个名为 initMouseEvent() 方法，用于指定与该鼠标事件有关信息。</li>
<li>模拟键盘事件</li>
<li>模拟其他事件</li>
<li>自定义DOM事件<br><code>createEvent(“CustomEvent”)</code></li>
</ol>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户 感觉页面反应不够灵敏。 </li>
<li>建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。 </li>
<li>建议在浏览器卸载页面之前移除页面中的所有事件处理程序。</li>
</ul>
<p></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://xhdnoah.github.io/2018/10/19/JavaScript/%20电子月亮%20《JavaScript 高级程序设计》笔记" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2018/10/19/《你不知道的 JavaScript》/" title="《你不知道的 JavaScript》笔记"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 《你不知道的 JavaScript》笔记</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2018/10/19/css-learning/" title="css-learning">Next post: css-learning&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>