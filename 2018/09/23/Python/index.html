<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Noah Xu"><title>python-learning · 电子月亮</title><meta name="description" content="转义序列


转义符
功能




\
Backslash


\’
Single quote


\”
Double quote


\a
ASCII Bell


\b
ASCII Backspace


\f
ASCII Formfeed


\n
ASCII Linefeed


\N{na"><meta name="keywords" content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">Electronic Moon</a></h1></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/resume/resume.html">简历</a></li><li class="soc"><a href="https://github.com/xhdnoah" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="http://xhdnoah.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>python-learning</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2018-09-23</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/Python/" title="Python" class="a-tag">Python</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h1 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h1><table><thead><tr><th>转义符</th><th>功能</th></tr></thead><tbody><tr><td>\</td><td>Backslash</td></tr><tr><td>\’</td><td>Single quote</td></tr><tr><td>\”</td><td>Double quote</td></tr><tr><td>\a</td><td>ASCII Bell</td></tr><tr><td>\b</td><td>ASCII Backspace</td></tr><tr><td>\f</td><td>ASCII Formfeed</td></tr><tr><td>\n</td><td>ASCII Linefeed</td></tr><tr><td>\N{name}</td><td>Unicode 数据库中的字符名</td></tr><tr><td>\r ASCII</td><td>Carriage Return</td></tr><tr><td>\t ASCII</td><td>Horizontal Tab</td></tr><tr><td>\uxxxx</td><td>值为16位十六进制值xxxx的字符</td></tr><tr><td>\Uxxxxxxxx</td><td>值为32位十六进制值xxxx的字符</td></tr><tr><td>\v</td><td>ASCII Vertical Tab</td></tr><tr><td>\ooo</td><td>值为八进制值ooo的字符</td></tr><tr><td>\xhh</td><td>值为十六进制数hh的字符</td></tr></tbody></table><p>triple-quotes “”” 你可以在一组三引号之间放入任意多行文字</p><p>input() 返回<code>str</code>字符串</p><p>打印出来的字符串前面有个 u，如 u‘35’ ：它表示字符串是unicode，使用%s就能正常</p><p>#参数、解包、变量<br><code>from sys import argv</code> import:将python的功能（模组）引入脚本 argv：argument variable参数变量，包含了你传递给Python的参数</p><p><code>a,b,c,d = argv</code>unpack将argv解包，将每个参数赋予一个变量名。</p><p><code>python file.py A B C D</code>运行脚本时传递四个参数</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p><code>name &quot;xxx &quot; is not defined</code> 从后往前读代码，变量是不是没有定义语句</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>open() 默认以read模式打开，只有特别指定后才会进行写入操作</p><p><code>open(filename, &#39;w&#39;/&#39;r&#39;/&#39;a&#39;/&#39;w+&#39;/&#39;r+&#39;/&#39;a+&#39;)</code>+ 修饰符表示文件可以同时以读写的方式打开</p><h1 id="from-os-path-import-exists"><a href="#from-os-path-import-exists" class="headerlink" title="from os.path import exists"></a><code>from os.path import exists</code></h1><p><code>exists</code>命令将文件名字符串作为参数，文件存在返回True，否则返回False</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p><code>is</code>用于判断变量是否为<code>None</code>值</p><p><code>and or</code>用于布尔值的逻辑和、逻辑与运算</p><p><code>+= -=</code> 用于增加/减少运算</p><p>缩进表示一个代码块的开始，逆缩进表示一个代码块的结束</p><p>声明以冒号：字符结束，并且开启一个缩进级别</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><p>Number 数字，可以是整数或浮点数</p></li><li><p>String 字符串，不可变对象</p></li><li><p>None，没有意义，代表某些初始状态</p></li><li><p>tuple 元组，通过<code>( )</code>创建，一旦初始化不能修改，只有一个元素的tuple定义时加一个逗号消除歧义</p></li><li><p>list 列表，通过<code>[ ]</code>创建</p><ul><li>索引从0开始</li><li>list[-1] 获取最后一个元素</li><li>list.append(‘x’) 在其尾部追加元素</li><li>list.insert(n,’x’) 元素插入到指定位置</li><li>list.pop() 删除末尾元素；list.pop(n) 删除指定位置元素</li></ul></li><li><p>dict 字典，通过<code>{key:value}</code>创建，代表键值对，即哈希表。可以通过 <code>keys</code>方法返回所有的键</p><ul><li>dict速度快但占用空间大</li><li>dict 的 key 必须是<strong>不可变对象</strong>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</li></ul></li><li><p>set 一组key的无序集合，通过<code>{1,2}</code>形式创建，不包含重复元素，通过<code>in</code>关键字判断集合是否存在某个元素</p><ul><li><code>s.add(key)</code></li><li><code>s.remove(key)</code></li></ul><h2 id="不变对象和可变对象"><a href="#不变对象和可变对象" class="headerlink" title="不变对象和可变对象"></a>不变对象和可变对象</h2><p>不变对象<code>str</code>、<code>None</code>一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>当我们写 <code>a=&#39;ABC&#39;</code>时，解释器：</p><ol><li><p>在内存中创建了一个<code>&#39;ABC&#39;</code>的字符串；</p></li><li><p>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>&#39;ABC&#39;</code>。</p></li></ol><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>Python的两种除法</p><p><code>`</code>&gt;&gt;&gt; 10/3</p><blockquote><blockquote><blockquote><p>10/3 计算结果是浮点数<br>3.3333333333333335<br>9/3<br>3.0</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>10//3 地板除的结果是整数<br>3<br><code>`</code></p></blockquote></blockquote></blockquote><h1 id="函数：最基本的一种代码抽象的方式"><a href="#函数：最基本的一种代码抽象的方式" class="headerlink" title="函数：最基本的一种代码抽象的方式"></a>函数：最基本的一种代码抽象的方式</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p><code>def function(x):</code></p><p><code>return y</code></p><p><code>lambda</code>定义匿名函数</p><p>内置函数 <a href="http://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">http://docs.python.org/3/library/functions.html</a></p><p>Python的函数返回多值其实就是返回一个tuple</p><p><code>instance(object,type) type: int list float tuple dict</code> 返回布尔值</p><p>##空函数：</p><pre><code>def nop():
    pass # pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来
</code></pre><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><pre><code>&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float(&#39;12.34&#39;)
12.34
&gt;&gt;&gt; str(1.23)
&#39;1.23&#39;
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(&#39;&#39;)
False
&gt;&gt;&gt; a = abs # 变量a指向abs函数，函数名是指向函数对象的引用，把函数名赋给一个变量，相当于起了一个别名
&gt;&gt;&gt; a(-1) #通过a调用abs函数
1
</code></pre><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="默认参数-power-x-n-2-必须指向不变对象"><a href="#默认参数-power-x-n-2-必须指向不变对象" class="headerlink" title="默认参数 power(x,n=2)必须指向不变对象"></a>默认参数 <code>power(x,n=2)</code>必须指向不变对象</h3><ul><li>必选参数在前，默认参数在后</li><li>如何设置默认参数：变化大的参数放前，变化小的参数放后，变化小的参数可作为默认参数</li></ul><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数<code>*args</code>接收到的是一个tuple，调用函数时，可以传入任意或0个参数</p><pre><code>def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n*n
    return sum
&gt;&gt;&gt; calc(1,2)
5
&gt;&gt;&gt; calc()
0
&gt;&gt;&gt; nums = [1,2,3]
&gt;&gt;&gt; calc(*nums) #Python允许在list/tuple前加*号，把list/tuple的元素变成可变参数
14
</code></pre><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code></p><pre><code>def person(name,age,**kw):
    print(&#39;name:&#39;,name,&#39;age:&#39;,age,&#39;other:&#39;,kw)
&gt;&gt;&gt; person(&#39;Michael&#39;,30)
name:Michael age:30 other:{}
&gt;&gt;&gt; person(&#39;Adam&#39;,45,gender=&#39;M&#39;,job=&#39;Engineer&#39;)
name:Adam age:45 other:{&#39;gender:&#39;M&#39;,&#39;job&#39;:&#39;Engineer&#39;}
</code></pre><h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><pre><code>def f1(a,b,c=0,*args,**kw):
    print(&#39;a=&#39;,a,&#39;b=&#39;,b,&#39;c=&#39;,c,&#39;args=&#39;,args,&#39;kw=&#39;,kw)
def f2(a,b,c=0,*,d,**kw):
    print(&#39;a=&#39;,a,&#39;b=&#39;,b,&#39;c=&#39;,c,&#39;d=&#39;,d,&#39;kw=&#39;,kw)
&gt;&gt;&gt; f1(1,2)
a=1 b=2 c=0 args=() kw={}
&gt;&gt;&gt; f1(1,2,c=3)
a=1 b=2 c=3 args=() kw={}
&gt;&gt;&gt; f1(1,2,3,&#39;a&#39;,&#39;b&#39;)
a=1,b=2,c=3 args=(&#39;a&#39;,&#39;b&#39;) kw={}
&gt;&gt;&gt; f2(1,2,3,&#39;a&#39;,&#39;b&#39;,x=99)
a=1,b=2,c=3,args=(&#39;a&#39;,&#39;b&#39;) kw={&#39;x&#39;:99}
&gt;&gt;&gt; f2(1,2,d=99,ext=None)
a=1 b=2 c=0 d=99 kw={&#39;ext&#39;:None}
&gt;&gt;&gt; args=(1,2,3,4)
&gt;&gt;&gt; kw={&#39;d&#39;:99,&#39;x&#39;:&#39;#&#39;}
&gt;&gt;&gt;f1(*args,**kw)
a=1 b=2=c=3 args=(4,) kw={&#39;d&#39;:99,&#39;x&#39;:&#39;#&#39;}
&gt;&gt;&gt; args=(1,2,3)
&gt;&gt;&gt; kw={&#39;d&#39;:88,&#39;x&#39;=&#39;#&#39;}
&gt;&gt;&gt; f2(*args,**kw)
a=1 b=2 c=3 d=88 kw={&#39;x&#39;:&#39;#
</code></pre><h3 id="参数检查-isinstance"><a href="#参数检查-isinstance" class="headerlink" title="参数检查 isinstance()"></a>参数检查 <code>isinstance()</code></h3><pre><code>def my_abs(x):
    if not isinstance(x, (int,float)):
        raise TypeError(&#39;bad operand type&#39;)
    if x&gt;=0:
        return x
    else:
        return -x
</code></pre><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><pre><code>def fact(n)
    if n==1:
        return 1
    return n*fact(n-1)
</code></pre><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><p><code>class</code>定义类，通过类可以生成对象实例，类中一般有<code>__init__</code>初始化方法和实例方法，参数<code>self</code>代表实例自己，<code>@property</code>属性装饰器可以使得函数像属性一样被访问</p><h1 id="Python3-JSON-数据解析"><a href="#Python3-JSON-数据解析" class="headerlink" title="Python3 JSON 数据解析"></a>Python3 JSON 数据解析</h1><p><code>json.dumps()</code>对数据编码</p><p><code>json.loads()</code>对数据解码</p><table><thead><tr><th>JSON</th><th>Python</th></tr></thead><tbody><tr><td>object</td><td>dict</td></tr><tr><td>array</td><td>list</td></tr><tr><td>string</td><td>str</td></tr><tr><td>number(int)</td><td>int</td></tr><tr><td>number(real)</td><td>float</td></tr><tr><td>true</td><td>True</td></tr><tr><td>false</td><td>False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><table><thead><tr><th>字符</th><th>ASCII</th><th>Unicode</th><th>UTF-8</th></tr></thead><tbody><tr><td>A</td><td>01000001</td><td>00000000 01000001</td><td>01000001</td></tr><tr><td>中</td><td></td><td>01001110 00101101</td><td>11100100 10111000 10101101</td></tr></tbody></table><p>Unicode：所有语言统一，最常用的两个字节表示一个字符</p><p>UTF-8: 可变长编码，英文字母1个字节，汉字通常3个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码</p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</p><p>当Python源代码中包含中文的时候，就需要务必指定保存为UTF-8编码。</p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f %.1f：保留小数点后1位</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><p>如果字符串里面的<code>%</code>是一个普通字符，那就需要转义，用<code>%%</code>来表示一个<code>%</code></p><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><pre><code>if&lt;判断1&gt;:
    &lt;执行1&gt;
elif&lt;判断2&gt;:
    &lt;执行2&gt;
elif&lt;判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</code></pre><p><code>if</code>语句从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p><code>for x in [...]/range(n):</code></p><p><code>while ... :</code>只要条件满足，就不断循环，条件不满足时退出循环</p><p><code>break</code>提前结束循环</p><p><code>continue</code> 跳过这次循环，直接开始下一次循环</p><p><em>特别注意</em>，不要滥用<code>break</code>和<code>continue</code>语句。<code>break</code>和<code>continue</code>会造成代码执行逻辑分叉过多，容易出错。</p><h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h2><p>取一个list/tuple部分元素</p><pre><code>&gt;&gt;&gt; L = [&#39;Michael&#39;,&#39;Sarah&#39;,&#39;Tracy&#39;,&#39;Bob&#39;,&#39;Jack&#39;] 
&gt;&gt;&gt; L[0:3] # 从索引 0 开始取到 3，但不包括 3，即索引0，1，2
[&#39;Machael&#39;,&#39;Sarah&#39;,&#39;Tracy]
&gt;&gt;&gt; L[-2:]
[&#39;Bob&#39;,&#39;Jack&#39;]
&gt;&gt;&gt; L[-2:-1] #倒数第一个元素的索引为 -1
[&#39;Bob&#39;]

&gt;&gt;&gt; L=list(range(100))
&gt;&gt;&gt; L
[0,1,2,3,...99]
&gt;&gt;&gt; L[:10]
[0,1,2,3,4,5,6,7,8,9]
&gt;&gt;&gt; L[-10:]
[90,91,92,93,94,95,96,97,98,99]
&gt;&gt;&gt; L[:10:2]
[0,2,4,6,8]
&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]

</code></pre><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个list或tuple，我们可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p><p>在Python中，迭代通过<code>for ... in</code>完成，且不仅用在list/tuple上，还可以作用在其他迭代对象。</p><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p><p>字符串：</p><pre><code>&gt;&gt;&gt; for ch in &#39;ABC&#39;:
...     print(ch)
...
A
B
C
</code></pre><p>如何判断一个对象是可迭代对象?通过<code>collections</code>模块的<code>Iterable</code>类型判断</p><pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance([1,2,3], Iterable)
True
&gt;&gt;&gt; isinstance(123, Iterable)
False
</code></pre><p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p><pre><code>&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]):
...     print(i,value)
...
0 A
1 B
2 C
</code></pre><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><pre><code>&gt;&gt;&gt; list(range(1,11))
[1,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; [x*x for x in range(1,11)]
[1,4,9,16,25,36,49,64,81,100]
&gt;&gt;&gt; [x*x for x in range(1,11) if x%2 ==0]
[4,16,36,64,100]
&gt;&gt;&gt; [m+n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]
</code></pre><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; [d for d in os.listdir(&#39;.&#39;)]
[&#39;.emacs.d&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;Adlm&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, &#39;Documents&#39;, &#39;Downloads&#39;, &#39;Library&#39;, &#39;Movies&#39;, &#39;Music&#39;, &#39;Pictures&#39;, &#39;Public&#39;, &#39;VirtualBox VMs&#39;, &#39;Workspace&#39;, &#39;XCode&#39;]
</code></pre><p><code>for</code>循环可以同时使用多个变量</p><pre><code>&gt;&gt;&gt; d = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }
&gt;&gt;&gt; for k, v in d.items():
...     print(k, &#39;=&#39;, v)
...
y = B
x = A
z = C
</code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><pre><code>&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
</code></pre><p>著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        print(b)
        a,b = b,a + b
        n = n + 1
    return &#39;done&#39;
</code></pre><p>其中，赋值语句</p><p><code>a,b = b,a + b</code></p><p>相当于：</p><pre><code>t = (b, a + b) # t是一个tuple
a = t[0]
b = t[1]
</code></pre><p><code>fib</code>函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p><p>要把<code>fib</code>函数变成generator，只需要把<code>print(b)</code>改为<code>yield b</code>就可以了：</p><pre><code>def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return &#39;done&#39;
</code></pre><p>这就是定义generator的另一种方法。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator:</p><pre><code>&gt;&gt;&gt; f = fib(6)
&gt;&gt;&gt; f #普通函数调用直接返回结果,generator“调用”实际返回一个generator对象
&lt;generator object fib at 0x104feaaa0&gt;
</code></pre><p>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>同样的，把函数改成generator后，我们基本上从来不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for</code>循环来迭代：</p><pre><code>&gt;&gt;&gt; for n in fib(6):
...     print(n)
...
1
1
2
3
5
8
</code></pre><p>但是用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p><pre><code>&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print(&#39;g:&#39;, x)
...     except StopIteration as e:
...         print(&#39;Generator return value:&#39;, e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
</code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter(&#39;abc&#39;), Iterator)
True
</code></pre><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p><pre><code>for x in [1, 2, 3, 4, 5]:
    pass
</code></pre><p>实际上完全等价于：</p><pre><code># 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="变量指向函数"><a href="#变量指向函数" class="headerlink" title="变量指向函数"></a>变量指向函数</h3><p>函数名也是对象</p><pre><code>&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f(-10)
10
</code></pre><h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</p><pre><code>def add(x, y, f):
    return f(x) + f(y)
</code></pre><p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code></p><h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h2><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><p>举例说明，比如我们有一个函数f(x)=x^2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p><pre class="line-numbers language-ascii"><code class="language-ascii">             f(x) = x * x
                  │
  ┌───┬───┬───┬───┼───┬───┬───┬───┐
  ▼  ▼  ▼   ▼  ▼  ▼   ▼  ▼  ▼
[ 1   2   3   4   5   6   7   8   9 ]
  ▼  ▼  ▼   ▼  ▼  ▼   ▼  ▼  ▼
[ 1   4   9  16  25  36  49  64  81 ]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python代码实现：</p><pre><code>&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre><p><code>map()</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p><p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p><pre><code>&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
</code></pre><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><p><strong><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></strong></p><p>字符串<code>str</code>也是一个序列，配合<code>map()</code>，可以写出把<code>str</code>转换为<code>int</code>的函数：</p><pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; def char2num(s):
...     digits = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}
...     return digits[s]
...
&gt;&gt;&gt; reduce(fn, map(char2num, &#39;13579&#39;))
13579
</code></pre><p>整理成一个<code>str2int</code>的函数就是：</p><pre><code>from functools import reduce

DIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
</code></pre><p>还可以用lambda函数进一步简化成：</p><pre><code>from functools import reduce

DIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p><pre><code>def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) 
# 结果: [1, 5, 9, 15]
</code></pre><p>把一个序列中的空字符串删掉，可以这么写：</p><pre><code>def not_empty(s):
    return s and s.strip()

list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))
# 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
</code></pre><h4 id="filter求素数"><a href="#filter求素数" class="headerlink" title="filter求素数"></a>filter求素数</h4><p>先构造一个从<code>3</code>开始的奇数序列：</p><pre><code>def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
</code></pre><p>注意这是一个生成器，并且是一个无限序列。</p><p>然后定义一个筛选函数：</p><pre><code>def _not_divisible(n):
    return lambda x: x % n &gt; 0
</code></pre><p>最后，定义一个生成器，不断返回下一个素数：</p><pre><code>def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
</code></pre><p>由于<code>primes()</code>也是一个无限序列，所以调用时需要设置一个退出循环的条件</p><pre><code># 打印1000以内的素数:
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p><p>Python内置的<code>sorted()</code>函数就可以对list进行排序：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
</code></pre><p>此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p><p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p><p>这样，我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p><pre><code>&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)
[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]
</code></pre><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><pre><code>&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)
[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]
</code></pre><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><pre><code>def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><pre><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre><p>调用函数<code>f</code>时，才真正计算求和的结果：</p><pre><code>&gt;&gt;&gt; f()
25
</code></pre><p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code>def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9
</code></pre><p>全部都是<code>9</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p><p><strong>返回闭包时牢记一点：返回一个函数时，该函数并未执行，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p><p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><pre><code>def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre><p>再看看结果：</p><pre><code>&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9
</code></pre><p>缺点是代码较长，可利用lambda函数缩短代码。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p><p>匿名函数<code>lambda x: x * x</code>实际上就是：</p><pre><code>def f(x):
    return x * x
</code></pre><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数只能有一个表达式，返回值就是该表达式的结果。</p><p>匿名函数没有名字，不必担心函数名冲突。匿名函数也是一个函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><pre><code>&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
&gt;&gt;&gt; f(5)
25
</code></pre><p>同样，也可以把匿名函数作为返回值返回，比如：</p><pre><code>def build(x, y):
    return lambda: x * x + y * y
</code></pre><h2 id="装饰器-Decorator"><a href="#装饰器-Decorator" class="headerlink" title="装饰器 Decorator"></a>装饰器 Decorator</h2><p>装饰器本质上是一个返回函数的高阶函数，它可以让其他函数在不需要修改的前提下增加额外功能，装饰器的返回值也是一个函数。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的代码并重用。</p><p>装饰器使用如此方便归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p><p>定义一个能打印日志的decorator：</p><pre><code>import functools
def log(func):
    @functools.wraps(func) # 把原函数的元信息拷贝到装饰器里面的func 函数中，解决函数签名等问题
    def wrapper(*args, **kw): # 业务函数func()的参数通过wrapper()传递
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw) # 返回业务函数
    return wrapper # 返回包装函数
</code></pre><pre><code>@log # @log 是 now = log(now) 的缩写，业务函数作为参数被包裹在装饰器内
def now():
    print(&#39;2015-3-25&#39;)
</code></pre><pre><code>&gt;&gt;&gt; now() # 调用包装后的业务函数，相当于调用 log(now)
call now():
2015-3-25
</code></pre><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><pre><code>import functools
def log(text): #对原有装饰器的函数封装并返回装饰器，理解为一个含参的闭包。@log(text)等价于@decorator
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的<code>__call__</code>方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p><h3 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h3><p>一个函数还可以同时定义多个装饰器：</p><pre><code>@a
@b
@c
def f ():
    pass
</code></pre><p>等效于:<code>f = a(b(c(f)))</code></p><h3 id="装饰方法"><a href="#装饰方法" class="headerlink" title="装饰方法"></a>装饰方法</h3><p>在Python中, 方法(method)和函数(function)实际是一样的. 唯一的区别, 方法的第一个参数需要是当前对象(<code>self</code>)的引用。你可以用同样的方式创建方法的装饰器! 不过, 别忘了<code>self</code>.</p><p>如果要写一个通用的装饰器–可用于任何函数或方法, 而不必考虑其参数–那么, 用<code>*args, **kwargs</code></p><h2 id="偏函数Partial-function"><a href="#偏函数Partial-function" class="headerlink" title="偏函数Partial function"></a>偏函数Partial function</h2><p><code>int()</code>函数提供额外的<code>base</code>参数，默认值为<code>10</code>。传入<code>base</code>参数，就可以做N进制的转换。假设要转换大量的二进制字符串，每次都传入<code>int(x, base=2)</code>非常麻烦，于是可以定义一个<code>int2()</code>的函数，默认把<code>base=2</code>传进去，<code>functools.partial</code>帮助我们创建一个偏函数，不需要自己定义，可以直接创建一个新的函数<code>int2</code>：</p><pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&#39;1000000&#39;)
64
&gt;&gt;&gt; int2(&#39;1010101&#39;)
85
</code></pre><p>偏函数的作用就是，把函数的某些参数给固定住（设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>偏函数可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数：</p><pre><code>int2(&#39;10010&#39;)
</code></pre><p>相当于</p><pre><code>kw = { &#39;base&#39;: 2 }
int(&#39;10010&#39;, **kw)
</code></pre><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块的好处是大大提高了代码的可维护性，使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。但是尽量不要与内置函数名冲突。</p><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><p>假设<code>abc</code>和<code>xyz</code>这两个模块名与其他模块冲突了，可以选择一个顶层包名，比如<code>mycompany</code>，按照如下目录存放：</p><pre class="line-numbers language-ascii"><code class="language-ascii">mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引入了包以后，只要顶层的包名不冲突，那所有模块都不会冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code></p><p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，是必须存在的，否则，Python就把这个目录当成普通目录。<code>__init__.py</code>可以是空文件，也可以有代码，<code>__init__.py</code>本身就是一个模块，它的模块名就是<code>mycompany</code>。</p><p>类似有多级目录，组成多级层次的包结构：</p><pre class="line-numbers language-ascii"><code class="language-ascii">mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ xyz.py
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p><p>面向对象的设计思想是抽象出Class，根据Class创建Instance。</p><p>数据封装、继承和多态是面向对象的三大特点</p><h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><pre><code>class Student(object):
    pass
</code></pre><p>类名通常是大写开头的单词，<code>(object)</code>表示从哪个类继承下来，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终继承的类。</p><pre><code>&gt;&gt;&gt; bart = Student()
&gt;&gt;&gt; bart.name = &#39;Bart Simpson&#39; #可以自由地给一个实例变量绑定属性
</code></pre><p>类可以起到模板的作用，通过定义一个特殊的<code>__init__</code>方法，把<code>name</code>，<code>score</code>等必要的属性绑上去：</p><pre><code>class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
</code></pre><p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身</p><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>在<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>数据，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><pre><code>class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))

&gt;&gt;&gt; bart.print_score()
Bart Simpson: 59
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p><p>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p><p>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。</p><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同</p><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private）</p><p>如果外部代码要获取name和score怎么办？可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p><pre><code>class Student(object):
    ...
    def get_name(self):
        return self.__name
    def get_score(self):
        return self.__score
</code></pre><p>如果又要允许外部代码修改score怎么办？可以再给Student类增加<code>set_score</code>方法：</p><pre><code>class Student(object):
    ...
    def set_score(self, score):
        self.__score = score
</code></pre><p> 在这样的方法中，可以对参数做检查，避免传入无效的参数：</p><pre><code>class Student(object):
    ...
    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError(&#39;bad score&#39;)
</code></pre><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>当子类和父类都存在相同的方法时，我们说，子类的方法覆盖了父类的方法，在代码运行的时候，总是会调用子类的方法。这样，我们就获得了继承的另一个好处：多态。</p><p>当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><pre><code>a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
</code></pre><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断</p><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是其父类。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>…时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>…都是<code>Animal</code>类型，然后按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如 Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><pre><code>class Timer(object):
    def run(self):
        print(&#39;Start...&#39;)
</code></pre><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type-返回对象类型"><a href="#使用type-返回对象类型" class="headerlink" title="使用type()返回对象类型"></a>使用type()返回对象类型</h3><pre><code>&gt;&gt;&gt; type(123)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; type(&#39;str&#39;)
&lt;class &#39;str&#39;&gt;
&gt;&gt;&gt; type(abs)
&lt;class &#39;builtin_function_or_method&#39;&gt;
&gt;&gt;&gt; type(a)
&lt;class &#39;__main__.Animal&#39;&gt;
</code></pre><h3 id="使用isinstance-判断class的类型"><a href="#使用isinstance-判断class的类型" class="headerlink" title="使用isinstance()判断class的类型"></a>使用isinstance()判断class的类型</h3><pre><code>&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; isinstance(d, Dog)
True
</code></pre><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断</p><h3 id="使用dir-获得一个对象的所有属性和方法"><a href="#使用dir-获得一个对象的所有属性和方法" class="headerlink" title="使用dir()获得一个对象的所有属性和方法"></a>使用dir()获得一个对象的所有属性和方法</h3><p>dir() 返回一个包含字符串的list</p><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><pre><code>&gt;&gt;&gt; len(&#39;ABC&#39;)
3
&gt;&gt;&gt; &#39;ABC&#39;.__len__()
3
</code></pre><p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p><pre><code>&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):
...         return 100
...
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; len(dog)
100
</code></pre><p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p><pre><code>&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
&gt;&gt;&gt; obj = MyObject()
</code></pre><p>紧接着，可以测试该对象的属性：</p><pre><code>&gt;&gt;&gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
False
&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;
&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
True
&gt;&gt;&gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;
19
&gt;&gt;&gt; obj.y # 获取属性&#39;y&#39;
19
</code></pre><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>Python是动态语言，根据类创建的实例可以任意绑定属性。</p><p>给实例绑定属性的方法是通过实例变量，或<code>self</code>变量：</p><pre><code>class Student(object):
    def __init__(self, name): #self变量
        self.name = name

s = Student(&#39;Bob&#39;)
s.score = 90 #实例变量
</code></pre><p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p><pre><code>class Student(object):
    name = &#39;Student&#39;
</code></pre><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到：</p><pre><code>&gt;&gt;&gt; class Student(object):
...     name = &#39;Student&#39;
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre><p>可以看出，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用__slots__"></a>使用__slots__</h2><pre><code>class Student(object):
    pass
s = Student()
</code></pre><p>尝试给实例绑定一个方法：</p><pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
&gt;&gt;&gt; s.set_age(25) # 调用实例方法
&gt;&gt;&gt; s.age # 测试结果
25
</code></pre><p>但是，给一个实例绑定的方法，对另一个实例是不起作用，为了给所有实例都绑定方法，可以给class绑定方法：</p><pre><code>&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score
</code></pre><p>通常情况下，上面的<code>set_score</code>方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能。</p><p>如果想要限制实例的属性怎么办？比如，只允许对Student实例添加<code>name</code>和<code>age</code>属性。</p><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p><pre><code>class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称
</code></pre><p><code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类不起作用</p><h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>为了限制score的范围，可以通过一个<code>set_score()</code>方法来设置成绩，再通过一个<code>get_score()</code>来获取成绩。这种调用方法略显复杂，没有直接用属性这么直接简单。</p><p>装饰器（decorator）可以给函数动态加上功能，对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p><pre><code>class Student(object):
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value
</code></pre><pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
</code></pre><p><code>@property</code>广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>通过多重继承，一个子类就可以同时获得多个父类的所有功能</p><pre><code>class Bat(Mammal, Flyable):
    pass
</code></pre><h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为MixIn，目的就是给一个类增加多个功能。</p><p>Python自带的很多库也使用了MixIn。举个例子，Python自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p><p>比如，编写一个多进程模式的TCP服务，定义如下：</p><pre><code>class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre><p>编写一个多线程模式的UDP服务，定义如下：</p><pre><code>class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre><p>如果你打算搞一个更先进的协程模型，可以编写一个<code>CoroutineMixIn</code>：</p><pre><code>class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre><p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>形如<code>__xxx__</code>的变量或者函数名，在Python中有特殊用途，如<code>__len__()</code>方法是为了能让class作用于<code>len()</code>函数</p><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><pre><code>&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return &#39;Student object (name: %s)&#39; % self.name
...
&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
Student object (name: Michael) #返回一个定制的实例，而不是打印出一串内存地址
</code></pre><pre><code>&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre><p>因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，<code>__repr__()</code>为调试服务。</p><pre><code>class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__
</code></pre><p>###__iter__</p><p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p><p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p><pre><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre><p>现在，试试把Fib实例作用于for循环：</p><pre><code>&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
</code></pre><h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p>要让Fib实例表现得像list那样按照下标取出元素，需要<code>__getitem__()</code>方法：</p><pre><code>class Fib(object):
    def __getitem__(self, n): #传入的参数可能是int，也可能是切片对象slice，要做判断
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会抛出 AttributeError ,并调用到<code>__getattr__()</code>方法，动态返回一个属性：</p><pre><code>class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99 #__getattr__默认返回None
</code></pre><p>实际上可以把一个类的所有属性和方法调用全部动态化处理，作用就是，可以针对完全动态的情况作调用。</p><p>现在很多网站都搞REST API，比如新浪微博、豆瓣，调用API的URL类似：</p><ul><li><a href="http://api.server/user/friends" target="_blank" rel="noopener">http://api.server/user/friends</a></li><li><a href="http://api.server/user/timeline/list" target="_blank" rel="noopener">http://api.server/user/timeline/list</a></li></ul><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p><p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p><pre><code>class Chain(object):

    def __init__(self, path=&#39;&#39;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path)) #要实现链式调用，最重要的就是每一个调用都是返回一个实例

    def __str__(self):
        return self._path

    __repr__ = __str__
</code></pre><p>试试：</p><pre><code>&gt;&gt;&gt; Chain().status.user.timeline.list
&#39;/status/user/timeline/list&#39;
</code></pre><p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p><p>还有些REST API会把参数放到URL中，比如GitHub的API：</p><pre><code>GET /users/:user/repos
</code></pre><p>调用时，需要把<code>:user</code>替换为实际用户名。如果我们能写出这样的链式调用：</p><pre><code>Chain().users(&#39;michael&#39;).repos
</code></pre><p>就可以非常方便地调用API了。</p><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>我们可以用<code>instance.method()</code>来调用实例方法，能不能直接在实例本身上调用呢？</p><p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用</p><pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&#39;My name is %s.&#39; % self.name)
</code></pre><p>调用方式如下：</p><pre><code>&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.
</code></pre><p><code>_call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象。那么，怎么判断一个变量是对象还是函数呢？更多的时候，我们需要通过<code>callable()</code>函数判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象</p><h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p>定义常量，好的方法是为这样的枚举类型定义一个class类型，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p><pre><code>from enum import Enum

Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))
</code></pre><p>可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p><pre><code>for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)
</code></pre><p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p><p><code>Enum</code>可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。</p><h2 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h2><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p><code>type()</code>函数可以查看一个类型或变量的类型，class的定义是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数。</p><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出<code>Hello</code>类，而无需通过<code>class Hello(object)...</code>的定义：</p><pre><code>&gt;&gt;&gt; def fn(self, name=&#39;world&#39;): # 先定义函数
...     print(&#39;Hello, %s.&#39; % name)
...
&gt;&gt;&gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; print(type(h))
&lt;class &#39;__main__.Hello&#39;&gt;
</code></pre><p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p><ol><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li></ol><h3 id="metaclass-元类"><a href="#metaclass-元类" class="headerlink" title="metaclass 元类"></a>metaclass 元类</h3><p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p><p>先定义metaclass，就可以创建类，最后创建实例。metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p><h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><pre><code>try:
    print(&#39;try...&#39;)
    r = 10 / 0
    print(&#39;result:&#39;, r)
except ZeroDivisionError as e:
    print(&#39;except:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
</code></pre><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p><p>错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。没错，可以有多个<code>except</code>来捕获不同类型的错误：</p><pre><code>try:
    print(&#39;try...&#39;)
    r = 10 / int(&#39;a&#39;)
    print(&#39;result:&#39;, r)
except ValueError as e:
    print(&#39;ValueError:&#39;, e)
except ZeroDivisionError as e:
    print(&#39;ZeroDivisionError:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
</code></pre><p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p><pre><code>try:
    foo()
except ValueError as e:
    print(&#39;ValueError&#39;)
except UnicodeError as e:
    print(&#39;UnicodeError&#39;)
</code></pre><p>第二个<code>except</code>永远也捕获不到<code>UnicodeError</code>，因为<code>UnicodeError</code>是<code>ValueError</code>的子类，如果有，也被第一个<code>except</code>给捕获了。</p><p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p><p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p><pre><code>def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except Exception as e:
        print(&#39;Error:&#39;, e)
    finally:
        print(&#39;finally...&#39;)
</code></pre><p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p><h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p><pre><code># err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except Exception as e:
        logging.exception(e)

main()
print(&#39;END&#39;) #同样是出错，但程序打印完错误信息后会继续执行，并正常退出
</code></pre><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例。</p><p>最后，我们来看另一种错误处理的方式：</p><pre><code># err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError(&#39;invalid value: %s&#39; % s)
    return 10 / n

def bar():
    try:
        foo(&#39;0&#39;)
    except ValueError as e:
        print(&#39;ValueError!&#39;)
        raise

bar()
</code></pre><p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去了，这不有病么？</p><p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>第一种方法简单直接粗暴有效，就是用<code>print()</code>把可能有问题的变量打印出来看看，但是运行结果会包含垃圾信息</p><h3 id="断言-assert"><a href="#断言-assert" class="headerlink" title="断言 assert"></a>断言 assert</h3><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：</p><pre><code>def foo(s):
    n = int(s)
    assert n != 0, &#39;n is zero!&#39;
    return 10 / n

def main():
    foo(&#39;0&#39;)
</code></pre><p>启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code></p><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p><pre><code>import logging

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print(10 / n)
</code></pre><p>在<code>import logging</code>之后添加一行配置再试试：</p><pre><code>import logging
logging.basicConfig(level=logging.INFO)
</code></pre><p>看到输出了：</p><pre><code>$ python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre><p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p><pre><code># err.py
s = &#39;0&#39;
n = int(s)
print(10 / n)
</code></pre><p>然后启动：</p><pre><code>$ python -m pdb err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()
-&gt; s = &#39;0&#39;
</code></pre><p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码<code>-&gt; s = &#39;0&#39;</code>。输入命令<code>l</code>来查看代码：</p><pre><code>(Pdb) l
  1     # err.py
  2  -&gt; s = &#39;0&#39;
  3     n = int(s)
  4     print(10 / n)
</code></pre><p>输入命令<code>n</code>可以单步执行代码：</p><pre><code>(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()
-&gt; n = int(s)
(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()
-&gt; print(10 / n)
</code></pre><p>任何时候都可以输入命令<code>p 变量名</code>来查看变量：</p><pre><code>(Pdb) p s
&#39;0&#39;
(Pdb) p n
0
</code></pre><p>输入命令<code>q</code>结束调试，退出程序：</p><pre><code>(Pdb) q
</code></pre><h3 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h3><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><pre><code># err.py
import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)
</code></pre><p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行：</p><pre><code>$ python err.py 
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()
-&gt; print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File &quot;err.py&quot;, line 7, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre><p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p><p>编写一个<code>Dict</code>类，这个类的行为和<code>dict</code>一致，但是可以通过属性来访问，用起来就像下面这样：</p><pre><code>&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d.a
1
</code></pre><p><code>mydict.py</code>代码如下：</p><pre><code>class Dict(dict):

    def __init__(self, **kw):
        super().__init__(**kw) #super()用于调用父类/超类

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value
</code></pre><p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p><pre><code>import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEqual(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty
</code></pre><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p><p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEqual()</code>：</p><pre><code>self.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等
</code></pre><p>另一种重要的断言就是期待抛出指定类型的Error，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p><pre><code>with self.assertRaises(KeyError):
    value = d[&#39;empty&#39;]
</code></pre><p>而通过<code>d.empty</code>访问不存在的key时，我们期待抛出<code>AttributeError</code>：</p><pre><code>with self.assertRaises(AttributeError):
    value = d.empty
</code></pre><h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p><pre><code>if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre><p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p><pre><code>$ python mydict_test.py
</code></pre><p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p><pre><code>$ python -m unittest mydict_test
.....
----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK
</code></pre><p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p><h3 id="setUp-tearDown"><a href="#setUp-tearDown" class="headerlink" title="setUp/tearDown"></a>setUp/tearDown</h3><p>设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p><pre><code>class TestDict(unittest.TestCase):

    def setUp(self):
        print(&#39;setUp...&#39;)

    def tearDown(self):
        print(&#39;tearDown...&#39;)
</code></pre><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用<code>...</code>表示中间一大段烦人的输出。</p><p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p><pre><code># mydict2.py
class Dict(dict):
    &#39;&#39;&#39;
    Simple dict but also support access as x.y style.

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    &#39;&#39;&#39;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__==&#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre><h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p><p>同步和异步的区别就在于是否等待IO执行的结果。</p><p>使用异步IO编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p><pre><code>with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre><p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p><pre><code>for line in f.readlines():
    print(line.strip()) # 把末尾的&#39;\n&#39;删掉
</code></pre><p>###Python 中的 with 语法：</p><p>with 语句适合于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，如文件使用后自动关闭、线程中锁的自动获取和释放等</p><p><strong>上下文管理协议</strong>：包含方法 <code>__enter__() __exit()__</code>，支持该协议的对象要实现这两个方法</p><p><strong>上下文管理器</strong>：支持上下文管理协议的对象，负责执行 with 语句块上下文中的进入与退出操作</p><p><strong>运行时上下文</strong>：由上下文管理器创建， <code>__enter__()</code>方法在语句体执行之前进入运行时上下文<code>__exit()__</code>在语句体执行完后从运行时上下文退出</p><p><strong>with 语句语法格式</strong>：</p><pre><code>with context_expression [as targets(s)]:
    with-body
</code></pre><p>context_expression返回一个上下文管理器对象，该对象会将上下文管理器的<code>__enter__()</code>方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组。</p><p><strong>with 语句操作文件对象</strong>：</p><pre><code>with open(r&#39;filename&#39;) as file:
    for line in file:
        print line
        # ...more code
</code></pre><p><strong>传统的 try/finally 方式操作文件对象：</strong></p><pre><code>file = open(r&#39;filename&#39;)
try:
    for line in file:
        print line
        # ...more code
finally:
    file.close()
</code></pre><p><strong>with 语句执行过程：</strong></p><pre><code>context_manager = context_expression
exit = type(context_manager).__exit__
value = type(context_manager).__enter__(context_manager)
exc = True  # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理
try:
    try:
        target = value # _enter__()方法的返回值赋值给 as 子句中的 target(s)
        with-body # 执行 with-body
    except:
        # 执行过程中有异常发生
        exc = False
        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常
        # 由外层代码对异常进行处理
        if not exit(context_manager,*sys.exc_info()):
            raise
finally:
    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出
    # 或者忽略异常退出
    if exc:
        exit(context_manager,None,None,None)
    # 缺省返回 None，None 在布尔上下文中看做是 False
</code></pre><p>不管是否执行过程中是否发生了异常，执行上下文管理器的<code>__exit__()</code>方法，<code>__exit__()</code>方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用<code>__exit__(exc_type, exc_value, exc_traceback)</code>，出现异常时，如果 <code>__exit__(type, value, traceback)</code>返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理。</p><h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p><p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>要读取二进制文件，比如图片、视频等等，用<code>&#39;rb&#39;</code>模式打开文件即可：</p><pre><code>&gt;&gt;&gt; f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)
&gt;&gt;&gt; f.read()
b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节
</code></pre><h3 id="字符编码-1"><a href="#字符编码-1" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数。遇到编码不规范的文件，可能会遇到<code>UnicodeDecodeError</code>，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<code>errors=&#39;ignore&#39;</code></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件。你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>close()</code>来关闭文件。</p><pre class="line-numbers language-python"><code class="language-python">txt <span class="token operator">=</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">//</span> open<span class="token punctuation">(</span><span class="token punctuation">)</span>返回一个<span class="token string">"file object"</span>，可以调用该文件对象的各种方法进行读写操作
<span class="token keyword">print</span> txt<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
txt<span class="token punctuation">,</span>write<span class="token punctuation">(</span><span class="token string">'Hello,world!'</span><span class="token punctuation">)</span>
txt<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">//</span>处理完文件后需要将其关闭

<span class="token keyword">with</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> x<span class="token punctuation">:</span> <span class="token operator">//</span>由于文件对象同时也是一个上下文管理器，所以可以通过 <span class="token keyword">with</span> 关键字打开文件，这样当 <span class="token keyword">with</span> 代码块执行完以后，文件对象就会自动关闭，避免忘记关闭文件的情况发生。
    x<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。所以，还是用<code>with</code>语句来得保险。</p><p>以<code>&#39;w&#39;</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>&#39;a&#39;</code>以追加（append）模式写入。</p><h1 id="StringIO-BytesIO"><a href="#StringIO-BytesIO" class="headerlink" title="StringIO/BytesIO"></a>StringIO/BytesIO</h1><h3 id="StringIO-在内存中读写str"><a href="#StringIO-在内存中读写str" class="headerlink" title="StringIO:在内存中读写str"></a>StringIO:在内存中读写str</h3><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p><pre><code>&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; f = StringIO()
&gt;&gt;&gt; f.write(&#39;hello&#39;)
5
&gt;&gt;&gt; f.write(&#39; &#39;)
1
&gt;&gt;&gt; f.write(&#39;world!&#39;)
6
&gt;&gt;&gt; print(f.getvalue()) 
hello world!
</code></pre><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><pre><code>&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; f = StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)
&gt;&gt;&gt; while True:
...     s = f.readline()
...     if s == &#39;&#39;:
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!
</code></pre><h3 id="BytesIO-在内存中读写bytes"><a href="#BytesIO-在内存中读写bytes" class="headerlink" title="BytesIO:在内存中读写bytes"></a>BytesIO:在内存中读写bytes</h3><pre><code>&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO()
&gt;&gt;&gt; f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
&gt;&gt;&gt; print(f.getvalue())
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
</code></pre><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p><h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数</p><p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p><pre><code>import os
# 查看当前目录的绝对路径:
&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)
&#39;/Users/michael&#39;
# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
&gt;&gt;&gt; os.path.join(&#39;/Users/michael&#39;, &#39;testdir&#39;)
&#39;/Users/michael/testdir&#39;
# 然后创建一个目录:
&gt;&gt;&gt; os.mkdir(&#39;/Users/michael/testdir&#39;)
# 删掉一个目录:
&gt;&gt;&gt; os.rmdir(&#39;/Users/michael/testdir&#39;)
# 对文件重命名:
&gt;&gt;&gt; os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)
# 删掉文件:
&gt;&gt;&gt; os.remove(&#39;test.py&#39;)
</code></pre><p><code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p><pre><code>&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
[&#39;.lein&#39;, &#39;.local&#39;, &#39;.m2&#39;, &#39;.npm&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;.vim&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, ...]
</code></pre><p>要列出所有的<code>.py</code>文件，也只需一行代码：</p><pre><code>&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
[&#39;apis.py&#39;, &#39;config.py&#39;, &#39;models.py&#39;, &#39;pymonitor.py&#39;, &#39;test_db.py&#39;, &#39;urls.py&#39;, &#39;wsgiapp.py&#39;]
</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>在程序运行的过程中，所有变量在内存中，定义一个dict：</p><pre><code>d = dict(name=&#39;Bob&#39;, age=20, score=88)
</code></pre><p>比如把<code>name</code>改成<code>&#39;Bill&#39;</code>，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的<code>&#39;Bill&#39;</code>存储到磁盘上，下次重新运行程序，变量又被初始化为<code>&#39;Bob&#39;</code>。</p><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p><p>Python提供了<code>pickle</code>模块来实现序列化。</p><p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object：</p><pre><code>&gt;&gt;&gt; f = open(&#39;dump.txt&#39;, &#39;wb&#39;)
&gt;&gt;&gt; pickle.dump(d, f)
&gt;&gt;&gt; f.close()
</code></pre><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p><pre><code>&gt;&gt;&gt; f = open(&#39;dump.txt&#39;, &#39;rb&#39;)
&gt;&gt;&gt; d = pickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; d
{&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;}
</code></pre><p>这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><table><thead><tr><th>JSON类型</th><th>Python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int/float</td></tr><tr><td>true/false</td><td>True/False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><p>把Python对象变成一个JSON：</p><pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; d = dict(name=&#39;Bob&#39;, age=20, score=88)
&gt;&gt;&gt; json.dumps(d)
&#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
</code></pre><p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的 JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p><p>要把 JSON 反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p><pre><code>&gt;&gt;&gt; json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
&gt;&gt;&gt; json.loads(json_str)
{&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;}
</code></pre><h3 id="JSON-进阶"><a href="#JSON-进阶" class="headerlink" title="JSON 进阶"></a>JSON 进阶</h3><p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p><pre><code>import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;Bob&#39;, 20, 88)
print(json.dumps(s))
</code></pre><p>运行代码，毫不留情地得到一个<code>TypeError</code>，错误的原因是<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p><p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为 JSON 的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p><pre><code>def student2dict(std):
    return {
        &#39;name&#39;: std.name,
        &#39;age&#39;: std.age,
        &#39;score&#39;: std.score
    }
</code></pre><p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为JSON：</p><pre><code>&gt;&gt;&gt; print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre><p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p><pre><code>print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre><p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p><p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p><pre><code>def dict2student(d):
    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])
</code></pre><p>运行结果如下：</p><pre><code>&gt;&gt;&gt; json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre><p>打印出的是反序列化的<code>Student</code>实例对象。</p><p>Python语言特定的序列化模块是<code>pickle</code>，但如果要把序列化搞得更通用、更符合Web标准，就可以使用<code>json</code>模块。</p><p><code>json</code>模块的<code>dumps()</code>和<code>loads()</code>函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>对于操作系统来说，一个任务就是一个进程（Process），有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“线程（Thread）”。</p><p>一个进程至少有一个线程，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p><p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p><p>有两种解决方案：</p><p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p><p>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</p><p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p><p>总结一下就是，多任务的实现有3种方式：</p><ul><li>多进程模式；</li><li>多线程模式；</li><li>多进程+多线程模式。</li></ul><p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，涉及到同步、数据共享的问题，编写起来更复杂。</p><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p><p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p><pre><code>import os

print(&#39;Process (%s) start...&#39; % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))
else:
    print(&#39;I (%s) just created a child process (%s).&#39; % (os.getpid(), pid))
</code></pre><p>运行结果如下：</p><pre><code>Process (876) start...
I (876) just created a child process (877).
I am child process (877) and my parent is 876.
</code></pre><p>有了<code>fork</code>调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p><h2 id="mutiprocessing"><a href="#mutiprocessing" class="headerlink" title="mutiprocessing"></a>mutiprocessing</h2><p><code>multiprocessing</code>模块就是跨平台版本的多进程模块。</p><p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p><pre><code>from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))

if __name__==&#39;__main__&#39;:
    print(&#39;Parent process %s.&#39; % os.getpid())
    p = Process(target=run_proc, args=(&#39;test&#39;,))
    print(&#39;Child process will start.&#39;)
    p.start()
    p.join()
    print(&#39;Child process end.&#39;)
</code></pre><p>执行结果如下：</p><pre><code>Parent process 928.
Process will start.
Run child process test (929)...
Process end.
</code></pre><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p><p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p><pre><code>from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))

if __name__==&#39;__main__&#39;:
    print(&#39;Parent process %s.&#39; % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print(&#39;Waiting for all subprocesses done...&#39;)
    p.close()
    p.join()
    print(&#39;All subprocesses done.&#39;)
</code></pre><p>执行结果如下：</p><pre><code>Parent process 669.
Waiting for all subprocesses done...
Run task 0 (671)...
Run task 1 (672)...
Run task 2 (673)...
Run task 3 (674)...
Task 2 runs 0.14 seconds.
Run task 4 (673)...
Task 1 runs 0.27 seconds.
Task 3 runs 0.86 seconds.
Task 0 runs 1.41 seconds.
Task 4 runs 1.91 seconds.
All subprocesses done.
</code></pre><p>代码解读：</p><p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p><p>请注意输出的结果，task <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task <code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成：</p><pre><code>p = Pool(5)
</code></pre><p>就可以同时跑5个进程。</p><p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p><p>下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p><pre><code>import subprocess

print(&#39;$ nslookup www.python.org&#39;)
r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])
print(&#39;Exit code:&#39;, r)
</code></pre><p>运行结果：</p><pre><code>$ nslookup www.python.org
Server:        192.168.19.4
Address:    192.168.19.4#53

Non-authoritative answer:
www.python.org    canonical name = python.map.fastly.net.
Name:    python.map.fastly.net
Address: 199.27.79.223

Exit code: 0
</code></pre><p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p><pre><code>import subprocess

print(&#39;$ nslookup&#39;)
p = subprocess.Popen([&#39;nslookup&#39;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)
print(output.decode(&#39;utf-8&#39;))
print(&#39;Exit code:&#39;, p.returncode)
</code></pre><p>上面的代码相当于在命令行执行命令<code>nslookup</code>，然后手动输入：</p><pre><code>set q=mx
python.org
exit
</code></pre><p>运行结果如下：</p><pre><code>$ nslookup
Server:        192.168.19.4
Address:    192.168.19.4#53

Non-authoritative answer:
python.org    mail exchanger = 50 mail.python.org.

Authoritative answers can be found from:
mail.python.org    internet address = 82.94.164.166
mail.python.org    has AAAA address 2001:888:2000:d::a6


Exit code: 0
</code></pre><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p><p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p><pre><code>from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)
        print(&#39;Get %s from queue.&#39; % value)

if __name__==&#39;__main__&#39;:
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
</code></pre><p>运行结果如下：</p><pre><code>Process to write: 50563
Put A to queue...
Process to read: 50564
Get A from queue.
Put B to queue...
Get B from queue.
Put C to queue...
Get C from queue.
</code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p><pre><code>import time, threading

# 新线程执行的代码:
def loop():
    print(&#39;thread %s is running...&#39; % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))
        time.sleep(1)
    print(&#39;thread %s ended.&#39; % threading.current_thread().name)

print(&#39;thread %s is running...&#39; % threading.current_thread().name)
t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)
t.start()
t.join()
print(&#39;thread %s ended.&#39; % threading.current_thread().name)
</code></pre><p>执行结果如下：</p><pre><code>thread MainThread is running...
thread LoopThread is running...
thread LoopThread &gt;&gt;&gt; 1
thread LoopThread &gt;&gt;&gt; 2
thread LoopThread &gt;&gt;&gt; 3
thread LoopThread &gt;&gt;&gt; 4
thread LoopThread &gt;&gt;&gt; 5
thread LoopThread ended.
thread MainThread ended.
</code></pre><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p><pre><code>import time, threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
</code></pre><p>我们定义了一个共享变量<code>balance</code>，初始值为<code>0</code>，并且启动两个线程，先存后取，理论上结果应该为<code>0</code>，但是，由于线程的调度是由操作系统决定的，当t1、t2交替执行时，只要循环次数足够多，<code>balance</code>的结果就不一定是<code>0</code>了。</p><p>原因是因为高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算：</p><pre><code>balance = balance + n
</code></pre><p>也分两步：</p><ol><li>计算<code>balance + n</code>，存入临时变量中；</li><li>将临时变量的值赋给<code>balance</code>。</li></ol><p>也就是可以看成：</p><pre><code>x = balance + n
balance = x
</code></pre><p>由于x是局部变量，两个线程各自都有自己的x，当代码正常执行时：</p><pre><code>初始值 balance = 0

t1: x1 = balance + 5 # x1 = 0 + 5 = 5
t1: balance = x1     # balance = 5
t1: x1 = balance - 5 # x1 = 5 - 5 = 0
t1: balance = x1     # balance = 0

t2: x2 = balance + 8 # x2 = 0 + 8 = 8
t2: balance = x2     # balance = 8
t2: x2 = balance - 8 # x2 = 8 - 8 = 0
t2: balance = x2     # balance = 0

结果 balance = 0
</code></pre><p>但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：</p><pre><code>初始值 balance = 0

t1: x1 = balance + 5  # x1 = 0 + 5 = 5

t2: x2 = balance + 8  # x2 = 0 + 8 = 8
t2: balance = x2      # balance = 8

t1: balance = x1      # balance = 5
t1: x1 = balance - 5  # x1 = 5 - 5 = 0
t1: balance = x1      # balance = 0

t2: x2 = balance - 8  # x2 = 0 - 8 = -8
t2: balance = x2   # balance = -8

结果 balance = -8
</code></pre><p>究其原因，是因为修改<code>balance</code>需要多条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把同一个对象的内容改乱了。</p><p>两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以，我们必须确保一个线程在修改<code>balance</code>的时候，别的线程一定不能改。</p><p>如果我们要确保<code>balance</code>计算正确，就要给<code>change_it()</code>上一把锁，当某个线程开始执行<code>change_it()</code>时，我们说，该线程因为获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p><pre><code>balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
</code></pre><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><p>###多核CPU</p><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p><p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p><pre><code>def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)
</code></pre><p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的<code>Student</code>对象，不能共享。</p><p>如果用一个全局<code>dict</code>存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>Student</code>对象如何？</p><pre><code>global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...
</code></pre><p>这种方式理论上是可行的，它最大的优点是消除了<code>std</code>对象在每层函数中的传递问题，但是，每个函数获取<code>std</code>的代码有点丑。</p><p>有没有更简单的方式？</p><p><code>ThreadLocal</code>应运而生，不用查找<code>dict</code>，<code>ThreadLocal</code>帮你自动做这件事：</p><pre><code>import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target= process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre><p>执行结果：</p><pre><code>Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)
</code></pre><p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p><p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p><p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p><p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p><h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h2><p>我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p><p>首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p><p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p><p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p><p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。但是操作系统能同时运行的进程数也是有限的。多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。</p><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p><h3 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数，对于计算密集型任务，最好用运行效率高的C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。对应到Python语言，单线程的异步编程模型称为协程。</p><h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p><p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p><p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p><p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p><p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p><pre><code># task_master.py

import random, time, queue
from multiprocessing.managers import BaseManager

# 发送任务的队列:
task_queue = queue.Queue()
# 接收结果的队列:
result_queue = queue.Queue()

# 从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

# 把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register(&#39;get_task_queue&#39;, callable=lambda: task_queue)
QueueManager.register(&#39;get_result_queue&#39;, callable=lambda: result_queue)
# 绑定端口5000, 设置验证码&#39;abc&#39;:
manager = QueueManager(address=(&#39;&#39;, 5000), authkey=b&#39;abc&#39;)
# 启动Queue:
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
# 放几个任务进去:
for i in range(10):
    n = random.randint(0, 10000)
    print(&#39;Put task %d...&#39; % n)
    task.put(n)
# 从result队列读取结果:
print(&#39;Try get results...&#39;)
for i in range(10):
    r = result.get(timeout=10)
    print(&#39;Result: %s&#39; % r)
# 关闭:
manager.shutdown()
print(&#39;master exit.&#39;)
</code></pre><p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p><p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p><pre><code># task_worker.py

import time, sys, queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:
class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register(&#39;get_task_queue&#39;)
QueueManager.register(&#39;get_result_queue&#39;)

# 连接到服务器，也就是运行task_master.py的机器:
server_addr = &#39;127.0.0.1&#39;
print(&#39;Connect to server %s...&#39; % server_addr)
# 端口和验证码注意保持与task_master.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=b&#39;abc&#39;)
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print(&#39;run task %d * %d...&#39; % (n, n))
        r = &#39;%d * %d = %d&#39; % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print(&#39;task queue is empty.&#39;)
# 处理结束:
print(&#39;worker exit.&#39;)
</code></pre><p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p><p>现在，可以试试分布式进程的工作效果了。先启动<code>task_master.py</code>服务进程：</p><pre><code>$ python3 task_master.py 
Put task 3411...
Put task 1605...
Put task 1398...
Put task 4729...
Put task 5300...
Put task 7471...
Put task 68...
Put task 4219...
Put task 339...
Put task 7866...
Try get results...
</code></pre><p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p><pre><code>$ python3 task_worker.py
Connect to server 127.0.0.1...
run task 3411 * 3411...
run task 1605 * 1605...
run task 1398 * 1398...
run task 4729 * 4729...
run task 5300 * 5300...
run task 7471 * 7471...
run task 68 * 68...
run task 4219 * 4219...
run task 339 * 339...
run task 7866 * 7866...
worker exit.
</code></pre><p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p><pre><code>Result: 3411 * 3411 = 11634921
Result: 1605 * 1605 = 2576025
Result: 1398 * 1398 = 1954404
Result: 4729 * 4729 = 22363441
Result: 5300 * 5300 = 28090000
Result: 7471 * 7471 = 55815841
Result: 68 * 68 = 4624
Result: 4219 * 4219 = 17799961
Result: 339 * 339 = 114921
Result: 7866 * 7866 = 61873956
</code></pre><p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p><p>Queue对象存储在哪？注意到<code>task_worker.py</code>中根本没有创建Queue的代码，所以，Queue对象存储在<code>task_master.py</code>进程中</p><p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p><p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p><p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP/IP简介"></a>TCP/IP简介</h2><p>P协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。</p><p>IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如<code>192.168.0.1</code>实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。</p><p>TCP协议建立在IP协议之上。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。</p><p>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。</p><p>一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。</p><p>端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个TCP报文来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。</p><p>一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。</p><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>当我们在浏览器中访问新浪时，我们的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。</p><p>要创建一个基于TCP连接的Socket，可以这样做：</p><pre><code># 导入socket库:
import socket

# 创建一个socket:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #AF_INET指定使用IPv4协议，SOCK_STREAM指定使用面向流的TCP协议
# 建立连接:
s.connect((&#39;www.sina.com.cn&#39;, 80)) #80是Web服务的标准端口
# 发送数据
s.send(b&#39;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&#39;)
# 接收数据:
buffer = []
while True:
    # 每次最多接收1k字节:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b&#39;&#39;.join(buffer)
# 关闭连接
s.close()
# 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件
header, html = data.split(b&#39;\r\n\r\n&#39;, 1)
print(header.decode(&#39;utf-8&#39;))
with open(&#39;sina.html&#39;, &#39;wb&#39;) as f:
    f.write(html)
</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p><p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p><p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p><p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。</p><p>首先，创建一个基于IPv4和TCP协议的Socket：</p><pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre><p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用<code>0.0.0.0</code>绑定到所有的网络地址，还可以用<code>127.0.0.1</code>绑定到本机地址。<code>127.0.0.1</code>是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p><p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用<code>9999</code>这个端口号。请注意，小于<code>1024</code>的端口号必须要有管理员权限才能绑定：</p><pre><code># 监听端口:
s.bind((&#39;127.0.0.1&#39;, 9999))
</code></pre><p>紧接着，调用<code>listen()</code>方法开始监听端口，传入的参数指定等待连接的最大数量：</p><pre><code>s.listen(5)
print(&#39;Waiting for connection...&#39;)
</code></pre><p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，<code>accept()</code>会等待并返回一个客户端的连接:</p><pre><code>while True:
    # 接受一个新连接:
    sock, addr = s.accept()
    # 创建新线程来处理TCP连接:
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()
</code></pre><p>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：</p><pre><code>def tcplink(sock, addr):
    print(&#39;Accept new connection from %s:%s...&#39; % addr)
    sock.send(b&#39;Welcome!&#39;)
    while True:
        data = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode(&#39;utf-8&#39;) == &#39;exit&#39;:
            break
        sock.send((&#39;Hello, %s!&#39; % data.decode(&#39;utf-8&#39;)).encode(&#39;utf-8&#39;))
    sock.close()
    print(&#39;Connection from %s:%s closed.&#39; % addr)
</code></pre><p>连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上<code>Hello</code>再发送给客户端。如果客户端发送了<code>exit</code>字符串，就直接关闭连接。</p><p>要测试这个服务器程序，我们还需要编写一个客户端程序：</p><pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接:
s.connect((&#39;127.0.0.1&#39;, 9999))
# 接收欢迎消息:
print(s.recv(1024).decode(&#39;utf-8&#39;))
for data in [b&#39;Michael&#39;, b&#39;Tracy&#39;, b&#39;Sarah&#39;]:
    # 发送数据:
    s.send(data)
    print(s.recv(1024).decode(&#39;utf-8&#39;))
s.send(b&#39;exit&#39;)
s.close()
</code></pre><p>我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了：</p><p><img src="/Users/xuhaidong/Downloads/001410425071613d61a12d8f77b4cf8ad20c0b3233782b9000.png" alt="001410425071613d61a12d8f77b4cf8ad20c0b3233782b9000"></p><p>需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。</p><p>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。</p><h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>相对TCP，UDP则是面向无连接的协议。使用UDP协议时，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p><p>我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：</p><pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 绑定端口:
s.bind((&#39;127.0.0.1&#39;, 9999))
</code></pre><p>创建Socket时，<code>SOCK_DGRAM</code>指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用<code>listen()</code>方法，而是直接接收来自任何客户端的数据：</p><pre><code>print(&#39;Bind UDP on 9999...&#39;)
while True:
    # 接收数据:
    data, addr = s.recvfrom(1024)
    print(&#39;Received from %s:%s.&#39; % addr)
    s.sendto(b&#39;Hello, %s!&#39; % data, addr)
</code></pre><p><code>recvfrom()</code>方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用<code>sendto()</code>就可以把数据用UDP发给客户端。</p><p>注意这里省掉了多线程，因为这个例子很简单。</p><p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用<code>connect()</code>，直接通过<code>sendto()</code>给服务器发数据：</p><pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b&#39;Michael&#39;, b&#39;Tracy&#39;, b&#39;Sarah&#39;]:
    # 发送数据:
    s.sendto(data, (&#39;127.0.0.1&#39;, 9999))
    # 接收数据:
    print(s.recv(1024).decode(&#39;utf-8&#39;))
s.close()
</code></pre><p>从服务器接收数据仍然调用<code>recv()</code>方法。</p><p>UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。</p><h1 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h1><p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。而如何定义数据的存储格式就是一个大问题。</p><p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p><h2 id="使用SQLite"><a href="#使用SQLite" class="headerlink" title="使用SQLite"></a>使用SQLite</h2><p>SQLite是一种嵌入式数据库，它的数据库就是一个文件。Python就内置了SQLite3</p><p>表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。</p><p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p><p>Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</p><p>我们在Python交互式命令行实践一下：</p><pre><code># 导入SQLite驱动:
&gt;&gt;&gt; import sqlite3
# 连接到SQLite数据库
# 数据库文件是test.db
# 如果文件不存在，会自动在当前目录创建:
&gt;&gt;&gt; conn = sqlite3.connect(&#39;test.db&#39;)
# 创建一个Cursor:
&gt;&gt;&gt; cursor = conn.cursor()
# 执行一条SQL语句，创建user表:
&gt;&gt;&gt; cursor.execute(&#39;create table user (id varchar(20) primary key, name varchar(20))&#39;)
&lt;sqlite3.Cursor object at 0x10f8aa260&gt;
# 继续执行一条SQL语句，插入一条记录:
&gt;&gt;&gt; cursor.execute(&#39;insert into user (id, name) values (\&#39;1\&#39;, \&#39;Michael\&#39;)&#39;)
&lt;sqlite3.Cursor object at 0x10f8aa260&gt;
# 通过rowcount获得插入的行数:
&gt;&gt;&gt; cursor.rowcount
1
# 关闭Cursor:
&gt;&gt;&gt; cursor.close()
# 提交事务:
&gt;&gt;&gt; conn.commit()
# 关闭Connection:
&gt;&gt;&gt; conn.close()
</code></pre><p>我们再试试查询记录：</p><pre><code>&gt;&gt;&gt; conn = sqlite3.connect(&#39;test.db&#39;)
&gt;&gt;&gt; cursor = conn.cursor()
# 执行查询语句:
&gt;&gt;&gt; cursor.execute(&#39;select * from user where id=?&#39;, (&#39;1&#39;,))
&lt;sqlite3.Cursor object at 0x10f8aa340&gt;
# 获得查询结果集:
&gt;&gt;&gt; values = cursor.fetchall()
&gt;&gt;&gt; values
[(&#39;1&#39;, &#39;Michael&#39;)]
&gt;&gt;&gt; cursor.close()
&gt;&gt;&gt; conn.close()
</code></pre><p>使用Python的DB-API时，只要搞清楚<code>Connection</code>和<code>Cursor</code>对象，打开后一定记得关闭，就可以放心地使用。</p><p>使用<code>Cursor</code>对象执行<code>insert</code>，<code>update</code>，<code>delete</code>语句时，执行结果由<code>rowcount</code>返回影响的行数，就可以拿到执行结果。</p><p>使用<code>Cursor</code>对象执行<code>select</code>语句时，通过<code>featchall()</code>可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。</p><p>如果SQL语句带有参数，那么需要把参数按照位置传递给<code>execute()</code>方法，有几个<code>?</code>占位符就必须对应几个参数，例如：</p><pre><code>cursor.execute(&#39;select * from user where name=? and pwd=?&#39;, (&#39;abc&#39;, &#39;password&#39;))
</code></pre><h2 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h2><p>MySQL是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于SQLite。MySQL内部有多种数据库引擎，最常用的引擎是支持数据库事务的InnoDB。</p><p>演示如何连接到MySQL服务器的test数据库：</p><pre><code># 导入MySQL驱动:
&gt;&gt;&gt; import mysql.connector
# 注意把password设为你的root口令:
&gt;&gt;&gt; conn = mysql.connector.connect(user=&#39;root&#39;, password=&#39;password&#39;, database=&#39;test&#39;)
&gt;&gt;&gt; cursor = conn.cursor()
# 创建user表:
&gt;&gt;&gt; cursor.execute(&#39;create table user (id varchar(20) primary key, name varchar(20))&#39;)
# 插入一行记录，注意MySQL的占位符是%s:
&gt;&gt;&gt; cursor.execute(&#39;insert into user (id, name) values (%s, %s)&#39;, [&#39;1&#39;, &#39;Michael&#39;])
&gt;&gt;&gt; cursor.rowcount
1
# 提交事务:
&gt;&gt;&gt; conn.commit()
&gt;&gt;&gt; cursor.close()
# 运行查询:
&gt;&gt;&gt; cursor = conn.cursor()
&gt;&gt;&gt; cursor.execute(&#39;select * from user where id = %s&#39;, (&#39;1&#39;,))
&gt;&gt;&gt; values = cursor.fetchall()
&gt;&gt;&gt; values
[(&#39;1&#39;, &#39;Michael&#39;)]
# 关闭Cursor和Connection:
&gt;&gt;&gt; cursor.close()
True
&gt;&gt;&gt; conn.close()
</code></pre><h2 id="使用SQLAIchemy"><a href="#使用SQLAIchemy" class="headerlink" title="使用SQLAIchemy"></a>使用SQLAIchemy</h2><p>数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如，包含<code>id</code>和<code>name</code>的<code>user</code>表：</p><pre><code>[
    (&#39;1&#39;, &#39;Michael&#39;),
    (&#39;2&#39;, &#39;Bob&#39;),
    (&#39;3&#39;, &#39;Adam&#39;)
]
</code></pre><p>但是用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来：</p><pre><code>class User(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

[
    User(&#39;1&#39;, &#39;Michael&#39;),
    User(&#39;2&#39;, &#39;Bob&#39;),
    User(&#39;3&#39;, &#39;Adam&#39;)
]
</code></pre><p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。在Python中，最有名的ORM框架是SQLAlchemy。</p><p>第一步，导入SQLAlchemy，并初始化DBSession：</p><pre><code># 导入:
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类:
Base = declarative_base()

# 定义User对象:
class User(Base):
    # 表的名字:
    __tablename__ = &#39;user&#39;

    # 表的结构:
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# 初始化数据库连接:
engine = create_engine(&#39;mysql+mysqlconnector://root:password@localhost:3306/test&#39;)
# 创建DBSession类型:
DBSession = sessionmaker(bind=engine)
</code></pre><p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：</p><pre><code>class School(Base):
    __tablename__ = &#39;school&#39;
    id = ...
    name = ...
</code></pre><p><code>create_engine()</code>用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p><pre><code>&#39;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&#39;
</code></pre><p>你只需要根据需要替换掉用户名、口令等信息即可。</p><p>下面，我们看看如何向数据库表中添加一行记录。</p><p>由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象：</p><pre><code># 创建session对象:
session = DBSession()
# 创建新User对象:
new_user = User(id=&#39;5&#39;, name=&#39;Bob&#39;)
# 添加到session:
session.add(new_user)
# 提交即保存到数据库:
session.commit()
# 关闭session:
session.close()
</code></pre><p>可见，关键是获取session，然后把对象添加到session，最后提交并关闭。<code>DBSession</code>对象可视为当前数据库连接。</p><p>如何从数据库表中查询数据呢？有了ORM，查询出来的可以不再是tuple，而是<code>User</code>对象。SQLAlchemy提供的查询接口如下：</p><pre><code># 创建Session:
session = DBSession()
# 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
user = session.query(User).filter(User.id==&#39;5&#39;).one()
# 打印类型和对象的name属性:
print(&#39;type:&#39;, type(user))
print(&#39;name:&#39;, user.name)
# 关闭Session:
session.close()
</code></pre><p>运行结果如下：</p><pre><code>type: &lt;class &#39;__main__.User&#39;&gt;
name: Bob
</code></pre><p>ORM就是把数据库表的行与相应的对象建立关联，互相转换。</p><p>由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。</p><p>例如，如果一个User拥有多个Book，就可以定义一对多关系如下：</p><pre><code>class User(Base):
    __tablename__ = &#39;user&#39;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多:
    books = relationship(&#39;Book&#39;)

class Book(Base):
    __tablename__ = &#39;book&#39;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    user_id = Column(String(20), ForeignKey(&#39;user.id&#39;))
</code></pre><p>当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。</p><h1 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h1><p>随着互联网的兴起，人们发现，Client/Serve架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。</p><p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。</p><h2 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h2><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>跟踪了新浪的首页，我们来总结一下HTTP请求的流程：</p><p>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p><p>方法：GET还是POST，GET仅请求资源，POST会附带用户数据；</p><p>路径：/full/url/path；</p><p>域名：由Host头指定：Host: <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p><p>以及其他相关的Header；</p><p>如果是POST，那么请求还包括一个Body，包含用户数据。</p><p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p><p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p><p>响应类型：由Content-Type指定；</p><p>以及其他相关的Header；</p><p>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</p><p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p><p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p><p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是<code>http://www.sina.com.cn/</code>的首页，但是新浪在HTML中可以链入其他服务器的资源，比如<code>&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</code>，从而将请求压力分散到各个服务器上。</p><h3 id="HTTP格式"><a href="#HTTP格式" class="headerlink" title="HTTP格式"></a>HTTP格式</h3><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p><p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p><pre><code>GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
</code></pre><p>每个Header一行一个，换行符是<code>\r\n</code>。</p><p>HTTP POST请求的格式：</p><pre><code>POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre><p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body。</p><p>HTTP响应的格式：</p><pre><code>200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre><p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。请再次注意，Body的数据类型由<code>Content-Type</code>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p><p>当存在<code>Content-Encoding</code>时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到<code>Content-Encoding: gzip</code>时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p><h2 id="WSGI接口"><a href="#WSGI接口" class="headerlink" title="WSGI接口"></a>WSGI接口</h2><p>一个Web应用的本质就是：</p><ol><li>浏览器发送一个HTTP请求；</li><li>服务器收到请求，生成一个HTML文档；</li><li>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</li><li>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</li></ol><p>所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。 <code>Web 服务器</code> 是没办法直接解释 <code>Python</code> 脚本的，于是就有了 <code>WSGI</code> 这一层，它负责把请求封装成 <code>Python</code> 可以解释的一个数据结构，然后调度 <code>Python 应用</code> 进行处理，再让 <code>Python 应用</code> 根据一定的格式规则封装成一个响应体， <code>WSGI</code> 模块解释过后再把它返回给服务器，最后服务器再返回给客户端。</p><p>WSGI：Web Server Gateway Interface规定了Web服务器到Web框架之间通信的规则。Web服务器网关接口定义非常简单，只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：</p><pre><code>def application(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    return [b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;]
</code></pre><p><code>application()</code>函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p><ul><li>environ：一个包含所有HTTP请求信息的<code>dict</code>对象；</li><li>start_response：一个发送HTTP响应的函数。</li></ul><p>在<code>application()</code>函数中，调用：</p><pre><code>start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
</code></pre><p>就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次<code>start_response()</code>函数。<code>start_response()</code>函数接收两个参数，一个是HTTP响应码，一个是一组<code>list</code>表示的HTTP Header，每个Header用一个包含两个<code>str</code>的<code>tuple</code>表示。</p><p>通常情况下，都应该把<code>Content-Type</code>Header 发送给浏览器。其他很多常用的HTTP Header也应该发送。</p><p>然后，函数的返回值<code>b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;</code>将作为HTTP响应的Body发送给浏览器。</p><p>有了WSGI，我们关心的就是如何从<code>environ</code>这个<code>dict</code>对象拿到HTTP请求信息，然后构造HTML，通过<code>start_response()</code>发送Header，最后返回Body。</p><p>整个<code>application()</code>函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p><p>不过，等等，这个<code>application()</code>函数怎么调用？如果我们自己调用，两个参数<code>environ</code>和<code>start_response</code>我们没法提供，返回的<code>bytes</code>也没法发给浏览器。</p><p>所以<code>application()</code>函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的<code>application()</code>函数真的可以把HTML输出到浏览器，所以，要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。</p><p>好消息是Python内置了一个WSGI服务器，这个模块叫wsgiref，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。</p><h3 id="运行WSGI服务"><a href="#运行WSGI服务" class="headerlink" title="运行WSGI服务"></a>运行WSGI服务</h3><p>我们先编写<code>hello.py</code>，实现Web应用程序的WSGI处理函数：</p><pre><code># hello.py

def application(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    return [b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;]
</code></pre><p>然后，再编写一个<code>server.py</code>，负责启动WSGI服务器，加载<code>application()</code>函数：</p><pre><code># server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server(&#39;&#39;, 8000, application)
print(&#39;Serving HTTP on port 8000...&#39;)
# 开始监听HTTP请求:
httpd.serve_forever()
</code></pre><p>确保以上两个文件在同一个目录下，然后在命令行输入<code>python server.py</code>来启动WSGI服务器，启动成功后，打开浏览器，输入<code>http://localhost:8000/</code>，就可以看到结果了</p><h2 id="使用Web框架"><a href="#使用Web框架" class="headerlink" title="使用Web框架"></a>使用Web框架</h2><p>了解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p><p>但是如何处理HTTP请求不是问题，问题是如何处理100个不同的URL。</p><p>每一个URL可以对应GET和POST请求，当然还有PUT、DELETE等请求，但是我们通常只考虑最常见的GET和POST请求。</p><p>一个最简单的想法是从<code>environ</code>变量里取出HTTP请求的信息，然后逐个判断：</p><pre><code>def application(environ, start_response):
    method = environ[&#39;REQUEST_METHOD&#39;]
    path = environ[&#39;PATH_INFO&#39;]
    if method==&#39;GET&#39; and path==&#39;/&#39;:
        return handle_home(environ, start_response)
    if method==&#39;POST&#39; and path=&#39;/signin&#39;:
        return handle_signin(environ, start_response)
    ...
</code></pre><p>只是这么写下去代码是肯定没法维护了,原因是因为WSGI提供的接口虽然比HTTP接口高级了不少，但和Web App的处理逻辑比，还是比较低级，我们需要在WSGI接口之上能进一步抽象，让我们专注于用一个函数处理一个URL，至于URL到函数的映射，就交给Web框架来做。</p><p>写一个<code>app.py</code>，处理3个URL，分别是：</p><ul><li><code>GET /</code>：首页，返回<code>Home</code>；</li><li><code>GET /signin</code>：登录页，显示登录表单；</li><li><code>POST /signin</code>：处理登录表单，显示登录结果。</li></ul><p>注意噢，同一个URL<code>/signin</code>分别有GET和POST两种请求，映射到两个处理函数中。</p><p>Flask通过Python的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000" target="_blank" rel="noopener">装饰器</a>在内部自动地把URL和函数给关联起来，所以，我们写出来的代码就像这样：</p><pre><code>from flask import Flask
from flask import request

app = Flask(__name__)

@app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def home():
    return &#39;&lt;h1&gt;Home&lt;/h1&gt;&#39;

@app.route(&#39;/signin&#39;, methods=[&#39;GET&#39;])
def signin_form():
    return &#39;&#39;&#39;&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
              &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
              &lt;/form&gt;&#39;&#39;&#39;

@app.route(&#39;/signin&#39;, methods=[&#39;POST&#39;])
def signin():
    # 需要从request对象读取表单内容：
    if request.form[&#39;username&#39;]==&#39;admin&#39; and request.form[&#39;password&#39;]==&#39;password&#39;:
        return &#39;&lt;h3&gt;Hello, admin!&lt;/h3&gt;&#39;
    return &#39;&lt;h3&gt;Bad username or password.&lt;/h3&gt;&#39;

if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre><p>运行<code>python app.py</code>，Flask自带的Server在端口<code>5000</code>上监听：</p><pre><code>$ python app.py 
 * Running on http://127.0.0.1:5000/
</code></pre><p>打开浏览器，输入首页地址<code>http://localhost:5000/</code>显示首页；输入<code>http://localhost:5000/signin</code>，会显示登录表单。</p><p>有了Web框架，我们在编写Web应用时，注意力就从WSGI处理函数转移到URL+对应的处理函数，这样，编写Web App就更加简单了。</p><p>在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过<code>request.form[&#39;name&#39;]</code>来获取表单的内容。</p><h2 id="Web框架设计"><a href="#Web框架设计" class="headerlink" title="Web框架设计"></a>Web框架设计</h2><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><ol><li>异常处理：程序的健壮性</li><li>WSG 入口模块</li><li>URL 路由：在 <code>Web 框架</code>中，路由的作用其实就是从 <code>URL</code> 与处理函数的映射表之中，找到从服务器获取到的请求中的 <code>URL</code> 相匹配的处理函数。作为从 <code>WSGI</code> 入口获取到请求之后的下一步。</li><li>视图：为了低耦合度，就需要实现模块化替换和可继承的 <code>URL</code> 处理逻辑，也就是视图。</li><li>模版引擎：实现业务逻辑层和用户界面（表现层）相关的代码进行分离。</li><li>会话维持：对于 <code>HTTP 协议</code> 这种无状态的通信协议，我们如果要做到识别每一个请求是由哪一个客户端发起的，然后根据这个客户端本身的信息进行处理并返回对应的内容，比如登录验证通过之后，在登出之前都不需要每一次都重新登录验证一下这种功能，就需要实现 <code>HTTP 会话</code> 了，也就是要实现对消息报头中的 <code>Cookie</code> 字段进行操作的模块。</li><li>数据库模块</li></ol><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><p>使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户。</p><p></p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://xhdnoah.github.io/2018/09/23/Python/%20电子月亮%20python-learning" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2018/10/17/DOM/" title="《DOM 编程艺术》笔记"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: 《DOM 编程艺术》笔记</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2018/09/06/Git/" title="git-learning">下一篇: git-learning&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="https://cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script><script src="https://cdn.bootcss.com/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="https://cdn.bootcss.com/jquery-migrate/1.2.1/jquery-migrate.min.js"></script><script src="https://cdn.bootcss.com/jquery.appear/0.3.3/jquery.appear.js"></script><script src="/js/typography.js"></script></body></html>