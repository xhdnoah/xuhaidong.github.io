<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Noah Xu"><title>《DOM 编程艺术》笔记 · 电子月亮</title><meta name="description" content="获取元素getElementById: 返回一个对象，对应document 对象里一个独一无二的元素getElementByTagName: 返回一个对象数组，每个对象对应文档里有着给定标签的元素getElementByClassName：返回一个具有相同类名的元素的数组
获取和设置属性object"><meta name="keywords" content><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title"></a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">Electronic Moon</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://github.com/xhdnoah" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="http://xhdnoah.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>《DOM 编程艺术》笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2018-10-17</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/DOM/" title="DOM" class="a-tag">DOM</a><span>&nbsp;</span></span></p><p class="post-abstract"></p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>getElementById: 返回一个对象，对应document 对象里一个独一无二的元素<br>getElementByTagName: 返回一个对象数组，每个对象对应文档里有着给定标签的元素<br>getElementByClassName：返回一个具有相同类名的元素的数组</p>
<h3 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h3><p>object.getAttribute(attribute)<br>object.setAttribute(attribute,value)</p>
<h3 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h3><p>event = Javascript statement(s)<br>onclick = “function(this); return false” this 的含义是“这个对象”；return false 防止默认行为被触发</p>
<h3 id="childNodes-属性"><a href="#childNodes-属性" class="headerlink" title="childNodes 属性"></a>childNodes 属性</h3><p>element.childNodes: 用来获取任何一个元素所有子元素，它是一个 包含这个元素全部子元素的数组</p>
<h3 id="nodeType-属性"><a href="#nodeType-属性" class="headerlink" title="nodeType 属性"></a>nodeType 属性</h3><p>元素节点：1；属性节点：2；文本节点：3；</p>
<h3 id="nodeValue-属性"><a href="#nodeValue-属性" class="headerlink" title="nodeValue 属性"></a>nodeValue 属性</h3><p>得到一个节点的值</p>
<h3 id="firstChild-lastChild"><a href="#firstChild-lastChild" class="headerlink" title="firstChild,lastChild"></a>firstChild,lastChild</h3><p>相当于 <code>node.childNodes[0],node.childeNodes[node.childNodes.length-1]</code></p>
<h2 id="平稳退化"><a href="#平稳退化" class="headerlink" title="平稳退化"></a>平稳退化</h2><p>把 herf 属性设置为一个真实存在的值可以帮助图片库平稳退化</p>
<h2 id="分离-Javascript"><a href="#分离-Javascript" class="headerlink" title="分离 Javascript"></a>分离 Javascript</h2><p>对于内嵌事件处理函数，能否用一个“挂钩”，让JS调用行为与HTML结构和内容分<br>如果想把一个时间添加到某个带有特定属性的元素上:<br><code>getElementById(id).event = action</code><br>如果事件涉及多个元素，可以用 <code>getElementByClass</code> 和<code>getAttribute</code>  把事件添加到特定属性的一组元素》<br>具体步骤：</p>
<ol>
<li>把文档所有相同标签的元素放进数组</li>
<li>遍历数组</li>
<li>如果某元素的 class 属性等于特定值，则添加事件<br>同时要让这些代码在HTML文档全部加载到浏览器之后马上执行，当 window 对象触发 onload 事件时， document 对象已存在。所以把JS代码打包到 prepareLinks 函数，并把函数添加到 onload 事件 <code>window.onload = prepareLinks</code> <h2 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h2>对象检测<br><code>if (!method) return false;</code> 插入 if 语句检查浏览器是否理解这个方法，不理解则中途退出函数<h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><strong>尽量少访问DOM和减少标记</strong>：只要是查询DOM中的元素，浏览器都会搜索整个DOM树，更好的办法是把第一次搜索的结果保存在一个变量中，重复使用。在多个函数都会取得一组类似元素的情况下，可以把搜索结果保存在一个全局变量里。<br><strong>合并和放置脚本</strong>：把所有的<code>&lt;script&gt;</code>标签放到文档末尾，<code>&lt;/body&gt;</code>标记之前，可以让页面更快。<br><strong>压缩脚本</strong>：一个工作副本可以修改并注释，一个精简副本用于放在站点。</li>
</ol>
<p>共享 onload 事件<br>addLoadEvent 函数，只有一个参数：打算在页面加载完毕时执行的函数的名字。</p>
<pre><code>function addLoadEvent(func){
    var oldonload = window.onload; # 把现有window.onload事件处理函数值存入变量 oldonload
    if (typeof window.onload != ‘function’){
        window.onload = func; # 如果处理函数没有绑定函数，把新函数添加给它
    } else {
        window.onload = function(){ # 新函数追加到现有指令的末尾
        oldload();
        func();
        }
    }
}
</code></pre><p>addLoadEvent(firstFunction);<br>addLoadEvent(secondFunction);</p>
<h3 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML-DOM"></a>HTML-DOM</h3><p>DOM Core:document.getElementByTagName(“form”)<br>HTML-DOM:document.forms</p>
<h1 id="动态创建标记"><a href="#动态创建标记" class="headerlink" title="动态创建标记"></a>动态创建标记</h1><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>document.write()，缺点是违背了“行为与表现分离”<br>innerHTML 属性：可以用来读、写某给定元素里的HTML内容，没有DOM方法精确</p>
<h2 id="DOM方法"><a href="#DOM方法" class="headerlink" title="DOM方法"></a>DOM方法</h2><p>DOM看到的文档就是一颗节点树，想在节点树上添加内容，必须插入新的节点，想添加一些标记到文档，必须插入元素节点。</p>
<h3 id="createElement-方法"><a href="#createElement-方法" class="headerlink" title="createElement 方法"></a>createElement 方法</h3><p>var para = document.creatElement(“nodeName”)</p>
<h3 id="appendChild-方法"><a href="#appendChild-方法" class="headerlink" title="appendChild 方法"></a>appendChild 方法</h3><p>parent.appendChild(child)</p>
<h3 id="createTextNode-方法"><a href="#createTextNode-方法" class="headerlink" title="createTextNode 方法"></a>createTextNode 方法</h3><p>var txt = document.createTextNode(“text”)<br>para.appendChild(txt);</p>
<h3 id="insertBefore-方法"><a href="#insertBefore-方法" class="headerlink" title="insertBefore 方法"></a>insertBefore 方法</h3><p>parentElement.insertBefore(newElement,targetELement)<br>在DOM里，元素节点的父元素必须也是元素节点。所以这里的父元素就是targetElement元素的parentNode属性值。</p>
<h3 id="编写insertAfter方法"><a href="#编写insertAfter方法" class="headerlink" title="编写insertAfter方法"></a>编写insertAfter方法</h3><pre><code>function insertAfter(newElement,targetElement){
    var parent = targetElement.parentNode;
    if(parent.lastchild == targetElement){
    parent.lastchild == newElement;
}else{
    parent.insertBefore(newElement,targetElement.nextSibling);
}
}
</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>异步加载页面内容</p>
<h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><p>充当浏览器中脚本（客户端）与服务器之间的中间人角色<br><code>var request = getHTTPObject();</code><br>XMLHttpRequest对象有许多方法。其中最有用的是open方法，用来指定服务器上将要访问的文件，指定请求类型：GET，POST，SEND，方法的第三个参数用于指定请求是否已异步的方式发送和处理。<br><code>request.open(&quot;GET&quot;,&quot;example.txt&quot;,true);</code><br><code>onreadystatechange</code>是一个事件处理函数，他会在服务器给XMLHttpRequest对象送回响应的时候被触发执行。</p>
<pre><code>request,onreadystatechange = function(){
​   //处理响应
}；
</code></pre><p>也可以引用一个函数<br><code>onreadystatechange = doSomething; #指定函数引用时，不要加括号，括号表示立即调用函数。</code><br>在指定了请求目标、明确如何处理响应之后，用<code>send</code>方法发送请求<br>浏览器在不同阶段更新 readyState 属性的值：</p>
<ol start="0">
<li>未初始化</li>
<li>正在加载</li>
<li>加载完毕</li>
<li>正在交互</li>
<li>完成<br>访问服务器发送回的数据通过两个属性完成：<code>responseText</code>属性用于保存文字符串形式的数据，<code>responseXML</code>属性用于保存 <code>Content-Type</code>头部中指定为”text/xml”的数据<br>异步请求容易忽略异步性，脚本在发送 XMLHttpRequest 请求之后，仍然继续执行不等待响应返回。如果其他脚本依赖与服务器上的响应，就得把相应的代码转移到指定给 onreadystatechange 属性的函数中</li>
</ol>
<h1 id="充实文档的内容"><a href="#充实文档的内容" class="headerlink" title="充实文档的内容"></a>充实文档的内容</h1><p><strong>渐进增强</strong>：内容结构是最核心的部分，Javascript脚本只应该用来充实文档内容，避免使用DOM技术创建核心内容</p>
<h2 id="把“不可见”变“可见”"><a href="#把“不可见”变“可见”" class="headerlink" title="把“不可见”变“可见”"></a>把“不可见”变“可见”</h2><p>使用DOM技术为网页添加实用小部件</p>
<ul>
<li>得到隐藏在属性里的信息</li>
<li>创建标记封装这些信息</li>
<li>把这些标记插入到文档</li>
</ul>
<h1 id="CSS-DOM"><a href="#CSS-DOM" class="headerlink" title="CSS-DOM"></a>CSS-DOM</h1><h2 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h2><p><code>element.style.property # style 属性是一个对象</code></p>
<h3 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h3><p>当引用一个中间带减号的 CSS 属性时，DOM 要求驼峰命名法<br>style属性只能返回内嵌样式</p>
<h3 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h3><p>element.style.property = value<br>style 对象的属性值永远是一个字符串</p>
<h2 id="何时用DOM脚本设置样式"><a href="#何时用DOM脚本设置样式" class="headerlink" title="何时用DOM脚本设置样式"></a>何时用DOM脚本设置样式</h2><h3 id="1-根据元素在节点树里的位置来设置样式"><a href="#1-根据元素在节点树里的位置来设置样式" class="headerlink" title="1. 根据元素在节点树里的位置来设置样式"></a>1. 根据元素在节点树里的位置来设置样式</h3><h3 id="2-根据某种条件反复设置这些样式"><a href="#2-根据某种条件反复设置这些样式" class="headerlink" title="2. 根据某种条件反复设置这些样式"></a>2. 根据某种条件反复设置这些样式</h3><h2 id="className属性"><a href="#className属性" class="headerlink" title="className属性"></a>className属性</h2><p>如果想要更换DOM脚本设置的样式，可以通过Javascript代码去更新元素的class属性</p>
<h1 id="用Javascript实现动画效果"><a href="#用Javascript实现动画效果" class="headerlink" title="用Javascript实现动画效果"></a>用Javascript实现动画效果</h1><p>动画就是让元素的位置随时间不断变化</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>网页元素的位置由CSS设置</li>
<li>相比static，relative定位的元素还可以通过float脱标</li>
<li>实现动画效果，必须“创造”出时间间隔<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3>setTimeout函数能够让某个函数经过一段预定时间后才开始执行<br><code>variable = setTimeout(&quot;function&quot;,interval)    # 第一个参数通常是字符串，内容为要执行的函数名，绝大多数时候，把这个函数调用赋值给一个变量</code><br><code>clearTimeout(variable)   # 取消“等待执行”队列里的某个函数</code><h3 id="时间递增量"><a href="#时间递增量" class="headerlink" title="时间递增量"></a>时间递增量</h3>真正的动画效果是一个渐变的过程。元素从出发点逐步移动到目的地：</li>
</ul>
<ol>
<li>获取元素当前位置</li>
<li>如果元素已经到达目的地，则退出函数</li>
<li>如果元素尚未到达目的地，则把它向目的地移近一点（1px)</li>
<li>经过一段时间间隔后从步骤1开始重复上述步骤</li>
</ol>
<p>确定元素位置，可以通过查询style.top,style.left并赋值给变量，再通过parseInt把字符串里的数值信息提取出来</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象出一个通用函数moveElement，列出每次调用可能变化的东西：</p>
<ol>
<li>打算移动的元素ID elementID</li>
<li>该元素目的地的“左”位置 final_x</li>
<li>该元素目的地的“上”位置 final_y</li>
<li>两次移动之间的停顿时间 interval</li>
</ol>
<h2 id="增强页面效果"><a href="#增强页面效果" class="headerlink" title="增强页面效果"></a>增强页面效果</h2><p>我们有个包含一系列链接的网页，当用户把鼠标指针悬停在其中的某个链接上时，想展示一张预览图片。如果想要做得更快更好：</p>
<ol>
<li>为所有预览图片生成一张“集体照”形式图片</li>
<li>隐藏这张“集体照”图片绝大部分</li>
<li>当用户把鼠标指针悬停在某链接的上方，只显示这张“集体照”图片的相应部分</li>
</ol>
<p>“集体照”由 三张预览图和一张默认图片构成，每次我们只想让这张图片的某个100*100像素部分出现，Javascript无法做到，但CSS可以</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS的overflow属性用来处理一个元素的尺寸超出其容器尺寸的情况<br><code>overflow:visible,hidden,scroll,auto; # 设为hidden可以确保内容被裁剪</code><br>首先需要把这张图片放到一个容器元素div，div元素相对定位，子图片绝对定位。<br>接下来解决网页对用户的操作行为作出正确响应，当用户把鼠标指针悬停在链接上把图片中与之对应的部分显示出来。这是一种行为变化，用JS和DOM实现</p>
<h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><p>调用moveElement函数行为，与每个链接的 onmouseover事件关联</p>
<h3 id="变量作用域问题"><a href="#变量作用域问题" class="headerlink" title="变量作用域问题"></a>变量作用域问题</h3><p>既不能使用全局变量，也不能使用局部变量，我们需要一种介于二者之间的东西，一个只与正在被移动的元素有关的变量，那就是“属性”。<br>Javascript允许我们为元素创建属性：element.property = value;<br>我们把变量movement从一个全局变量改为正在被移动的元素的属性elem.movement，这样就可以测试存在并使用 clearTimeout<br>于是，不管 moveElement 正在移动哪个元素，都将获得一个movement 属性。如果函数执行时 movement 属性已存在就用clearTimeout 函数对其复位</p>
<h3 id="改进动画效果"><a href="#改进动画效果" class="headerlink" title="改进动画效果"></a>改进动画效果</h3><p>如果元素与目的地距离较远，就每次前进一大步；如果较近，前进一小步<br>首先，需要计算出元素与目的地之间距离 dist = final_x - xpos;<br>Math.ceil(number); 返回向“大于”方向舍入最接近的整数<br>如果xpos大于final_x ，dist = xpos - final_x</p>
<p></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://xhdnoah.github.io/2018/10/17/DOM/%20电子月亮%20《DOM 编程艺术》笔记" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2018/10/19/css-learning/" title="css-learning"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: css-learning</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2018/09/23/Python/" title="python-learning">Next post: python-learning&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="http://xhdnoah.github.io" rel="noopener noreferrer">Noah Xu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>